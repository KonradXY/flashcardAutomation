<html>
<head>
  <title>Evernote Export</title>
  <basefont face="Segoe UI" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/308716 (en-US, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: Segoe UI;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="516"/>

<div>
<span><div><h2><span style="font-weight: bold;">22 - Chain of Responsibility Pattern</span></h2><div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 846px;"></col></colgroup><tbody><tr><td style="width: 846px; padding: 8px; border: 1px solid;"><div>D:   can you give the gof definition of the chain of responsibility pattern ?</div></td></tr><tr><td style="width: 846px; padding: 8px; border: 1px solid;"><div>R: Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it.</div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 846px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div>D: can you show an uml diagram of the chain of responsibility pattern ?  </div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div>R: Let’s consider the scenario that is discussed in the computer-world example. Let’s further assume that in the following example, you can process both normal and high-priority issues that may come from either the email or fax pillar.</div><div><br/></div><div style="text-align: center;"><img src="22 - Chain of Responsibility Pattern_files/Image.jpg" type="image/jpeg" data-filename="Image.jpg" style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; -webkit-font-smoothing: antialiased; border: 0px; height: 44em; max-width: 100%; vertical-align: middle; margin: 0px; padding: 2px;" width="613"/></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 846px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div>D:   can you show an implementation of the chain of responsibility pattern ?</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div>R: Here’s the implementation.</div><div><font face="Source Code Pro"><br/></font></div><div><font face="Source Code Pro">package jdp2e.chainofresponsibility.demo;</font></div><div><font face="Source Code Pro">enum MessagePriority</font></div><div><font face="Source Code Pro">{</font></div><div><font face="Source Code Pro">   <span style="font-style: italic;">NORMAL</span>,</font></div><div><font face="Source Code Pro">   <span style="font-style: italic;">HIGH</span></font></div><div><font face="Source Code Pro">}</font></div><div><font face="Source Code Pro">class Message</font></div><div><font face="Source Code Pro">{</font></div><div><font face="Source Code Pro">   public String text;</font></div><div><font face="Source Code Pro">   public MessagePriority priority;</font></div><div><font face="Source Code Pro">   public Message(String msg, MessagePriority p)</font></div><div><font face="Source Code Pro">   {</font></div><div><font face="Source Code Pro">       text = msg;</font></div><div><font face="Source Code Pro">       this.priority = p;</font></div><div><font face="Source Code Pro">   }</font></div><div><font face="Source Code Pro">}</font></div><div><font face="Source Code Pro">interface Receiver</font></div><div><font face="Source Code Pro">{</font></div><div><font face="Source Code Pro">   boolean handleMessage(Message message);</font></div><div><font face="Source Code Pro">   void nextErrorHandler(Receiver nextReceiver);</font></div><div><font face="Source Code Pro">}</font></div><div><font face="Source Code Pro">class IssueRaiser</font></div><div><font face="Source Code Pro">{</font></div><div><font face="Source Code Pro">   public Receiver setFirstReceiver;</font></div><div><font face="Source Code Pro">   public void setFirstErrorHandler(Receiver firstErrorHandler)</font></div><div><font face="Source Code Pro">   {</font></div><div><font face="Source Code Pro">       this.setFirstReceiver = firstErrorHandler;</font></div><div><font face="Source Code Pro">   }</font></div><div><font face="Source Code Pro">   public void raiseMessage(Message message)</font></div><div><font face="Source Code Pro">   {</font></div><div><font face="Source Code Pro">       if (setFirstReceiver != null)</font></div><div><font face="Source Code Pro">           setFirstReceiver.handleMessage(message);</font></div><div><font face="Source Code Pro">   }</font></div><div><font face="Source Code Pro">}</font></div><div><font face="Source Code Pro">// FaxErrorHandler class</font></div><div><font face="Source Code Pro">class FaxErrorHandler implements Receiver</font></div><div><font face="Source Code Pro">{</font></div><div><font face="Source Code Pro">   private Receiver nextReceiver;</font></div><div><font face="Source Code Pro">   @Override</font></div><div><font face="Source Code Pro">   public void nextErrorHandler(Receiver nextReceiver)</font></div><div><font face="Source Code Pro">   {</font></div><div><font face="Source Code Pro">       this.nextReceiver = nextReceiver;</font></div><div><font face="Source Code Pro">   }</font></div><div><font face="Source Code Pro">   @Override</font></div><div><font face="Source Code Pro">   public boolean handleMessage(Message message)</font></div><div><font face="Source Code Pro">   {</font></div><div><font face="Source Code Pro">       if (message.text.contains(&quot;Fax&quot;))</font></div><div><font face="Source Code Pro">       {</font></div><div><font face="Source Code Pro">           System.<span style="font-style: italic;">out</span>.println(&quot; FaxErrorHandler processed &quot; +message.priority +&quot; priority issue :&quot;+ message.text);</font></div><div><font face="Source Code Pro">           return true;</font></div><div><font face="Source Code Pro">       }</font></div><div><font face="Source Code Pro">       else</font></div><div><font face="Source Code Pro">       {</font></div><div><font face="Source Code Pro">           if (nextReceiver != null)</font></div><div><font face="Source Code Pro">               nextReceiver.handleMessage(message);</font></div><div><font face="Source Code Pro">       }</font></div><div><font face="Source Code Pro">       return false;</font></div><div><font face="Source Code Pro">   }</font></div><div><font face="Source Code Pro">}</font></div><div><font face="Source Code Pro">// EmailErrorHandler class</font></div><div><font face="Source Code Pro">class EmailErrorHandler implements Receiver</font></div><div><font face="Source Code Pro">{</font></div><div><font face="Source Code Pro">   private Receiver nextReceiver;</font></div><div><font face="Source Code Pro">   @Override</font></div><div><font face="Source Code Pro">   public void nextErrorHandler(Receiver nextReceiver)</font></div><div><font face="Source Code Pro">   {</font></div><div><font face="Source Code Pro">       this.nextReceiver = nextReceiver;</font></div><div><font face="Source Code Pro">   }</font></div><div><font face="Source Code Pro">   @Override</font></div><div><font face="Source Code Pro">   public boolean handleMessage(Message message)</font></div><div><font face="Source Code Pro">   {</font></div><div><font face="Source Code Pro">       if (message.text.contains(&quot;Email&quot;))</font></div><div><font face="Source Code Pro">       {</font></div><div><font face="Source Code Pro">           System.<span style="font-style: italic;">out</span>.println(&quot; EmailErrorHandler processed &quot;+message.priority+ &quot; priority issue: &quot;+message.text);</font></div><div><font face="Source Code Pro">           return true;</font></div><div><font face="Source Code Pro">       }</font></div><div><font face="Source Code Pro">       else</font></div><div><font face="Source Code Pro">       {</font></div><div><font face="Source Code Pro">           if (nextReceiver != null)</font></div><div><font face="Source Code Pro">               nextReceiver.handleMessage(message);</font></div><div><font face="Source Code Pro">       }</font></div><div><font face="Source Code Pro">       return false;</font></div><div><font face="Source Code Pro">   }</font></div><div><font face="Source Code Pro">}</font></div><div><font face="Source Code Pro">//Client code</font></div><div><font face="Source Code Pro">public class ChainofResponsibilityPattern {</font></div><div><font face="Source Code Pro">   public static void main(String[] args) {</font></div><div><font face="Source Code Pro">       System.<span style="font-style: italic;">out</span>.println(&quot;\n ***Chain of Responsibility Pattern Demo***\n&quot;);</font></div><div><font face="Source Code Pro">       /* Forming the chain as IssueRaiser-&gt;FaxErrorhandler-&gt;EmailErrorHandler */</font></div><div><font face="Source Code Pro">       Receiver faxHandler, emailHandler;</font></div><div><font face="Source Code Pro">       //Objects of the chains</font></div><div><font face="Source Code Pro">       IssueRaiser issueRaiser = new IssueRaiser();</font></div><div><font face="Source Code Pro">       faxHandler = new FaxErrorHandler();</font></div><div><font face="Source Code Pro">       emailHandler = new EmailErrorHandler();</font></div><div><font face="Source Code Pro">       //Making the chain</font></div><div><font face="Source Code Pro">       //Starting point:IssueRaiser will raise issues and set the first</font></div><div><font face="Source Code Pro">       //handler</font></div><div><font face="Source Code Pro">       issueRaiser.setFirstErrorHandler(faxHandler);</font></div><div><font face="Source Code Pro">       //FaxErrorHandler will pass the error to EmailHandler if needed.</font></div><div><font face="Source Code Pro">       faxHandler.nextErrorHandler(emailHandler);</font></div><div><font face="Source Code Pro">       //EmailErrorHandler will be placed at the last position in the chain</font></div><div><font face="Source Code Pro">       emailHandler.nextErrorHandler(null);</font></div><div><font face="Source Code Pro">       Message m1 = new Message(&quot;Fax is going slow.&quot;, MessagePriority.<span style="font-style: italic;">NORMAL</span>);</font></div><div><font face="Source Code Pro">       Message m2 = new Message(&quot;Emails are not reaching.&quot;, MessagePriority.<span style="font-style: italic;">HIGH</span>);</font></div><div><font face="Source Code Pro">       Message m3 = new Message(&quot;In Email, CC field is disabled always.&quot;, MessagePriority.<span style="font-style: italic;">NORMAL</span>);</font></div><div><font face="Source Code Pro">       Message m4 = new Message(&quot;Fax is not reaching destinations.&quot;, MessagePriority.<span style="font-style: italic;">HIGH</span>);</font></div><div><font face="Source Code Pro">       issueRaiser.raiseMessage(m1);</font></div><div><font face="Source Code Pro">       issueRaiser.raiseMessage(m2);</font></div><div><font face="Source Code Pro">       issueRaiser.raiseMessage(m3);</font></div><div><font face="Source Code Pro">       issueRaiser.raiseMessage(m4);</font></div><div><font face="Source Code Pro">   }</font></div><div><font face="Source Code Pro">}</font></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 846px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div>D:   <span style="font-weight: bold;">In the example, what is the purpose of message priorities?</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div><b>R: </b>Good catch. Actually, you could ignore them because, for simplicity in the handlers, you are just searching for the words <span style="font-style: italic;">email</span> or <span style="font-style: italic;">fax</span>. These priorities are added to beautify the code. But instead of using separate handlers for email and fax, you could make a different kind of chain that handles the messages based on the priorities. In such a case, these priorities can be used more effectively.</div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 846px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div>D:   <span style="font-weight: bold;">What are the advantages of using a chain-of-responsibility design pattern?</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div><b>R:</b></div><ul><li><div>You can have more than one object to handle a request. (Notice that if a handler cannot handle the whole request, it may forward the responsibility to the next handler in the chain).</div></li><li><div>The nodes of the chain can be added or removed dynamically. Also, you can shuffle the order. For example, if you notice that the majority of issues are with email processing, then you may place EmailErrorHandler as the first handler in the chain to save the average processing time of the application.</div></li><li><div>A handler does not need to know how the next handler in the chain will handle the request. It focuses only on its own handling mechanism.</div></li><li><div>In this pattern, you are promoting loose coupling because it decouples the senders (of requests) from the receivers.</div></li></ul></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 846px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div>D:   <span style="font-weight: bold;">What are the challenges associated with using the chain-of-responsibility design pattern?</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div><b>R:</b></div><ul><li><div>There is no guarantee that the request will be handled (fully or partially) because you may reach the end of the chain; but it is possible that you have not found any explicit receiver to handle the request.</div></li><li><div>Debugging may become tricky with this kind of design.</div></li></ul></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 846px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div>D:   <span style="font-weight: bold;">How can you handle the scenario where you have reached at the end of chain, but the request is not handled at all?</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div><b>R. </b>One simple solution is to use try/catch (or try/finally or try/catch/finally) blocks. You may put the handlers in these constructs. You may notice that a try block can be associated with multiple catch blocks also.</div><div>In the end, if no one can handle the request, you may raise an exception with the appropriate messages and catch the exception in your intended catch block to draw your attention (or handle it in some different way).</div><div>The GoF talked about Smalltalk’s automatic forwarding mechanism, doesNotUnderstand, in a similar context. If a message cannot find a proper handler, it is caught in doesNotUnderstand implementations that can be overridden to forward the message in the object’s successor, log it in a file, and store it in a queue for later processing, or you can simply perform any other intended operations. But you must make a note that by default, this method raises an exception that needs to be handled in a proper way.</div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 846px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div>D:   <span style="font-weight: bold;">In short, if a handler cannot handle the request fully, it will pass it to the next handler. Is this correct?</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div><b>R: </b>Yes.</div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 846px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div>D:   <span style="font-weight: bold;">It appears that there are similarities between the observer pattern and the chain-of-responsibility pattern. Is this correct?</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div><b>R: </b>In an observer pattern, all registered users get notifications in parallel; but in a chain-of-responsibility pattern, objects in the chain are notified, one by one, in a sequential manner. This process continues until an object handles the notification fully (or you reach the end of the chain). I show the comparisons in diagrams in the “Q&amp;A Session” in Chapter <a href="https://learning.oreilly.com/library/view/java-design-patterns/9781484240786/html/395506_2_En_14_Chapter.xhtml">14</a>.</div></td></tr></tbody></table><div><br/></div></div></div><div><br/></div></span>
</div></body></html> 