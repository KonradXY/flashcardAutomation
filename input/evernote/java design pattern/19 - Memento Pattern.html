<html>
<head>
  <title>Evernote Export</title>
  <basefont face="Segoe UI" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/308716 (en-US, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: Segoe UI;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="497"/>

<div>
<span><div><h2><span style="font-weight: bold;">19 - Memento Pattern</span></h2><div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 846px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div>D:   Can you give the gof definition of the memento pattern ?</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div>R: Without violating encapsulation, capture and externalize an object’s internal state so that the object can be restored to this state later.</div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 846px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div>D:   Can you show an example with a uml diagram of the memento pattern ?</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div>R: In your application, you may need to support “undo” operations. To achieve this, you need to record the internal state of an object. So, you must save this state information in a place that can be referred again to revert back the old state of the object. But in general, objects encapsulate their states, and those states are inaccessible to the outer world. So, if you expose the state information, then you violate encapsulation.</div><div>The dictionary meaning of <span style="font-style: italic;">memento</span> is reminder (of past events). So, you can guess that using this pattern, you can restore an object to its previous state, but it ensures that you achieve your goal without violating the encapsulation.</div><div><br/></div><div>Go through the code and follow the comments for your ready reference. In this example, three objects are involved: a memento, an originator, and a caretaker. (These names are very common, so I have kept the same naming convention in our implementation.)</div><div>The <span style="font-style: italic;">originator</span> object has an internal state. A client can set a state in it. A <span style="font-style: italic;">memento</span> object may store as much or as little of the originator’s state, at the originator’s discretion. When a <span style="font-style: italic;">caretaker</span> wants to record the state of the originator, it requests the current state from it. So, it first asks the originator for a memento object.</div><div>In the following example, the caretaker object confirms the save operation by displaying a console message. Suppose that the client makes some changes and then wants to revert back to the previous state. Since the originator object’s state is already changed, to roll back to the previous state requires help from the caretaker object, which saved the state earlier. The caretaker object returns the memento object (with the previous state) to the originator. The memento object itself is an opaque object (one which the caretaker is not allowed to make any change to, and ideally, only the originator, who created the memento can access the memento’s internal state).</div><div>So, you can conclude that caretaker has a narrow view/interface to the memento because it can only pass it to other objects. In contrast, the originator sees the wide interface because it can access the data necessary to return to a previous state.</div><div><br/></div><div><img src="19 - Memento Pattern_files/Image.jpg" type="image/jpeg" data-filename="Image.jpg" width="377"/></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 846px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div>D:   ca you show an implementation of the memento pattern ?</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div>R: Here is the implementation.</div><div><font face="Source Code Pro"><br/></font></div><div><font face="Source Code Pro">package jdp2e.memento.demo;</font></div><div><font face="Source Code Pro">class Memento</font></div><div><font face="Source Code Pro">{</font></div><div><font face="Source Code Pro">   private int stateId;</font></div><div><font face="Source Code Pro">   public Memento(int stateId)</font></div><div><font face="Source Code Pro">   {</font></div><div><font face="Source Code Pro">       this.stateId = stateId;</font></div><div><font face="Source Code Pro">   }</font></div><div><font face="Source Code Pro">   public int getStateId() {</font></div><div><font face="Source Code Pro">       return stateId;</font></div><div><font face="Source Code Pro">   }</font></div><div><font face="Source Code Pro">   /*This class does not have the</font></div><div><font face="Source Code Pro">   setter method.We need to use this class</font></div><div><font face="Source Code Pro">   to get the state of the object only.*/</font></div><div><font face="Source Code Pro">   /*public void setState(String state) {</font></div><div><font face="Source Code Pro">       this.state = state;</font></div><div><font face="Source Code Pro">   }*/</font></div><div><font face="Source Code Pro">}</font></div><div><font face="Source Code Pro">/*</font></div><div><font face="Source Code Pro">The 'Originator' class</font></div><div><font face="Source Code Pro">WikiPedia notes( for your reference):</font></div><div><font face="Source Code Pro">Make an object (originator) itself responsible for:</font></div><div><font face="Source Code Pro">1.Saving its internal state to a(memento) object and</font></div><div><font face="Source Code Pro">2.Restoring to a previous state from a(memento) object.</font></div><div><font face="Source Code Pro">3.Only the originator that created a memento is allowed to access it .</font></div><div><font face="Source Code Pro">*/</font></div><div><font face="Source Code Pro">class Originator</font></div><div><font face="Source Code Pro">{</font></div><div><font face="Source Code Pro">   private int stateId;</font></div><div><font face="Source Code Pro">   public Originator()</font></div><div><font face="Source Code Pro">   {</font></div><div><font face="Source Code Pro">       this.stateId = 0;</font></div><div><font face="Source Code Pro">       System.<span style="font-style: italic;">out</span>.println(&quot; Originator is created with state id : &quot;+ stateId);</font></div><div><font face="Source Code Pro">   }</font></div><div><font face="Source Code Pro">   public int getStateId()</font></div><div><font face="Source Code Pro">   {</font></div><div><font face="Source Code Pro">       return stateId;</font></div><div><font face="Source Code Pro">   }</font></div><div><font face="Source Code Pro">   public void setStateId(int stateId)</font></div><div><font face="Source Code Pro">   {</font></div><div><font face="Source Code Pro">       System.<span style="font-style: italic;">out</span>.println(&quot; Setting the state id of the originator to : &quot;+ stateId);</font></div><div><font face="Source Code Pro">       this.stateId= stateId;</font></div><div><font face="Source Code Pro">   }</font></div><div><font face="Source Code Pro">   //Saving its internal state to a(memento) object</font></div><div><font face="Source Code Pro">   public Memento saveMemento(int stateId)</font></div><div><font face="Source Code Pro">   {</font></div><div><font face="Source Code Pro">       System.<span style="font-style: italic;">out</span>.println(&quot; Saving originator's current state id. &quot;);</font></div><div><font face="Source Code Pro">       //Create memento with the current state and return it.</font></div><div><font face="Source Code Pro">       return new Memento(stateId);</font></div><div><font face="Source Code Pro">   }</font></div><div><font face="Source Code Pro">   //Restoring to a previous state from a(memento) object .</font></div><div><font face="Source Code Pro">   public void revertMemento(Memento previousMemento)</font></div><div><font face="Source Code Pro">   {</font></div><div><font face="Source Code Pro">       System.<span style="font-style: italic;">out</span>.println(&quot; Restoring to state id...&quot;+ previousMemento.getStateId());</font></div><div><font face="Source Code Pro">       this.stateId = previousMemento.getStateId();</font></div><div><font face="Source Code Pro">       System.<span style="font-style: italic;">out</span>.println(&quot; Current state id of originator : &quot;+ stateId);</font></div><div><font face="Source Code Pro">   }</font></div><div><font face="Source Code Pro">}</font></div><div><font face="Source Code Pro">/*</font></div><div><font face="Source Code Pro">The 'Caretaker' class.</font></div><div><font face="Source Code Pro">WikiPedia notes( for your reference):</font></div><div><font face="Source Code Pro">1.A client (caretaker) can request a memento from the originator  to save the internal state of the originator and</font></div><div><font face="Source Code Pro">2.Pass a memento back to the originator (to restore to a previous state)</font></div><div><font face="Source Code Pro">This enables to save and restore the internal state of an originator without violating its encapsulation.</font></div><div><font face="Source Code Pro">*/</font></div><div><font face="Source Code Pro">public class MementoPatternExample {</font></div><div><font face="Source Code Pro">   public static void main(String[] args) {</font></div><div><font face="Source Code Pro">       System.<span style="font-style: italic;">out</span>.println(&quot;***Memento Pattern Demo***\n&quot;);</font></div><div><font face="Source Code Pro">       //Originator is initialized with a state</font></div><div><font face="Source Code Pro">       Originator originatorObject = new Originator();</font></div><div><font face="Source Code Pro">       Memento mementoObject;</font></div><div><font face="Source Code Pro">       originatorObject.setStateId(1);</font></div><div><font face="Source Code Pro">       // A client (caretaker) can request a memento from the originator</font></div><div><font face="Source Code Pro">       //to save the internal state of the originator</font></div><div><font face="Source Code Pro">       mementoObject=originatorObject.saveMemento(originatorObject.getStateId());</font></div><div><font face="Source Code Pro">       System.<span style="font-style: italic;">out</span>.println(&quot; Snapshot #1: Originator's current state id is saved in caretaker.&quot;);</font></div><div><font face="Source Code Pro">       //A client (or caretaker) cannot set/modify the memento's state</font></div><div><font face="Source Code Pro">       //mementoObject.setState(&quot;arbitratyState&quot;);//error</font></div><div><font face="Source Code Pro">       //Changing the state id of Originator</font></div><div><font face="Source Code Pro">       originatorObject.setStateId(2);</font></div><div><font face="Source Code Pro">       mementoObject=originatorObject.saveMemento(originatorObject.getStateId());</font></div><div><font face="Source Code Pro">       System.<span style="font-style: italic;">out</span>.println(&quot; Snapshot #2: Originator's current state id is saved in caretaker.&quot;);</font></div><div><font face="Source Code Pro">       //Changing the state id of Originator again .</font></div><div><font face="Source Code Pro">       originatorObject.setStateId(3);</font></div><div><font face="Source Code Pro">       //Reverting back to previous state id.</font></div><div><font face="Source Code Pro">       originatorObject.revertMemento(mementoObject);</font></div><div><font face="Source Code Pro">   }</font></div><div><font face="Source Code Pro">}</font></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 846px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div>D:   <span style="font-weight: bold;">I can restore the previous snapshot/restore point. But in a real-life scenario, I may have multiple restore points. How can you implement that using this design pattern?</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div><b>R:  </b>You can use an ArrayList in such a case. Consider the following program.</div><div>The Originator class and Memento class are same as before, so I am presenting the modified Caretaker class only. I am using the following line of code in the upcoming implementation.</div><div>List&lt;Memento&gt; savedStateIds = new ArrayList&lt;Memento&gt;();</div><div>In this modified program, you can see three different variations of “undo” operations.</div><ul><li><div>You can just go back to the previous restore point.</div></li><li><div>You can go back to your specified restore point.</div></li><li><div>You can revert back to all restore points.</div></li></ul></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 846px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div>D:   <span style="font-weight: bold;">In many applications, I notice that the memento class is presented as an inner class of Originator. Why are you not following that approach?</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div><b>R: </b>The memento design pattern can be implemented in many different ways (for example, using package-private visibility or using object serialization techniques). But in each case, if you analyze the key aim, you find that once the memento instance is created by an originator, no one else besides its creator is allowed to access the internal state (this includes the caretaker/client). A caretaker’s job is to store the memento instance (restore points in our example) and supply them back when you are in need. So, there is no harm if your memento class is public. You can just block the public setter method for the memento. I believe that it is sufficient enough.</div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 846px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div>D:   <span style="font-weight: bold;">But you are still using the getter method getStateId(). Does it not violate the encapsulation?</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div><b>R: </b>There is a lot of discussion and debate around this area—whether you should use getter/setter or not, particularly when you consider encapsulation. I believe that it depends on the amount of strictness that you want to impose. For example, if you just provide getter/setters for all fields without any reason, that is surely a bad design. The same thing applies when you use all the public fields inside the objects. But sometimes the accessor methods are required and useful. In this book, my aim is to encourage you learn design patterns with simple examples. If I need to consider each and every minute detail such as this, you may lose interest. So, in these examples, I show a simple way to promote encapsulation using the memento pattern. But, if you want to be stricter, you may prefer to implement the memento class as an inner class of the originator and modify the initial implementation</div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 846px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div>D:   <span style="font-weight: bold;">What are key</span> <span style="font-weight: bold;">challenges</span> <span style="font-weight: bold;">associated with a memento design pattern?</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div>R:</div><ul><li><div>A high number of mementos require more storage. At the same time, they put additional burdens on a caretaker.</div></li><li><div>The preceding point increases maintenance costs in parallel.</div></li><li><div>You cannot ignore the time to save these states. The additional time to save the states decreases the overall performance of the system.</div></li></ul><div><span style="font-weight: bold;">Note</span> In a language like C# or Java, developers may prefer the serialization/deserialization techniques instead of directly implementing a memento design pattern. Both techniques have their own pros/cons. But you can also combine both techniques in your application.</div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 846px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div>D:   <span style="font-weight: bold;">In these implementations, if you make the originator’s state public, then our clients also could directly access the states. Is this correct?</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div><b>R: </b>Yes. But you should not try to break the encapsulation. Notice the GoF definition that begins “without violating <span style="font-style: italic;">encapsulation</span>…”</div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 846px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div>D:   <span style="font-weight: bold;">In these implementations, the memento class does not have a public setter method. What is the reason behind this?</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div><b>R: </b>Go through the answer of question 2 again. And read the comment in the code that says, “Only the originator that created a memento is allowed to access it.” So, if you do not provide a public setter method for your memento class, the caretaker or client cannot modify the memento instances that are created by an originator.</div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 846px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div>D:   <span style="font-weight: bold;">In these implementations, you could ignore the getter method of the memento by using package-private visibility for stateId. For example, you could code memento class like the following.</span> <span style="font-weight: bold;">Is this correct?</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div>R: Yes. In many application, other classes (except originator) cannot even read the memento’s state. When you use package-private visibility, you do not need any accessor method. In other words, you are simply using the default modifier in this case.</div><div>So, this kind of visibility is slightly more open than private visibility and other classes in the same package can access a class member. So, in this case, the intended classes need to be placed inside the same package. At the same time, you need to accept that all other classes inside the same package will have the direct access to this state. So, you need to be careful enough when you place the classes in your special package.</div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 846px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div>D:   <span style="font-weight: bold;">I am confused. To support undo operations, which pattern should I prefer—memento or command?</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div><b>R:  </b>The GoF told us that these are related patterns. It primarily depends on how you want to handle the situation. For example, suppose that you are adding 10 to an integer. After this addition, you want to undo the operation by doing the reverse operation (i.e., 50 + 10 = 60, so to go back, you do 60 –10 = 50). In this type of operation, we do not need to store the previous state.</div><div>But consider a situation where you need to store the state of your objects prior to the operations. In this case, memento is your savior. So, in a paint application, you can avoid the cost of undoing a paint operation. You can store the list of objects prior to executing the commands. This stored list can be treated as a memento in this case. You can keep this list with the associated commands</div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 846px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div>D:   What are the differences between shallow copy and deep copy and how it is related to the memento pattern ?</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div>R: You clone with the clone() method in Java, but at the same time, you need to implement the Cloneable interface (which is a marker interface) because the Java objects that implement this Cloneable interface are only eligible for cloning. The default version of clone()creates a shallow copy. To create the deep copy, you need to override the clone() method .</div><h4><span style="font-style: italic; font-weight: bold;">Key Characteristics of the Following Program</span></h4><div>In the following example, you have two classes: Employee and EmpAddress.</div><div>The Employee class has three fields: id, name, and EmpAddress. So, you may notice that to form an Employee object, you need to pass an EmpAddress object also. So, in the following example, you will notice the line of code:</div><div>Employee emp=new Employee(1,&quot;John&quot;,initialAddress);</div><div>EmpAddress has only a field called address, which is a String datatype.</div><div>In the client code, you create an Employee object emp and then you create another object, empClone, through cloning. So, you will notice the line of code as follows:</div><div>Employee empClone=(Employee)emp.clone();</div><div>Then you change the field values of the emp object. But as a side effect of this change, the address of empClone object also changes, but this is not wanted.</div><h4><span style="font-style: italic; font-weight: bold;">Implementation</span></h4><div><font face="Source Code Pro">package jdp2e.memento.questions_answers;</font></div><div><font face="Source Code Pro">class EmpAddress implements Cloneable</font></div><div><font face="Source Code Pro">{</font></div><div><font face="Source Code Pro">   String address;</font></div><div><font face="Source Code Pro">   public EmpAddress(String address)</font></div><div><font face="Source Code Pro">   {</font></div><div><font face="Source Code Pro">       this.address=address;</font></div><div><font face="Source Code Pro">   }</font></div><div><font face="Source Code Pro">   public String getAddress()</font></div><div><font face="Source Code Pro">   {</font></div><div><font face="Source Code Pro">       return address;</font></div><div><font face="Source Code Pro">   }</font></div><div><font face="Source Code Pro">   public void setAddress(String address)</font></div><div><font face="Source Code Pro">   {</font></div><div><font face="Source Code Pro">       this.address = address;</font></div><div><font face="Source Code Pro">   }</font></div><div><font face="Source Code Pro">   @Override</font></div><div><font face="Source Code Pro">   public String toString()</font></div><div><font face="Source Code Pro">   {</font></div><div><font face="Source Code Pro">       return  this.address ;</font></div><div><font face="Source Code Pro">   }</font></div><div><font face="Source Code Pro">   @Override</font></div><div><font face="Source Code Pro">   public Object clone() throws CloneNotSupportedException</font></div><div><font face="Source Code Pro">   {</font></div><div><font face="Source Code Pro">       //Shallow Copy</font></div><div><font face="Source Code Pro">       return super.clone();</font></div><div><font face="Source Code Pro">   }</font></div><div><font face="Source Code Pro">}</font></div><div><font face="Source Code Pro">class Employee implements Cloneable</font></div><div><font face="Source Code Pro">{</font></div><div><font face="Source Code Pro">   int id;</font></div><div><font face="Source Code Pro">   String name;</font></div><div><font face="Source Code Pro">   EmpAddress empAddress;</font></div><div><font face="Source Code Pro">   public Employee(int id,String name,EmpAddress empAddress)</font></div><div><font face="Source Code Pro">   {</font></div><div><font face="Source Code Pro">       this.id=id;</font></div><div><font face="Source Code Pro">       this.name=name;</font></div><div><font face="Source Code Pro">       this.empAddress=empAddress;</font></div><div><font face="Source Code Pro">   }</font></div><div><font face="Source Code Pro">   public int getId()</font></div><div><font face="Source Code Pro">   {</font></div><div><font face="Source Code Pro">       return id;</font></div><div><font face="Source Code Pro">   }</font></div><div><font face="Source Code Pro">   public void setId(int id)</font></div><div><font face="Source Code Pro">   {</font></div><div><font face="Source Code Pro">       this.id = id;</font></div><div><font face="Source Code Pro">   }</font></div><div><font face="Source Code Pro">   public String getName()</font></div><div><font face="Source Code Pro">   {</font></div><div><font face="Source Code Pro">       return name;</font></div><div><font face="Source Code Pro">   }</font></div><div><font face="Source Code Pro">   public void setName(String name)</font></div><div><font face="Source Code Pro">   {</font></div><div><font face="Source Code Pro">       this.name = name;</font></div><div><font face="Source Code Pro">   }</font></div><div><font face="Source Code Pro">   public EmpAddress getAddress()</font></div><div><font face="Source Code Pro">   {</font></div><div><font face="Source Code Pro">       return this.empAddress;</font></div><div><font face="Source Code Pro">   }</font></div><div><font face="Source Code Pro">   public void setAddress(EmpAddress newAddress)</font></div><div><font face="Source Code Pro">   {</font></div><div><font face="Source Code Pro">       this.empAddress=newAddress;</font></div><div><font face="Source Code Pro">   }</font></div><div><font face="Source Code Pro">   @Override</font></div><div><font face="Source Code Pro">   public String toString()</font></div><div><font face="Source Code Pro">   {</font></div><div><font face="Source Code Pro">       return &quot;EmpId=&quot; +this.id+ &quot; EmpName=&quot;+ this.name+ &quot; EmpAddressName=&quot;+ this.empAddress;</font></div><div><font face="Source Code Pro">   }</font></div><div><font face="Source Code Pro">   @Override</font></div><div><font face="Source Code Pro">   public Object clone() throws CloneNotSupportedException</font></div><div><font face="Source Code Pro">   {</font></div><div><font face="Source Code Pro">       //Shallow Copy</font></div><div><font face="Source Code Pro">       return super.clone();</font></div><div><font face="Source Code Pro">   }</font></div><div><font face="Source Code Pro">}</font></div><div><font face="Source Code Pro">public class ShallowVsDeepCopy {</font></div><div><font face="Source Code Pro">   public static void main(String[] args) throws CloneNotSupportedException  {</font></div><div><font face="Source Code Pro">       System.<span style="font-style: italic;">out</span>.println(&quot;***Shallow vs Deep Copy Demo***\n&quot;);</font></div><div><font face="Source Code Pro">       EmpAddress initialAddress=new EmpAddress(&quot;21, abc Road, USA&quot;);</font></div><div><font face="Source Code Pro">       Employee emp=new Employee(1,&quot;John&quot;,initialAddress);</font></div><div><font face="Source Code Pro">       System.<span style="font-style: italic;">out</span>.println(&quot;emp1 object is as follows:&quot;);</font></div><div><font face="Source Code Pro">       System.<span style="font-style: italic;">out</span>.println(emp);</font></div><div><font face="Source Code Pro">       Employee empClone=(Employee)emp.clone();</font></div><div><font face="Source Code Pro">       System.<span style="font-style: italic;">out</span>.println(&quot;empClone object is as follows:&quot;);</font></div><div><font face="Source Code Pro">       System.<span style="font-style: italic;">out</span>.println(empClone);</font></div><div><font face="Source Code Pro">       System.<span style="font-style: italic;">out</span>.println(&quot;\n Now changing the name, id and address of the emp object &quot;);</font></div><div><font face="Source Code Pro">       emp.setId(10);</font></div><div><font face="Source Code Pro">       emp.setName(&quot;Sam&quot;);</font></div><div><font face="Source Code Pro">       emp.empAddress.setAddress(&quot;221, xyz Road, Canada&quot;);</font></div><div><font face="Source Code Pro">       System.<span style="font-style: italic;">out</span>.println(&quot;Now emp1 object is as follows:&quot;);</font></div><div><font face="Source Code Pro">       System.<span style="font-style: italic;">out</span>.println(emp);</font></div><div><font face="Source Code Pro">       System.<span style="font-style: italic;">out</span>.println(&quot;And emp1Clone object is as follows:&quot;);</font></div><div><font face="Source Code Pro">       System.<span style="font-style: italic;">out</span>.println(empClone);</font></div><div><font face="Source Code Pro">   }</font></div><div><font face="Source Code Pro">}</font></div><div><font face="Source Code Pro"><br/></font></div><h4><span style="font-style: italic; font-weight: bold;">Output</span></h4><div>Here is the output.</div><div>***Shallow vs Deep Copy Demo***</div><div>emp1 object is as follows:</div><div>EmpId=1 EmpName=John EmpAddressName=21, abc Road, USA</div><div>empClone object is as follows:</div><div>EmpId=1 EmpName=John EmpAddressName=21, abc Road, USA</div><div>Now changing the name and id of emp object</div><div>Now emp1 object is as follows:</div><div>EmpId=10 EmpName=Sam EmpAddressName=221, xyz Road, Canada</div><div>And emp1Clone object is as follows:</div><div>EmpId=1 EmpName=John <span style="font-weight: bold;">EmpAddressName=221, xyz Road, Canada</span></div><h4><span style="font-style: italic; font-weight: bold;">Analysis</span></h4><div>Notice the last line of the output. You see an unwanted side effect. The address of the cloned object is modified due the modification to the emp object. This is because the original object and the cloned object both point to the same address, and they are not 100% disjoined. Figure <a href="https://learning.oreilly.com/library/view/java-design-patterns/9781484240786/html/395506_2_En_19_Chapter.xhtml#Fig3">19-3</a> depicts the scenario.</div><div style="text-align: center;"><img src="19 - Memento Pattern_files/Image [1].jpg" type="image/jpeg" data-filename="Image.jpg" style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; -webkit-font-smoothing: antialiased; border: 0px; height: 19.75em; max-width: 100%; vertical-align: middle; margin: 0px; padding: 2px;" width="329"/></div><div><br/></div><div>So, now let’s experiment with a deep copy implementation. Let’s modify the clone method of the Employee class as follows.</div><div><font face="Source Code Pro"><br/></font></div><div><font face="Source Code Pro">@Override</font></div><div><font face="Source Code Pro">   public Object clone() throws CloneNotSupportedException</font></div><div><font face="Source Code Pro">   {</font></div><div><font face="Source Code Pro">       //Shallow Copy</font></div><div><font face="Source Code Pro">       //return super.clone();</font></div><div><font face="Source Code Pro">       //For deep copy</font></div><div><font face="Source Code Pro">       <span style="font-weight: bold;">Employee employee = (Employee)  super.clone();</span></font></div><div><font face="Source Code Pro">       <span style="font-weight: bold;">employee.empAddress = (EmpAddress) empAddress.clone();</span></font></div><div><font face="Source Code Pro">       <span style="font-weight: bold;">return employee;</span></font></div><div><font face="Source Code Pro">   }</font></div><h4><span style="font-style: italic; font-weight: bold;">Modified Output</span></h4><div>Here is the modified output.</div><div>***Shallow vs Deep Copy Demo***</div><div>emp1 object is as follows:</div><div>EmpId=1 EmpName=John EmpAddressName=21, abc Road, USA</div><div>empClone object is as follows:</div><div>EmpId=1 EmpName=John EmpAddressName=21, abc Road, USA</div><div>Now changing the name, id and address of the emp object</div><div>Now emp1 object is as follows:</div><div><span style="font-weight: bold;">EmpId=10 EmpName=Sam EmpAddressName=221, xyz Road, Canada</span></div><div>And emp1Clone object is as follows:</div><div><span style="font-weight: bold;">EmpId=1 EmpName=John EmpAddressName=21, abc Road, USA</span></div><h4><span style="font-style: italic; font-weight: bold;">Analysis</span></h4><div>Notice the last line of the output. Now you do not see the unwanted side effect due to the modification to the emp object. This is because the original object and the cloned object are totally different and independent of each other. Figure <a href="https://learning.oreilly.com/library/view/java-design-patterns/9781484240786/html/395506_2_En_19_Chapter.xhtml#Fig4">19-4</a> depicts the scenario.</div><div style="text-align: center;"><img src="19 - Memento Pattern_files/Image [2].jpg" type="image/jpeg" data-filename="Image.jpg" style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; -webkit-font-smoothing: antialiased; border: 0px; height: 22.28em; max-width: 100%; vertical-align: middle; margin: 0px; padding: 2px;" width="330"/></div></td></tr></tbody></table></div></div><div><br/></div></span>
</div></body></html> 