<html>
<head>
  <title>Evernote Export</title>
  <basefont face="Segoe UI" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/308716 (en-US, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: Segoe UI;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="432"/>

<div><span><div><b><span style="font-size: 14pt;">7 - Decorator Pattern</span></b></div><div><br/></div><table style="width:1134px;" width="1134px"><colgroup><col style="width: 1134px;"></col></colgroup><tbody><tr><td><div>D:   </div><div>Could you give the gof definition of the decorator pattern ?</div><div>What's the purpose of the decorator pattern ?</div></td></tr><tr><td><div>R:    </div><div>Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.</div><div>This pattern says that the class must be closed for modification but open for extension; that is, a new functionality can be added without disturbing existing functionalities. The concept is very useful when we want to add special functionalities to a specific object instead of the whole class. In this pattern, we try to use the concept of object composition instead of inheritance. So, when we master this technique, we can add new responsibilities to an object without affecting the underlying classes.</div></td></tr></tbody></table><div><br/></div><table style="width:1134px;" width="1134px"><colgroup><col style="width: 1134px;"></col></colgroup><tbody><tr><td style="border-color:rgb(204, 204, 204);"><div>D:   </div><div>can you give an example of the decorator pattern ?</div><div>Can you give the uml diagram of the decorator pattern ?</div></td></tr><tr><td style="border-color:rgb(204, 204, 204);"><div>R:    Suppose that in a GUI-based toolkit, we want to add some border properties. We can do this with inheritance. But it cannot be treated as an ultimate solution because the user cannot have absolute control over this creation from the beginning. So, the core choice is static in this case.</div><div>Decorators comes into picture with a flexible approach. They promote the concept of dynamic choices, for example, we can surround the component in another object. The enclosing object is called a <i>decorator</i>. It must conform to the interface of the component that it decorates. It forwards the requests to the component. It can perform additional operations before or after the forwardings. An unlimited number of responsibilities can be added with this concept.</div><div><br/></div><img src="7 - Decorator Pattern_files/Image.jpg" type="image/jpeg" data-filename="Image.jpg" style="--en-viewerProps:{};" width="509px"/><div><br/></div></td></tr></tbody></table><div><br/></div><table style="width:1134px;" width="1134px"><colgroup><col style="width: 1134px;"></col></colgroup><tbody><tr><td style="border-color:rgb(204, 204, 204);"><div>D:    Can you give an example of implementation of the decorator pattern ?</div></td></tr><tr><td style="border-color:rgb(204, 204, 204);"><div>R:    Here’s the implementation.</div><div><br/></div><div><span style="font-family: Source Code Pro;">package jdp2e.decorator.demo;</span></div><div><span style="font-family: Source Code Pro;">abstract class Component</span></div><div><span style="font-family: Source Code Pro;">{</span></div><div><span style="font-family: Source Code Pro;">   public abstract void makeHouse();</span></div><div><span style="font-family: Source Code Pro;">}</span></div><div><br/></div><div><span style="font-family: Source Code Pro;">class ConcreteComponent extends Component</span></div><div><span style="font-family: Source Code Pro;">{</span></div><div><span style="font-family: Source Code Pro;">   public void makeHouse()</span></div><div><span style="font-family: Source Code Pro;">   {</span></div><div><span style="font-family: Source Code Pro;">       System.<i>out</i>.println(&quot;Original House is complete. It is closed for modification.&quot;);</span></div><div><span style="font-family: Source Code Pro;">   }</span></div><div><span style="font-family: Source Code Pro;">}</span></div><div><br/></div><div><span style="font-family: Source Code Pro;">abstract class AbstractDecorator extends Component</span></div><div><span style="font-family: Source Code Pro;">{</span></div><div><span style="font-family: Source Code Pro;">   protected Component component ;</span></div><div><span style="font-family: Source Code Pro;">   public void setTheComponent(Component c)</span></div><div><span style="font-family: Source Code Pro;">   {</span></div><div><span style="font-family: Source Code Pro;">       component = c;</span></div><div><span style="font-family: Source Code Pro;">   }</span></div><div><span style="font-family: Source Code Pro;">   public void makeHouse()</span></div><div><span style="font-family: Source Code Pro;">   {</span></div><div><span style="font-family: Source Code Pro;">       if (component != null)</span></div><div><span style="font-family: Source Code Pro;">       {</span></div><div><span style="font-family: Source Code Pro;">           component.makeHouse();//Delegating the task</span></div><div><span style="font-family: Source Code Pro;">       }</span></div><div><span style="font-family: Source Code Pro;">   }</span></div><div><span style="font-family: Source Code Pro;">}</span></div><div><br/></div><div><span style="font-family: Source Code Pro;">//A floor decorator</span></div><div><span style="font-family: Source Code Pro;">class FloorDecorator extends AbstractDecorator</span></div><div><span style="font-family: Source Code Pro;">{</span></div><div><span style="font-family: Source Code Pro;">   public  void makeHouse()</span></div><div><span style="font-family: Source Code Pro;">   {</span></div><div><span style="font-family: Source Code Pro;">       super.makeHouse();</span></div><div><span style="font-family: Source Code Pro;">       //Decorating now.</span></div><div><span style="font-family: Source Code Pro;">       System.<i>out</i>.println(&quot;***Floor decorator is in action***&quot;);</span></div><div><span style="font-family: Source Code Pro;">       addFloor();</span></div><div><span style="font-family: Source Code Pro;">       /*You can put additional stuffs as per your need*/</span></div><div><span style="font-family: Source Code Pro;">   }</span></div><div><span style="font-family: Source Code Pro;">   private void addFloor()</span></div><div><span style="font-family: Source Code Pro;">   {</span></div><div><span style="font-family: Source Code Pro;">       System.<i>out</i>.println(&quot;I am making an additional floor on top of it.&quot;);</span></div><div><span style="font-family: Source Code Pro;">   }</span></div><div><span style="font-family: Source Code Pro;">}</span></div><div><span style="font-family: Source Code Pro;">//A paint decorator</span></div><div><span style="font-family: Source Code Pro;">class PaintDecorator extends AbstractDecorator</span></div><div><span style="font-family: Source Code Pro;">{</span></div><div><span style="font-family: Source Code Pro;">   public void makeHouse()</span></div><div><span style="font-family: Source Code Pro;">   {</span></div><div><span style="font-family: Source Code Pro;">       super.makeHouse();</span></div><div><span style="font-family: Source Code Pro;">       //Decorating now.</span></div><div><span style="font-family: Source Code Pro;">       System.<i>out</i>.println(&quot;***Paint decorator is in action now***&quot;);</span></div><div><span style="font-family: Source Code Pro;">       paintTheHouse();</span></div><div><span style="font-family: Source Code Pro;">       //You can add additional stuffs as per your need</span></div><div><span style="font-family: Source Code Pro;">   }</span></div><div><span style="font-family: Source Code Pro;">   private void paintTheHouse()</span></div><div><span style="font-family: Source Code Pro;">   {</span></div><div><span style="font-family: Source Code Pro;">       System.<i>out</i>.println(&quot;Now I am painting the house.&quot;);</span></div><div><span style="font-family: Source Code Pro;">   }</span></div><div><span style="font-family: Source Code Pro;">}</span></div><div><span style="font-family: Source Code Pro;">public class DecoratorPatternExample {</span></div><div><span style="font-family: Source Code Pro;">   public static void main(String[] args) {</span></div><div><span style="font-family: Source Code Pro;">       System.<i>out</i>.println(&quot;***Decorator pattern Demo***\n&quot;);</span></div><div><span style="font-family: Source Code Pro;">       ConcreteComponent withoutDecorator = new ConcreteComponent();</span></div><div><span style="font-family: Source Code Pro;">       withoutDecorator.makeHouse();</span></div><div><span style="font-family: Source Code Pro;">       System.<i>out</i>.println(&quot;_________________&quot;);</span></div><div><span style="font-family: Source Code Pro;">       //Using a decorator to add floor</span></div><div><span style="font-family: Source Code Pro;">       System.<i>out</i>.println(&quot;Using a Floor decorator now.&quot;);</span></div><div><span style="font-family: Source Code Pro;">       FloorDecorator floorDecorator = new FloorDecorator();</span></div><div><span style="font-family: Source Code Pro;">       floorDecorator.setTheComponent(withoutDecorator);</span></div><div><span style="font-family: Source Code Pro;">       floorDecorator.makeHouse();</span></div><div><span style="font-family: Source Code Pro;">       System.<i>out</i>.println(&quot;_________________&quot;);</span></div><div><span style="font-family: Source Code Pro;">       //Using a decorator to add floor to original house and then</span></div><div><span style="font-family: Source Code Pro;">       //paint it.</span></div><div><span style="font-family: Source Code Pro;">       System.<i>out</i>.println(&quot;Using a Paint decorator now.&quot;);</span></div><div><span style="font-family: Source Code Pro;">       PaintDecorator paintDecorator = new PaintDecorator();</span></div><div><span style="font-family: Source Code Pro;">       //Adding results from floor decorator</span></div><div><span style="font-family: Source Code Pro;">       paintDecorator.setTheComponent(floorDecorator);</span></div><div><span style="font-family: Source Code Pro;">       paintDecorator.makeHouse();</span></div><div><span style="font-family: Source Code Pro;">       System.<i>out</i>.println(&quot;_________________&quot;);</span></div><div><span style="font-family: Source Code Pro;">   }</span></div><div><span style="font-family: Source Code Pro;">}</span></div></td></tr></tbody></table><div><br/></div><table style="width:1134px;" width="1134px"><colgroup><col style="width: 1134px;"></col></colgroup><tbody><tr><td style="border-color:rgb(204, 204, 204);"><div>D:   Can you explain how composition is promoting a dynamic behavior that inheritance cannot?</div></td></tr><tr><td style="border-color:rgb(204, 204, 204);"><div>R:    We know that when a derived class inherits from a parent class, it inherits the behavior of the base class at that time only. Though different subclasses can extend the base/parent class in different ways, this type of binding is known in compile-time, so the choice is static in nature. But the way that you used the concept of composition in the example lets you experiment with dynamic behavior.</div><div>When we design a parent class, we may not have enough visibility about <i>what kind of additional responsibilities our clients may want in</i> <i>later phases</i>. And our constraint is that we should not modify the existing code frequently. In such a case, object composition not only outclasses inheritances, it also ensures that we are not introducing bugs to the existing architecture. Lastly, in this context, you must remember one of the key design principles: <i>Classes should be open for extension but closed for modification.</i></div></td></tr></tbody></table><div><br/></div><table style="width:1134px;" width="1134px"><colgroup><col style="width: 1134px;"></col></colgroup><tbody><tr><td style="border-color:rgb(204, 204, 204);"><div>D:   What are the key advantages of using a decorator?</div></td></tr><tr><td style="border-color:rgb(204, 204, 204);"><div>R:</div><ul><li><div>The existing structure is untouched, so that you are not introducing bugs there.</div></li><li><div>New functionalities can be easily added to an existing object.</div></li><li><div>You do not need to predict/implement all the supported functionalities at the initial design phase. You can develop incrementally (e.g., add decorator objects one by one to support incremental needs). You must acknowledge the fact that if you make a complex class first, and then you try to extend the functionalities, it will be a tedious process.</div></li></ul></td></tr></tbody></table><div><br/></div><table style="width:1134px;" width="1134px"><colgroup><col style="width: 1134px;"></col></colgroup><tbody><tr><td style="border-color:rgb(204, 204, 204);"><div>D:   How is the overall design pattern different from inheritance?</div></td></tr><tr><td style="border-color:rgb(204, 204, 204);"><div>R:    You can add or remove responsibilities by simply attaching or detaching decorators. But with a simple inheritance mechanism, you need to create a new class for the new responsibilities. So, it is possible that you may end up with a complex system.</div><div><br/></div><div>Consider the example again. Suppose that you want to add a new floor, paint the house, and do <i>some extra work</i>. To fulfill this need, you start with decorator2 because it is already providing the support to add a floor to the existing architecture, and then you can paint it. So, you can add a simple wrapper to complete those additional responsibilities.</div><div>But if you start with inheritance from the beginning, then you may have multiple subclasses (e.g., one for adding a floor, one for painting the house). Figure below shows hierarchical inheritance.</div><div><br/></div><img src="7 - Decorator Pattern_files/Image [1].jpg" type="image/jpeg" data-filename="Image.jpg" style="--en-viewerProps:{};" width="378px"/><div><br/></div><div><br/></div><div>If you need an additional painted floor with extra features, you may end up with a design like the one shown in figure below</div><div><br/></div><img src="7 - Decorator Pattern_files/Image [2].jpg" type="image/jpeg" data-filename="Image.jpg" style="--en-viewerProps:{};" width="418px"/><div><br/></div><div><br/></div><div>Now you feel the heat of the diamond effect because in many programming languages including Java, multiple parent classes are not allowed.</div><div>In this context, even if you consider multilevel inheritance, you discover that overall the inheritance mechanism is much more challenging and time-consuming than the decorator pattern, and it may promote duplicate code in your application. Lastly, you must remember that inheritance mechanism is promoting only compile-time binding (not the dynamic binding).</div></td></tr></tbody></table><div><br/></div><table style="width:1134px;" width="1134px"><colgroup><col style="width: 1134px;"></col></colgroup><tbody><tr><td style="border-color:rgb(204, 204, 204);"><div>D:   Why can’t multilevel inheritance score higher in the previous context?</div></td></tr><tr><td style="border-color:rgb(204, 204, 204);"><div>R:    the decorator pattern surely outclasses the inheritance mechanism because you can simply add a decorator to the existing system that supports the client that you just want only.</div></td></tr></tbody></table><div><br/></div><table style="width:1134px;" width="1134px"><colgroup><col style="width: 1134px;"></col></colgroup><tbody><tr><td style="border-color:rgb(204, 204, 204);"><div>D:   Why are you creating a class with a single responsibility? You could make a subclass that can simply add a floor and then paint. In that case, you end up with fewer subclasses. Is this understanding correct?</div></td></tr><tr><td style="border-color:rgb(204, 204, 204);"><div>R:    If you are familiar with SOLID principles, you know that there is a principle called <i>single responsibility</i> . The idea behind this principle is that each class should have a responsibility over a single part of the functionality in the software. The decorator pattern is very much effective when you use the single responsibility principle because you can simply add/remove responsibilities dynamically.</div></td></tr></tbody></table><div><br/></div><table style="width:1134px;" width="1134px"><colgroup><col style="width: 1134px;"></col></colgroup><tbody><tr><td style="border-color:rgb(204, 204, 204);"><div>D:   What are the disadvantages associated with this pattern?</div></td></tr><tr><td style="border-color:rgb(204, 204, 204);"><div>R:    I believe that if you are careful enough, there is no significant disadvantage. But you must be aware of the fact that if you create too many decorators in the system, it will be hard to maintain and debug. So, in that case, it can create unnecessary confusion.</div></td></tr></tbody></table><div><br/></div><table style="width:1134px;" width="1134px"><colgroup><col style="width: 1134px;"></col></colgroup><tbody><tr><td style="border-color:rgb(204, 204, 204);"><div>D:   Is it mandatory to use decorators for dynamic binding only?</div></td></tr><tr><td style="border-color:rgb(204, 204, 204);"><div>R:    No. You can use both static and dynamic binding. But dynamic binding is its strength, so I concentrated on it. You may notice that the GoF definition also focused on dynamic binding only.</div></td></tr></tbody></table><div><br/></div><table style="width:1134px;" width="1134px"><colgroup><col style="width: 1134px;"></col></colgroup><tbody><tr><td style="border-color:rgb(204, 204, 204);"><div>D:   You are using decorators to wrap your core architecture. Is this correct?</div></td></tr><tr><td style="border-color:rgb(204, 204, 204);"><div>R: Yes. The decorators are wrapper code to extend the core functionalities of the application. But the core architecture is untouched when you use them.</div></td></tr></tbody></table><div><br/></div><div><br/></div></span>
</div></body></html> 