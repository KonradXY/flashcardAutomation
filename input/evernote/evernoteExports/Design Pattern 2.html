<html>
<head>
  <title>Evernote Export</title>
  <basefont face="Segoe UI" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/308816 (it-IT, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: Segoe UI;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="389"/>

<div><span><div><br/></div><table style="width:1236px;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td><div><span style="font-size: 14px;">Can you give an example of a singleton implemented with enums ?</span></div></td></tr><tr><td><div><span style="--en-fontfamily: monospace; font-family: &quot;Source Code Pro&quot;,monospace"><span style="font-size: 14px;">public enum EnumSingleton {</span></span></div><div><span style="--en-fontfamily: monospace; font-family: &quot;Source Code Pro&quot;,monospace"><span style="font-size: 14px;">    INSTANCE(&quot;Initial class info&quot;);</span></span></div><div><span style="--en-fontfamily: monospace; font-family: &quot;Source Code Pro&quot;,monospace"><span style="font-size: 14px;">    private String info;</span></span></div><div><span style="--en-fontfamily: monospace; font-family: &quot;Source Code Pro&quot;,monospace"><span style="font-size: 14px;">    private EnumSingleton(String info) {</span></span></div><div><span style="--en-fontfamily: monospace; font-family: &quot;Source Code Pro&quot;,monospace"><span style="font-size: 14px;">        this.info = info;</span></span></div><div><span style="--en-fontfamily: monospace; font-family: &quot;Source Code Pro&quot;,monospace"><span style="font-size: 14px;">    }</span></span></div><div><span style="--en-fontfamily: monospace; font-family: &quot;Source Code Pro&quot;,monospace"><span style="font-size: 14px;">    public EnumSingleton getInstance() {</span></span></div><div><span style="--en-fontfamily: monospace; font-family: &quot;Source Code Pro&quot;,monospace"><span style="font-size: 14px;">        return INSTANCE;</span></span></div><div><span style="--en-fontfamily: monospace; font-family: &quot;Source Code Pro&quot;,monospace"><span style="font-size: 14px;">    }</span></span></div><div><span style="--en-fontfamily: monospace; font-family: &quot;Source Code Pro&quot;,monospace"><span style="font-size: 14px;">    // getters and setters</span></span></div><div><span style="--en-fontfamily: monospace; font-family: &quot;Source Code Pro&quot;,monospace"><span style="font-size: 14px;">}</span></span></div><div><br/></div><div><span style="font-size: 14px;">This approach has serialization and thread-safety guaranteed by the enum implementation itself, which ensures internally that only the single instance is available, correcting the problems pointed out in the class-based implementation. The usage would be this way:</span></div><div><br/></div><div><span style="--en-fontfamily: monospace; font-family: &quot;Source Code Pro&quot;,monospace"><span style="font-size: 14px;">EnumSingleton enumSingleton1 = EnumSingleton.INSTANCE.getInstance();</span></span></div><div><span style="--en-fontfamily: monospace; font-family: &quot;Source Code Pro&quot;,monospace"><span style="font-size: 14px;">System.out.println(enumSingleton1.getInfo()); //Initial enum info</span></span></div><div><span style="--en-fontfamily: monospace; font-family: &quot;Source Code Pro&quot;,monospace"><span style="font-size: 14px;">EnumSingleton enumSingleton2 = EnumSingleton.INSTANCE.getInstance();</span></span></div><div><span style="--en-fontfamily: monospace; font-family: &quot;Source Code Pro&quot;,monospace"><span style="font-size: 14px;">enumSingleton2.setInfo(&quot;New enum info&quot;);</span></span></div><div><span style="--en-fontfamily: monospace; font-family: &quot;Source Code Pro&quot;,monospace"><span style="font-size: 14px;">System.out.println(enumSingleton1.getInfo()); // New enum info</span></span></div><div><span style="--en-fontfamily: monospace; font-family: &quot;Source Code Pro&quot;,monospace"><span style="font-size: 14px;">System.out.println(enumSingleton2.getInfo()); // New enum info</span></span></div><div style="padding-left:40px;"><br/></div><div style="padding-left:40px;"><br/></div></td></tr></tbody></table><div><br/></div><table style="width:1236px;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td><div><span style="font-size: 14px;">Why there's the need to make the fields of a singleton transient ?</span></div></td></tr><tr><td><div><span style="font-size: 14px;"><i>Variables may be marked transient to indicate that they are not part of the persistent state of an object.  </i>In other words, transient field cannot be serielizable.</span></div><div><span style="font-size: 14px;"><i>If we don’t do the transient and readResolve(), as the book stated. Otherwise, each time a serialized instance is deserialized, a new instance will be created, leading, in the case of our example, to spurious Elvis sightings.</i></span></div><div style="text-align:start;"><span style="font-size: 14px;">Serialization is converting the objects to bytes, and the bytes could persist in storage or communication link. Usually, the objects are stored in memory, thus they are reclaimed after the running. But with the serialization, thos byes are still in the storage, then later we can deserialize(restore) the object from bytes which has the same state as before.</span></div><div style="text-align:start;"><br/></div><div style="text-align:start;"><span style="font-size: 14px;">To make it serializable, the following steps are needed:</span></div><ol><li><div><span style="font-size: 14px;">Implements the Serializable interface.</span></div></li><li><div><span style="font-size: 14px;">Make all fields transient</span></div></li><li><div><span style="font-size: 14px;">Add the readResolve method</span></div></li></ol><div><br/></div><div><span style="--en-fontfamily: monospace; font-family: &quot;Source Code Pro&quot;,monospace"><b><span style="font-size: 14px;">public class </span></b><span style="font-size: 14px;">ElvisFactorySerializable </span><b><span style="font-size: 14px;">implements </span></b><span style="font-size: 14px;">Serializable{</span></span></div><div><span style="--en-fontfamily: monospace; font-family: &quot;Source Code Pro&quot;,monospace"><span style="font-size: 14px;">    </span><b><span style="font-size: 14px;">public static transient </span></b><span style="font-size: 14px;">ElvisFactorySerializable <i>instance </i>= </span><b><span style="font-size: 14px;">null</span></b><span style="font-size: 14px;">;</span></span></div><div><span style="--en-fontfamily: monospace; font-family: &quot;Source Code Pro&quot;,monospace"><span style="font-size: 14px;">    </span><b><span style="font-size: 14px;">private </span></b><span style="font-size: 14px;">ElvisFactorySerializable(){}</span></span></div><div><span style="--en-fontfamily: monospace; font-family: &quot;Source Code Pro&quot;,monospace"><span style="font-size: 14px;">    </span><b><span style="font-size: 14px;">public static </span></b><span style="font-size: 14px;">ElvisFactorySerializable getInstance() {</span></span></div><div><span style="--en-fontfamily: monospace; font-family: &quot;Source Code Pro&quot;,monospace"><span style="font-size: 14px;">        </span><b><span style="font-size: 14px;">if </span></b><span style="font-size: 14px;">(<i>instance</i>==</span><b><span style="font-size: 14px;">null</span></b><span style="font-size: 14px;">){</span></span></div><div><span style="--en-fontfamily: monospace; font-family: &quot;Source Code Pro&quot;,monospace"><span style="font-size: 14px;">            <i>instance </i>= </span><b><span style="font-size: 14px;">new </span></b><span style="font-size: 14px;">ElvisFactorySerializable();</span></span></div><div><span style="--en-fontfamily: monospace; font-family: &quot;Source Code Pro&quot;,monospace"><span style="font-size: 14px;">        }</span></span></div><div><span style="--en-fontfamily: monospace; font-family: &quot;Source Code Pro&quot;,monospace"><span style="font-size: 14px;">        </span><b><span style="font-size: 14px;">return </span></b><span style="font-size: 14px;"><i>instance</i>;</span></span></div><div><span style="--en-fontfamily: monospace; font-family: &quot;Source Code Pro&quot;,monospace"><span style="font-size: 14px;">    }</span></span></div><div><br/></div><div><span style="--en-fontfamily: monospace; font-family: &quot;Source Code Pro&quot;,monospace"><span style="font-size: 14px;">    </span><b><span style="font-size: 14px;">private </span></b><span style="font-size: 14px;">Object readResolve(){</span></span></div><div><span style="--en-fontfamily: monospace; font-family: &quot;Source Code Pro&quot;,monospace"><span style="font-size: 14px;"><i>        </i></span><b><span style="font-size: 14px;">return </span></b><span style="font-size: 14px;"><i>instance</i>;</span></span></div><div><span style="--en-fontfamily: monospace; font-family: &quot;Source Code Pro&quot;,monospace"><span style="font-size: 14px;">    }</span></span></div><div><span style="--en-fontfamily: monospace; font-family: &quot;Source Code Pro&quot;,monospace"><span style="font-size: 14px;">}</span></span></div></td></tr></tbody></table><div style="text-align:start;"><br/></div><table style="width:1236px;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td><div><span style="font-size: 14px;">What are the advantages of static factories ?</span></div></td></tr><tr><td><ol><li><div><b><span style="font-size: 14px;">Constructors don't have meaningful names</span></b><span style="font-size: 14px;">, so they are always restricted to the standard naming convention imposed by the language. </span><b><span style="font-size: 14px;">Static factory methods can have meaningful names</span></b><span style="font-size: 14px;">, hence explicitly conveying what they do</span></div></li><li><div><b><span style="font-size: 14px;">Static factory methods can return the same type that implements the method(s), a subtype, and also primitives</span></b><span style="font-size: 14px;">, so they offer a more flexible range of returning types</span></div></li><li><div><b><span style="font-size: 14px;">Static factory methods can encapsulate all the logic required for pre-constructing fully initialized instances</span></b><span style="font-size: 14px;">, so they can be used for moving this additional logic out of constructors. This prevents constructors from <a href="http://misko.hevery.com/code-reviewers-guide/flaw-constructor-does-real-work/" rev="en_rl_none">performing further tasks, others than just initializing fields</a></span></div></li><li><div><b><span style="font-size: 14px;">Static factory methods can be controlled-instanced methods</span></b><span style="font-size: 14px;">, with the <a href="https://en.wikipedia.org/wiki/Singleton_pattern" rev="en_rl_none">Singleton pattern</a> being the most glaring example of this featur</span></div></li></ol></td></tr></tbody></table><div><br/></div><table style="width:1236px;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td><div><span style="font-size: 14px;">What is a static factory ? can you give an example of a static factory method ?</span></div></td></tr><tr><td><div><span style="font-size: 14px;">Java constructors are the default mechanism for getting fully-initialized class instances. After all, they provide all the infrastructure required for injecting dependencies, either manually or automatically.</span></div><div><span style="font-size: 14px;">Even so, in a few specific use cases, it's preferable to resort to static factory methods for achieving the same result.</span></div><div><br/></div><div><span style="font-size: 14px;">Let's suppose that we want to provide the class with the ability for logging the time at which every <i>User</i> object is created.</span></div><div><b><span style="font-size: 14px;">If we just put this logic into the constructor, we'd be breaking the</span></b><span style="font-size: 14px;"> </span><b><span style="font-size: 14px;"><a href="https://en.wikipedia.org/wiki/Single_responsibility_principle" rev="en_rl_none">Single Responsibility Principle</a></span></b><span style="font-size: 14px;">. We would end up with a monolithic constructor that does a lot more than initialize fields.</span></div><div><b><span style="font-size: 14px;">We can keep our design clean with a static factory method:</span></b></div><div><br/></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">public class User {</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">   </span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">    private static final Logger LOGGER = Logger.getLogger(User.class.getName());</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">    private final String name;</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">    private final String email;</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">    private final String country;</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">   </span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">    // standard constructors / getters</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">   </span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">    public static User createWithLoggedInstantiationTime(</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">      String name, String email, String country) {</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">        setLoggerProperties();</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">        LOGGER.log(Level.INFO, &quot;Creating User instance at : {0}&quot;, LocalTime.now());</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">        return new User(name, email, country);</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">    }</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">   </span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">    private static void setLoggerProperties() {</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">        ConsoleHandler handler = new ConsoleHandler();</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">        handler.setLevel(Level.INFO);</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">        handler.setFormatter(new SimpleFormatter());</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">        LOGGER.addHandler(handler);</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">    }</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">}</span></span></div><div><br/></div><div><span style="font-size: 14px;">Here's how we'd create our improved <i>User</i> instance:</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">User user = User.createWithLoggedInstantiationTime(&quot;John&quot;, &quot;john@domain.com&quot;, &quot;Argentina&quot;);</span></span></div><div><br/></div><div><span style="font-size: 14px;">As shown above, we can encapsulate chunks of logic into static factory methods before returning fully-initialized <i>User</i> objects. And we can do this without polluting the constructor with the responsibility of performing multiple, unrelated tasks. For instance, </span><b><span style="font-size: 14px;">suppose we want to make our</span></b><span style="font-size: 14px;"> </span><b><span style="font-size: 14px;"><i>User</i></span></b><span style="font-size: 14px;"> </span><b><span style="font-size: 14px;">class a Singleton. We can achieve this by implementing an instance-controlled static factory method:</span></b></div><div><br/></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">public class User {</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">    private static volatile User instance = null;</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">    // other fields / standard constructors / getters</span></span></div><div><br/></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">    public static User getSingletonInstance(String name, String email, String country) {</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">        if (instance == null) {</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">            synchronized (User.class) {</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">                if (instance == null) {</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">                    instance = new User(name, email, country);</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">                }</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">            }</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">        }</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">        return instance;</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">    }</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">}</span></span></div><div><br/></div><div><span style="font-size: 14px;">The implementation of the <i>getSingletonInstance()</i> method is </span><b><span style="font-size: 14px;">thread-safe, with a small performance penalty, due to the synchronized block</span></b><span style="font-size: 14px;">. In this case, we used lazy initialization to demonstrate the implementation of an instance-controlled static factory method. It's worth mentioning, however, that </span><b><span style="font-size: 14px;">the best way to implement a Singleton is with a Java</span></b><span style="font-size: 14px;"> </span><b><span style="font-size: 14px;"><i>enum</i></span></b><span style="font-size: 14px;"> </span><b><span style="font-size: 14px;">type, as it's both serialization-safe and thread-safe</span></b><span style="font-size: 14px;">. For the full details on how to implement Singletons using different approaches, please check <a href="https://www.baeldung.com/java-singleton" rev="en_rl_none">this article</a>. As expected, getting a <i>User</i> object with this method looks very similar to the previous examples:</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">User user = User.getSingletonInstance(&quot;John&quot;, &quot;john@domain.com&quot;, &quot;Argentina&quot;);</span></span></div></td></tr></tbody></table><div><br/></div><table style="width:1236px;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td><div><span style="font-size: 14px;">why the fact that static factories are advantageous because they have a name can be false ?</span></div></td></tr><tr><td><div><span style="font-size: 14px;">This is how you make a <a href="http://www.rapidtables.com/web/color/red-color.htm" rev="en_rl_none">red tomato</a> color object with a constructor:</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">Color tomato = new Color(255, 99, 71);</span></span></div><div><br/></div><div><span style="font-size: 14px;">This is how you do it with a static factory method:</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">Color tomato = Color.makeFromPalette(255, 99, 71);</span></span></div><div><br/></div><div><span style="font-size: 14px;">It seems that makeFromPalette() is semantically richer than just new Color(), right? Well, yes. Who knows what those three numbers mean if we just pass them to the constructor. But the word &quot;palette&quot; helps us figure everything out immediately. True. However, the right solution would be to use polymorphism and encapsulation, to decompose the problem into a few semantically rich classes:</span></div><div><br/></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">interface Color {}</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">class HexColor implements Color {</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">    private final int hex;</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">    HexColor(int h) {</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">        this.hex = h;</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">    }</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">}</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">class RGBColor implements Color {</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">    private final Color origin;</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">    RGBColor(int red, int green, int blue) {</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">        this.origin = new HexColor(</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">            red &lt;&lt; 16 + green &lt;&lt; 8 + blue</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">        );</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">    }</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">}</span></span></div><div><span style="font-size: 14px;">Now, we use the right constructor of the right class: </span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">Color tomato = new RGBColor(255, 99, 71);</span></span></div></td></tr></tbody></table><div><br/></div><table style="width:1236px;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td><div><span style="font-size: 14px;">why the fact that static factories are advantageous because they can return subtype can be false ?</span></div></td></tr><tr><td><div><span style="font-size: 14px;">Let's say our class Color has a method lighter(), which is supposed to shift the color to the next available lighter one:</span></div><div><br/></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">class Color {</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    protected final int hex;</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    Color(int h) {</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">        this.hex = h;</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    }</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    public Color lighter() {</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">        return new Color(hex + 0x111);</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    }</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">}</span></span></div><div><br/></div><div><span style="font-size: 14px;">However, sometimes it's more desirable to pick the next lighter color through a set of available <a href="https://en.wikipedia.org/wiki/Pantone" rev="en_rl_none">Pantone</a> colors:</span></div><div><br/></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">class PantoneColor extends Color {</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    private final PantoneName pantone;</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    PantoneColor(String name) {</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">        this(new PantoneName(name));</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    }</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    PantoneColor(PantoneName name) {</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">        this.pantone = name;</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    }</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    @Override</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    public Color lighter() {</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">        return new PantoneColor(this.pantone.up());</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    }</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">}</span></span></div><div><br/></div><div><span style="font-size: 14px;">Then, we create a static factory method, which will decide which Color implementation is the most suitable for us:</span></div><div><br/></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">class Color {</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    private final String code;</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    static Color make(int h) {</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">        if (h == 0xBF1932) {</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">            return new PantoneColor(&quot;19-1664 TPX&quot;);</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">        }</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">        return new RGBColor(h);</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    }</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">}</span></span></div><div><br/></div><div><span style="font-size: 14px;">If the <a href="https://www.pantone.com/color-finder/19-1664-TPX" rev="en_rl_none">true red</a> color is requested, we return an instance of PantoneColor. In all other cases it's just a standard RGBColor. The decision is made by the static factory method. This is how we will call it:</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">Color color = Color.make(0xBF1932);</span></span></div><div><br/></div><div><span style="font-size: 14px;">It would not be possible to do the same &quot;forking&quot; with a constructor, since it can only return the class it is declared in. A static method has all the necessary freedom to return any subtype of Color.</span></div><div><span style="font-size: 14px;">True. However, in an object-oriented world we can and must do it all differently. First, we would make Color an interface:</span></div><div><br/></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">interface Color {</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    Color lighter();</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">}</span></span></div><div><br/></div><div><span style="font-size: 14px;">Next, we would move this decision making process to its own class Colors, just like we did in the previous example:</span></div><div><br/></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">class Colors {</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    Color make(int h) {</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">        if (h == 0xBF1932) {</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">            return new PantoneColor(&quot;19-1664-TPX&quot;);</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">        }</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">        return new RGBColor(h);</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    }</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">}</span></span></div><div><br/></div><div><span style="font-size: 14px;">And we would use an instance of class Colors instead of a static faсtory method inside Color:</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">colors.make(0xBF1932);</span></span></div><div><br/></div><div><span style="font-size: 14px;">However, this is still not really an object-oriented way of thinking, because we're taking the decision-making away from the object it belongs to. Either through a static factory method make() or a new class Colors—it doesn't really matter how—we tear our objects into two pieces. The first piece is the object itself and the second one is the decision making algorithm that stays somewhere else.</span></div><div><span style="font-size: 14px;">A much more object-oriented design would be to put the logic into an object of class PantoneColor which would decorate the original RGBColor:</span></div><div><br/></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">class PantoneColor {</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    private final Color origin;</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    PantoneColor(Color color) {</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">        this.origin = color;</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    }</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    @Override</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    public Color lighter() {</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">        final Color next;</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">        if (this.origin.hex() == 0xBF1932) {</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">            next = new RGBColor(0xD12631);</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">        } else {</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">            next = this.origin.lighter();</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">        }</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">        return new PantoneColor(next);</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    }</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">)</span></span></div><div><br/></div><div><span style="font-size: 14px;">Then, we make an instance of RGBColor and decorate it with PantoneColor:</span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">Color red = new PantoneColor(</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    new RGBColor(0xBF1932)</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">);</span></span></div><div><br/></div><div><span style="font-size: 14px;">We ask red to return a lighter color and it returns the one from the Pantone palette, not the one that is merely lighter in RGB coordinates:</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">Color lighter = red.lighter(); // 0xD12631</span></span></div></td></tr></tbody></table><div><br/></div><table style="width:1236px;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td><div><span style="font-size: 14px;">why the fact that static factories are advantageous because they can cache can be false ?</span></div></td></tr><tr><td><div><span style="font-size: 14px;">Let's say I need a red tomato color in multiple places in the application:</span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">Color tomato = new Color(255, 99, 71);</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">// ... sometime later</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">Color red = new Color(255, 99, 71);</span></span></div><div><br/></div><div><span style="font-size: 14px;">Two objects will be created, which is obviously inefficient, since they are identical. It would be better to keep the first instance somewhere in memory and return it when the second call arrives. Static factory methods make it possible to solve this very problem:</span></div><div><br/></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">Color tomato = Color.makeFromPalette(255, 99, 71);</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">// ... sometime later</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">Color red = Color.makeFromPalette(255, 99, 71);</span></span></div><div><br/></div><div><span style="font-size: 14px;">Then somewhere inside the Color we keep a private static Map with all the objects already instantiated:</span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">class Color {</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    private static final Map &lt; Integer, Color &gt; CACHE =</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">        new HashMap &lt; &gt; ();</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    private final int hex;</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    static Color makeFromPalette(int red, int green, int blue) {</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">        final int hex = red &lt;&lt; 16 + green &lt;&lt; 8 + blue;</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">        return Color.CACHE.computeIfAbsent(</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">            hex, h - &gt; new Color(h)</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">        );</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    }</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    private Color(int h) {</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">        return new Color(h);</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    }</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">}</span></span></div><div><br/></div><div><span style="font-size: 14px;">It is very effective performance-wise. With a small object like our Color the problem may not be so obvious, but when objects are bigger, their instantiation and garbage collection may waste a lot of time.</span></div><div><span style="font-size: 14px;">True. However, there is an object-oriented way to solve this problem. We just introduce a new class Palette, which becomes a store of colors:</span></div><div><br/></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">class Palette {</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    private final Map &lt; Integer, Color &gt; colors =</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">        new HashMap &lt; &gt; ();</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    Color take(int red, int green, int blue) {</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">        final int hex = red &lt;&lt; 16 + green &lt;&lt; 8 + blue;</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">        return this.computerIfAbsent(</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">            hex, h - &gt; new Color(h)</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">        );</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    }</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">}</span></span></div><div><br/></div><div><span style="font-size: 14px;">Now, we make an instance of Palette once and ask it to return a color to us every time we need it:</span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">Color tomato = palette.take(255, 99, 71);</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">// Later we will get the same instance:</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">Color red = palette.take(255, 99, 71);</span></span></div></td></tr></tbody></table><div><br/></div><table style="width:1236px;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td><div><span style="font-size: 14px;">can you explain the purpose of the service locator pattern ?</span></div></td></tr><tr><td><div><b><span style="font-size: 14px;">The purpose of the Service Locator pattern is to return the service instances on demand.</span></b><span style="font-size: 14px;"> This is useful for decoupling service consumers from concrete classes.</span></div><div><span style="font-size: 14px;">An implementation will consist of the following components:</span></div><ul><li><div><span style="font-size: 14px;">Client – the client object is a service consumer. It's responsible for invoking the request from the service locator</span></div></li><li><div><span style="font-size: 14px;">Service Locator – is a communication entry point for returning the services from the cache</span></div></li><li><div><span style="font-size: 14px;">Cache – an object for storing service references to reuse them later</span></div></li><li><div><span style="font-size: 14px;">Initializer – creates and registers references to services in the cache</span></div></li><li><div><span style="font-size: 14px;">Service – the Service component represents the original services or their implementation</span></div></li></ul><div><br/></div><div><span style="font-size: 14px;">The original service object is looked up by the locator and returned on demand.</span></div></td></tr></tbody></table><div><br/></div><table style="width:1236px;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td><div><span style="font-size: 14px;">can you show an implementation of the service locator pattern ?</span></div></td></tr><tr><td><div><span style="font-size: 14px;">First, we'll create a <i>MessagingService</i> interface for sending messages in different ways:</span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">public interface MessagingService {</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    String getMessageBody();</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    String getServiceName();</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">}</span></span></div><div><br/></div><div><span style="font-size: 14px;">Next, we'll define two implementations of the interface above, that send messages through email and SMS:</span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">public class EmailService implements MessagingService {</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    public String getMessageBody() {</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">        return &quot;email message&quot;;</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    }</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    public String getServiceName() {</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">        return &quot;EmailService&quot;;</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    }</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">}</span></span></div><div><br/></div><div><span style="font-size: 14px;">The <i>SMSService</i> class definition is similar to the <i>EmailService</i> class.</span></div><div><br/></div><div><span style="font-size: 14px;">After defining the two services, we have to define the logic to initialize them:</span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">public class InitialContext {</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    public Object lookup(String serviceName) {</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">        if (serviceName.equalsIgnoreCase(&quot;EmailService&quot;)) {</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">            return new EmailService();</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">        } else if (serviceName.equalsIgnoreCase(&quot;SMSService&quot;)) {</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">            return new SMSService();</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">        }</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">        return null;</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    }</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">}</span></span></div><div><br/></div><div><span style="font-size: 14px;">The last component we need before putting the service locator object together is the cache.</span></div><div><span style="font-size: 14px;">In our example, this is a simple class with a <i>List</i> property:</span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">public class Cache {</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    private List&lt;MessagingService&gt; services = new ArrayList&lt;&gt;();</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    public MessagingService getService(String serviceName) {</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">        // retrieve from the list</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    }</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    public void addService(MessagingService newService) {</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">        // add to the list</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    }</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">}</span></span></div><div><br/></div><div><span style="font-size: 14px;">Finally, we can implement our service locator class:</span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">public class ServiceLocator {</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    private static Cache cache = new Cache();</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    public static MessagingService getService(String serviceName) {</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">        MessagingService service = cache.getService(serviceName);</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">        if (service != null) {</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">            return service;</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">        }</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">        InitialContext context = new InitialContext();</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">        MessagingService service1 = (MessagingService) context</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">          .lookup(serviceName);</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">        cache.addService(service1);</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">        return service1;</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">    }</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">}</span></span></div><div><br/></div><div><span style="font-size: 14px;">The logic here is fairly simple. The class holds an instance of the <i>Cache.</i> Then, in the <i>getService()</i> method, it will first check the cache for an instance of the service. Then, if that's <i>null,</i> it will call the initializing logic and add the new object to the cache.</span></div></td></tr></tbody></table><div><br/></div><table style="width:1236px;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td><div><span style="font-size: 14px;">what are the differences between dependency injectoin and the service locator pattern ?</span></div></td></tr><tr><td><div><span style="font-size: 14px;">At first glance, the Service Locator pattern may look similar to another well-known pattern – namely, Dependency Injection.</span></div><div><span style="font-size: 14px;">First, it's important to note that </span><b><span style="font-size: 14px;">both Dependency Injection and the Service Locator pattern are implementations of the Inversion of Control concept</span></b><span style="font-size: 14px;">.</span></div><div><b><span style="font-size: 14px;">The key difference here is that the client object still creates its dependencies</span></b><span style="font-size: 14px;">. It just uses the locator for that, meaning it needs a reference to the locator object.</span></div><div><span style="font-size: 14px;">By comparison, when using the dependency injection, the class is given the dependencies. The injector is called only once at startup to inject dependencies into the class.</span></div></td></tr></tbody></table><div><br/></div><table style="width:1236px;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border-color:rgb(204, 204, 204);"><div><span style="font-size: 14px;">when we should avoid the use of the service locator ?</span></div></td></tr><tr><td style="border-color:rgb(204, 204, 204);"><div><span style="font-size: 14px;">Finally, let's consider a few reasons to avoid using the Service Locator pattern. </span></div><div><span style="font-size: 14px;">One argument against it is that it makes unit testing difficult. With dependency injection, we can pass mock objects of the dependent class to the tested instance. On the other hand, this is a bottleneck with the Service Locator pattern. Another issue is that it's trickier to use APIs based on this pattern. The reason for this is that the dependencies are hidden inside the class and they're only verified at runtime.</span></div><div><span style="font-size: 14px;">Despite all of this, the Service Locator pattern is easy to code and understand, and can be a great choice for small applications.</span></div></td></tr></tbody></table><div><br/></div><table style="width:1236px;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td><div><span style="font-size: 14px;">how can you implement decorator pattern with streams in java 8 ?</span></div></td></tr><tr><td><img src="Design Pattern 2_files/Image.png" type="image/png" data-filename="Image.png"/><div><br/></div><div><br/></div><div><br/></div><div><span style="font-size: 14px;">To use all the power of Java 8 I recommend to add a special interface for all decorators, the DecoratingComponent. The abstract superclass for decorators implements that interface but, as before, only holds a reference to Component.</span></div><div><span style="font-size: 14px;">It is important to notice that due to the definition of the new interface (see below) nothing changes for the concrete decorators. They are exactly identical in both realizations of the pattern. The abstract class also undergoes virtually no change (see further below) so switching to this solution has no noticeable costs.</span></div><div><br/></div><div><span style="font-size: 14px;">The new interface DecoratingComponent extends the basic component interface and provides factory methods for decorators. These are static or <a href="http://blog.codefx.org/java/everything-about-default-methods/" rev="en_rl_none">default/defender methods</a> (so they are already implemented <a href="http://stackoverflow.com/a/23476994" rev="en_rl_none">and would be final if they could be</a>) and no abstract methods should be declared. This way, the new interface does not add an extra burden on the implementations further down the inheritance tree.</span></div><div style="text-align:start;"><br/></div><div><span style="font-size: 14px;">To quickly move from a Component to a DecoratingComponent, the interface should have a static method which takes the first and returns the latter. Since DecoratingComponent extends Component and adds no abstract methods, this is trivial. Simply create an anonymous implementation and forward all calls to the adapted component.</span></div><div><br/></div><div><span style="font-size: 14px;">The general approach would look like this:</span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">static DecoratingComponent from(Component component) {</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">  DecoratingComponent adapted = new DecoratingComponent() {</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">    </span></span><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">@Override</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">    </span></span><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">public SomeReturn someMethod(SomeArgument argument) {</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">        </span></span><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">return component.someMethod(argument);</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">    </span></span><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">}</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">    </span></span><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">// ... more methods here ...</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">  };</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">return adapted;</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">}</span></span></div><div><br/></div><div><br/></div><div><span style="font-size: 14px;">In case of the DecoratingHyperlinkListener it is much easier because it’s a functional interface so a lambda expression can be used:</span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">static DecoratingHyperlinkListener from(HyperlinkListener listener) {</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">    </span></span><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">return event -&gt; listener.hyperlinkUpdate(event);</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">}</span></span></div></td></tr></tbody></table><div><br/></div><table style="width:1236px;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td><div><span style="font-size: 14px;">In relations to the DecoratingComponent pattern, could you implement a Generic Decorator component ?</span></div></td></tr><tr><td><div><b><span style="font-size: 14px;">Generic Decoration. </span></b><span style="font-size: 14px;">This is the essential method of the interface:</span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">default DecoratingComponent decorate(</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">    </span></span><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">Function&lt;? super DecoratingComponent, ? extends DecoratingComponent&gt;</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">    </span></span><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">decorator) {</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">        </span></span><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">return decorator.apply(this);</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">}</span></span></div><div><br/></div><div><br/></div><div><span style="font-size: 14px;">It takes a function from one decorating component to another as an argument. It applies the function to itself to create a decorated instance, which is then returned.</span></div><div><span style="font-size: 14px;">This method can be used throughout the whole code to decorate any component in a simple and readable way:</span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">Component some = ...;</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">DecoratingComponent decorated = DecoratingComponent</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">// create an instance of 'DecoratingComponent' from the 'Component'</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">    </span></span><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">.from(some)</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">// now decorate it</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">    </span></span><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">.decorate(component -&gt; new MyCoolComponentDecorator(component, ...));</span></span></div><div><br/></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">// if you already have an instance of 'DecoratingComponent', it get's easier</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">decorated = decorated</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">    </span></span><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">.decorate(component -&gt; new MyBestComponentDecorator(component, ...));</span></span></div><div><br/></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">// constructor references are even clearer (but cannot always be used)</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">decorated = decorated.decorate(MyBestComponentDecorator::new);</span></span></div></td></tr></tbody></table><div><br/></div><table style="width:1236px;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td><div><span style="font-size: 14px;">in relation to the DecoratingComponent pattern, could you implement a concrete decorator component ?</span></div></td></tr><tr><td><div><b><span style="font-size: 14px;">Concrete Decorations</span></b></div><div><span style="font-size: 14px;">You can also add methods to decorate instances with concrete decorators:</span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">default DecoratingHyperlinkListener logEvents() {</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">    </span></span><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">return LogEventsToConsole.decorate(this);</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">}</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">default DecoratingHyperlinkListener onHoverMakeVisible(JComponent component) {</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">    </span></span><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">return OnHoverMakeComponentVisible.decorate(this, component);</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">}</span></span></div><div><br/></div><div><span style="font-size: 14px;">They make decorating very succinct and readable:</span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">DecoratingComponent decorated = ...</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">decorated = decorated.logEvents();</span></span></div><div><br/></div><div><br/></div><div><span style="font-size: 14px;">But it is debatable whether these methods should really be added. While they are very convenient, a strong argument can be made against them as they create a circular dependency. Not only do the decorators know about the interface (which they implement indirectly via the abstract superclass), now the interface also knows its implementations. In general this is a pungent code smell.</span></div><div><br/></div><div><span style="font-size: 14px;">The final call is not yet in on this but I recommend a pragmatic middle way. I let the interface know about the implementations which live in the same package. This will be the generic ones as they do not reference anything too concrete from the rest of my code. But I would not let it know about every crazy decorator I created deep in the bowels of the system. (And of course I would neither add all those decorators to the same package unless it’s already called <i>the_kraken</i>…)</span></div><div><br/></div><div><span style="font-size: 14px;">Worse though, all decorators would have to expose the fact that they are an AbstractDecorator. Suddenly there is an abstract class, which was only created to ease the implementation, creeping through the whole code base.</span></div></td></tr></tbody></table><div><br/></div><table style="width:1236px;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td><div><span style="font-size: 14px;">why in the decorated stream design you putted an extra interface ?</span></div></td></tr><tr><td><div><span style="font-size: 14px;">Yes, yes, all those Java 8 features are very nice but couldn’t you simply add these methods to AbstractDecorator? Good question!</span></div><div><span style="font-size: 14px;">Of course, I could’ve just added them there. But I don’t like that solution for two reasons.</span></div><div><br/></div><ol><li><div><b><span style="font-size: 14px;">Single Responsibility Principle. </span></b><span style="font-size: 14px;">First, that would blur the responsibilities of the classes. The new interface is responsible for decorating instances of Component, the abstract superclass is responsible for enabling easy implementation of decorators. These are not the same things and they do not change for the same reason. The new interface might change whenever a new decorator has to be included. The abstract class will change whenever Component changes.</span></div></li></ol><div><br/></div><ol start="2"><li><div><b><span style="font-size: 14px;">Type Hierarchy. </span></b><span style="font-size: 14px;">If these methods were added to AbstractDecorator, they could only be called on such instances. So all decorators would have to inherit from that class, which limits the range for future implementations. Who knows, maybe some really good reason comes up, why another class can not be an AbstractDecorator.</span></div></li></ol></td></tr></tbody></table><div><br/></div><table style="width:1236px;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td><div><span style="font-size: 14px;">what are the consideration you need to take care when implementing the decorator pattern with the extra interface ?</span></div></td></tr><tr><td><div><b><span style="font-size: 14px;">Changes To The Abstract Decorator Class. </span></b><span style="font-size: 14px;">If you have access to the class, you should let it implement DecoratingComponent instead of Component. As no new abstract methods were introduced this entails no further changes. This is shown in the UML diagram above. If you can not change the class, your decorators will only implement Component. This will keep you from using their constructors to create a function which maps a component to a decorating component. As you need that function as an argument for the decorate method, you have to change that method to look as follows:</span></div><div><br/></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">// note the more general second type of the 'Function' interface</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">default DecoratingComponent decorate(</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">Function&lt;? super DecoratingComponent, ? extends Component&gt; decorator) {</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">// create the decorated instance as before</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">Component decorated = decorator.apply(this);</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">// since it is no 'DecoratingComponent' use 'from' to turn it into one</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">return from(decorated);</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">}</span></span></div><div><br/></div><div><br/></div><div><b><span style="font-size: 14px;">Changes To The Decorators</span></b></div><div><span style="font-size: 14px;">No changes to those classes are necessary. Unless of course, you are one of those crazy people who use static factory methods. Than you would have to make sure that they declare their return type as DecoratingComponent or you’re in the same situation as when the abstract superclass can not implement the new interface. If you can not change the decorator classes, the same solution works here.</span></div><div><br/></div><div><b><span style="font-size: 14px;">Example</span></b></div><div><span style="font-size: 14px;">So let’s look at the snippet from above again:</span></div><div><br/></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">HyperlinkListener listener = this::changeHtmlViewBackgroundColor; </span></span><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">// create a 'HyperlinkListener' with a method reference</span></span></div><div><br/></div><div><br/></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">listener = DecoratingHyperlinkListener </span></span><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">// decorate that instance with different behaviors </span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">// (note that each call actually returns a new instance so the result has to be assigned to a variable)</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">     .from(listener) </span></span><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">// adapt the 'HyperlinkListener' to be a 'DecoratingHyperlinkListener'</span></span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">                     // (looks better if it is not on its own line)</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">     .onHoverMakeVisible(urlLabel) </span></span><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">// call some concrete decorator functions</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">     .onHoverSetUrlOn(urlLabel)</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">     .logEvents()</span></span></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">     .decorate(l -&gt; new OnActivateHighlightComponent(l, urlLabel)) </span></span><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">// call the generic decorator function with a lambda expression</span></span></div><div><br/></div><div><span style="font-family: Source Code Pro;"><span style="font-size: 14px;">.decorate(OnEnterLogUrl::new); </span></span><span style="font-family: &quot;Source Code Pro&quot;;"><span style="font-size: 14px;">// call the generic decorator function with a constructor reference</span></span></div></td></tr><tr><td><div><br/></div></td></tr></tbody></table><div><br/></div><div><br/></div></span>
</div></body></html> 