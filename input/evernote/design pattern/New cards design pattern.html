<html>
<head>
  <title>Evernote Export</title>
  <basefont face="Segoe UI" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/308716 (en-US, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: Segoe UI;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="583"/>

<div>
<span><div><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="width: 1236px; padding: 8px; border: 1px solid;"><div>Can you give an example of a singleton implemented with enums ?</div></td></tr><tr><td style="width: 1236px; padding: 8px; border: 1px solid;"><div><span style="font-family: &quot;Source Code Pro&quot;;">public enum EnumSingleton {</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">    INSTANCE(&quot;Initial class info&quot;);</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">    private String info;</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">    private EnumSingleton(String info) {</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">        this.info = info;</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">    }</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">    public EnumSingleton getInstance() {</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">        return INSTANCE;</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">    }</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">    // getters and setters</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">}</span></div><div><br/></div><div>This approach has serialization and thread-safety guaranteed by the enum implementation itself, which ensures internally that only the single instance is available, correcting the problems pointed out in the class-based implementation. The usage would be this way:</div><div style="text-align:start;"></div><div><br/></div><div><span style="font-family: &quot;Source Code Pro&quot;;">EnumSingleton enumSingleton1 = EnumSingleton.INSTANCE.getInstance();</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">System.out.println(enumSingleton1.getInfo()); //Initial enum info</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">EnumSingleton enumSingleton2 = EnumSingleton.INSTANCE.getInstance();</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">enumSingleton2.setInfo(&quot;New enum info&quot;);</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">System.out.println(enumSingleton1.getInfo()); // New enum info</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">System.out.println(enumSingleton2.getInfo()); // New enum info</span></div><div style="padding-left:40px;"></div><div style="padding-left:40px;"></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="width: 1236px; padding: 8px; border: 1px solid;"><div>What are the advantages of static factories ?</div></td></tr><tr><td style="width: 1236px; padding: 8px; border: 1px solid;"><ol><li><div><span style="font-weight: bold;">Constructors don't have meaningful names</span>, so they are always restricted to the standard naming convention imposed by the language. <span style="font-weight: bold;">Static factory methods can have meaningful names</span>, hence explicitly conveying what they do</div></li><li><div><span style="font-weight: bold;">Static factory methods can return the same type that implements the method(s), a subtype, and also primitives</span>, so they offer a more flexible range of returning types</div></li><li><div><span style="font-weight: bold;">Static factory methods can encapsulate all the logic required for pre-constructing fully initialized instances</span>, so they can be used for moving this additional logic out of constructors. This prevents constructors from <a href="http://misko.hevery.com/code-reviewers-guide/flaw-constructor-does-real-work/">performing further tasks, others than just initializing fields</a></div></li><li><div><span style="font-weight: bold;">Static factory methods can be controlled-instanced methods</span>, with the <a href="https://en.wikipedia.org/wiki/Singleton_pattern">Singleton pattern</a> being the most glaring example of this featur</div></li></ol></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="width: 1236px; padding: 8px; border: 1px solid;"><div>What is a static factory ? can you give an example of a static factory method ?</div></td></tr><tr><td style="width: 1236px; padding: 8px; border: 1px solid;"><div>Java constructors are the default mechanism for getting fully-initialized class instances. After all, they provide all the infrastructure required for injecting dependencies, either manually or automatically.</div><div>Even so, in a few specific use cases, it's preferable to resort to static factory methods for achieving the same result.</div><div><br/></div><div>Let's suppose that we want to provide the class with the ability for logging the time at which every <span style="font-style: italic;">User</span> object is created.</div><div><span style="font-weight: bold;">If we just put this logic into the constructor, we'd be breaking the</span> <a href="https://en.wikipedia.org/wiki/Single_responsibility_principle" style="font-weight: bold;">Single Responsibility Principle</a>. We would end up with a monolithic constructor that does a lot more than initialize fields.</div><div><span style="font-weight: bold;">We can keep our design clean with a static factory method:</span></div><div><br/></div><div><span style="font-family: &quot;Source Code Pro&quot;;">public class User {</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">   </span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">    private static final Logger LOGGER = Logger.getLogger(User.class.getName());</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">    private final String name;</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">    private final String email;</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">    private final String country;</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">   </span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">    // standard constructors / getters</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">   </span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">    public static User createWithLoggedInstantiationTime(</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">      String name, String email, String country) {</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">        setLoggerProperties();</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">        LOGGER.log(Level.INFO, &quot;Creating User instance at : {0}&quot;, LocalTime.now());</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">        return new User(name, email, country);</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">    }</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">   </span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">    private static void setLoggerProperties() {</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">        ConsoleHandler handler = new ConsoleHandler();</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">        handler.setLevel(Level.INFO);</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">        handler.setFormatter(new SimpleFormatter());</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">        LOGGER.addHandler(handler);</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">    }</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">}</span></div><div><br/></div><div>Here's how we'd create our improved <span style="font-style: italic;">User</span> instance:</div><div><span style="font-family: &quot;Source Code Pro&quot;;">User user = User.createWithLoggedInstantiationTime(&quot;John&quot;, &quot;john@domain.com&quot;, &quot;Argentina&quot;);</span></div><div><br/></div><div>As shown above, we can encapsulate chunks of logic into static factory methods before returning fully-initialized <span style="font-style: italic;">User</span> objects. And we can do this without polluting the constructor with the responsibility of performing multiple, unrelated tasks. For instance, <span style="font-weight: bold;">suppose we want to make our</span> <span style="font-style: italic; font-weight: bold;">User</span> <span style="font-weight: bold;">class a Singleton. We can achieve this by implementing an instance-controlled static factory method:</span></div><div><br/></div><div><span style="font-family: &quot;Source Code Pro&quot;;">public class User {</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">    private static volatile User instance = null;</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">    // other fields / standard constructors / getters</span></div><div><br/></div><div><span style="font-family: &quot;Source Code Pro&quot;;">    public static User getSingletonInstance(String name, String email, String country) {</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">        if (instance == null) {</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">            synchronized (User.class) {</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">                if (instance == null) {</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">                    instance = new User(name, email, country);</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">                }</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">            }</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">        }</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">        return instance;</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">    }</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">}</span></div><div><br/></div><div>The implementation of the <span style="font-style: italic;">getSingletonInstance()</span> method is <span style="font-weight: bold;">thread-safe, with a small performance penalty, due to the synchronized block</span>. In this case, we used lazy initialization to demonstrate the implementation of an instance-controlled static factory method. It's worth mentioning, however, that <span style="font-weight: bold;">the best way to implement a Singleton is with a Java</span> <span style="font-style: italic; font-weight: bold;">enum</span> <span style="font-weight: bold;">type, as it's both serialization-safe and thread-safe</span>. For the full details on how to implement Singletons using different approaches, please check <a href="https://www.baeldung.com/java-singleton">this article</a>. As expected, getting a <span style="font-style: italic;">User</span> object with this method looks very similar to the previous examples:</div><div><span style="font-family: &quot;Source Code Pro&quot;;">User user = User.getSingletonInstance(&quot;John&quot;, &quot;john@domain.com&quot;, &quot;Argentina&quot;);</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="width: 1236px; padding: 8px; border: 1px solid;"><div>why the fact that static factories are advantageous because they have a name can be false ?</div></td></tr><tr><td style="width: 1236px; padding: 8px; border: 1px solid;"><div>This is how you make a <a href="http://www.rapidtables.com/web/color/red-color.htm">red tomato</a> color object with a constructor:</div><div><span style="font-family: &quot;Source Code Pro&quot;;">Color tomato = new Color(255, 99, 71);</span></div><div><br/></div><div>This is how you do it with a static factory method:</div><div><span style="font-family: &quot;Source Code Pro&quot;;">Color tomato = Color.makeFromPalette(255, 99, 71);</span></div><div><br/></div><div>It seems that makeFromPalette() is semantically richer than just new Color(), right? Well, yes. Who knows what those three numbers mean if we just pass them to the constructor. But the word &quot;palette&quot; helps us figure everything out immediately. True. However, the right solution would be to use polymorphism and encapsulation, to decompose the problem into a few semantically rich classes:</div><div><br/></div><div><span style="font-family: &quot;Source Code Pro&quot;;">interface Color {}</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">class HexColor implements Color {</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">    private final int hex;</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">    HexColor(int h) {</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">        this.hex = h;</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">    }</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">}</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">class RGBColor implements Color {</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">    private final Color origin;</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">    RGBColor(int red, int green, int blue) {</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">        this.origin = new HexColor(</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">            red &lt;&lt; 16 + green &lt;&lt; 8 + blue</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">        );</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">    }</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">}</span></div><div>Now, we use the right constructor of the right class: </div><div><span style="font-family: &quot;Source Code Pro&quot;;">Color tomato = new RGBColor(255, 99, 71);</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="width: 1236px; padding: 8px; border: 1px solid;"><div>why the fact that static factories are advantageous because they can return subtype can be false ?</div></td></tr><tr><td style="width: 1236px; padding: 8px; border: 1px solid;"><div>Let's say our class Color has a method lighter(), which is supposed to shift the color to the next available lighter one:</div><div><br/></div><div><font face="Source Code Pro">class Color {</font></div><div><font face="Source Code Pro">    protected final int hex;</font></div><div><font face="Source Code Pro">    Color(int h) {</font></div><div><font face="Source Code Pro">        this.hex = h;</font></div><div><font face="Source Code Pro">    }</font></div><div><font face="Source Code Pro">    public Color lighter() {</font></div><div><font face="Source Code Pro">        return new Color(hex + 0x111);</font></div><div><font face="Source Code Pro">    }</font></div><div><font face="Source Code Pro">}</font></div><div><br/></div><div>However, sometimes it's more desirable to pick the next lighter color through a set of available <a href="https://en.wikipedia.org/wiki/Pantone">Pantone</a> colors:</div><div><br/></div><div><font face="Source Code Pro">class PantoneColor extends Color {</font></div><div><font face="Source Code Pro">    private final PantoneName pantone;</font></div><div><font face="Source Code Pro">    PantoneColor(String name) {</font></div><div><font face="Source Code Pro">        this(new PantoneName(name));</font></div><div><font face="Source Code Pro">    }</font></div><div><font face="Source Code Pro">    PantoneColor(PantoneName name) {</font></div><div><font face="Source Code Pro">        this.pantone = name;</font></div><div><font face="Source Code Pro">    }</font></div><div><font face="Source Code Pro">    @Override</font></div><div><font face="Source Code Pro">    public Color lighter() {</font></div><div><font face="Source Code Pro">        return new PantoneColor(this.pantone.up());</font></div><div><font face="Source Code Pro">    }</font></div><div><font face="Source Code Pro">}</font></div><div><br/></div><div><br/></div><div><br/></div><div>Then, we create a static factory method, which will decide which Color implementation is the most suitable for us:</div><div><br/></div><div><font face="Source Code Pro">class Color {</font></div><div><font face="Source Code Pro">    private final String code;</font></div><div><font face="Source Code Pro">    static Color make(int h) {</font></div><div><font face="Source Code Pro">        if (h == 0xBF1932) {</font></div><div><font face="Source Code Pro">            return new PantoneColor(&quot;19-1664 TPX&quot;);</font></div><div><font face="Source Code Pro">        }</font></div><div><font face="Source Code Pro">        return new RGBColor(h);</font></div><div><font face="Source Code Pro">    }</font></div><div><font face="Source Code Pro">}</font></div><div><br/></div><div>If the <a href="https://www.pantone.com/color-finder/19-1664-TPX">true red</a> color is requested, we return an instance of PantoneColor. In all other cases it's just a standard RGBColor. The decision is made by the static factory method. This is how we will call it:</div><div><font style="font-family: &quot;Source Code Pro&quot;;">Color color = Color.make(0xBF1932);</font></div><div><br/></div><div>It would not be possible to do the same &quot;forking&quot; with a constructor, since it can only return the class it is declared in. A static method has all the necessary freedom to return any subtype of Color.</div><div>True. However, in an object-oriented world we can and must do it all differently. First, we would make Color an interface:</div><div><br/></div><div><font face="Source Code Pro">interface Color {</font></div><div><font face="Source Code Pro">    Color lighter();</font></div><div><font face="Source Code Pro">}</font></div><div><br/></div><div>Next, we would move this decision making process to its own class Colors, just like we did in the previous example:</div><div><br/></div><div><font face="Source Code Pro">class Colors {</font></div><div><font face="Source Code Pro">    Color make(int h) {</font></div><div><font face="Source Code Pro">        if (h == 0xBF1932) {</font></div><div><font face="Source Code Pro">            return new PantoneColor(&quot;19-1664-TPX&quot;);</font></div><div><font face="Source Code Pro">        }</font></div><div><font face="Source Code Pro">        return new RGBColor(h);</font></div><div><font face="Source Code Pro">    }</font></div><div><font face="Source Code Pro">}</font></div><div><br/></div><div>And we would use an instance of class Colors instead of a static faсtory method inside Color:</div><div><font style="font-family: &quot;Source Code Pro&quot;;">colors.make(0xBF1932);</font></div><div><br/></div><div>However, this is still not really an object-oriented way of thinking, because we're taking the decision-making away from the object it belongs to. Either through a static factory method make() or a new class Colors—it doesn't really matter how—we tear our objects into two pieces. The first piece is the object itself and the second one is the decision making algorithm that stays somewhere else.</div><div>A much more object-oriented design would be to put the logic into an object of class PantoneColor which would decorate the original RGBColor:</div><div><br/></div><div><font face="Source Code Pro">class PantoneColor {</font></div><div><font face="Source Code Pro">    private final Color origin;</font></div><div><font face="Source Code Pro">    PantoneColor(Color color) {</font></div><div><font face="Source Code Pro">        this.origin = color;</font></div><div><font face="Source Code Pro">    }</font></div><div><font face="Source Code Pro">    @Override</font></div><div><font face="Source Code Pro">    public Color lighter() {</font></div><div><font face="Source Code Pro">        final Color next;</font></div><div><font face="Source Code Pro">        if (this.origin.hex() == 0xBF1932) {</font></div><div><font face="Source Code Pro">            next = new RGBColor(0xD12631);</font></div><div><font face="Source Code Pro">        } else {</font></div><div><font face="Source Code Pro">            next = this.origin.lighter();</font></div><div><font face="Source Code Pro">        }</font></div><div><font face="Source Code Pro">        return new PantoneColor(next);</font></div><div><font face="Source Code Pro">    }</font></div><div><font face="Source Code Pro">)</font></div><div><br/></div><div>Then, we make an instance of RGBColor and decorate it with PantoneColor:</div><div><font face="Source Code Pro">Color red = new PantoneColor(</font></div><div><font face="Source Code Pro">    new RGBColor(0xBF1932)</font></div><div><font face="Source Code Pro">);</font></div><div><br/></div><div>We ask red to return a lighter color and it returns the one from the Pantone palette, not the one that is merely lighter in RGB coordinates:</div><div><font style="font-family: &quot;Source Code Pro&quot;;">Color lighter = red.lighter(); // 0xD12631</font></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="width: 1236px; padding: 8px; border: 1px solid;"><div>why the fact that static factories are advantageous because they can cache can be false ?</div></td></tr><tr><td style="width: 1236px; padding: 8px; border: 1px solid;"><div>Let's say I need a red tomato color in multiple places in the application:</div><div><font face="Source Code Pro">Color tomato = new Color(255, 99, 71);</font></div><div><font face="Source Code Pro">// ... sometime later</font></div><div><font face="Source Code Pro">Color red = new Color(255, 99, 71);</font></div><div><br/></div><div>Two objects will be created, which is obviously inefficient, since they are identical. It would be better to keep the first instance somewhere in memory and return it when the second call arrives. Static factory methods make it possible to solve this very problem:</div><div><br/></div><div><font face="Source Code Pro">Color tomato = Color.makeFromPalette(255, 99, 71);</font></div><div><font face="Source Code Pro">// ... sometime later</font></div><div><font face="Source Code Pro">Color red = Color.makeFromPalette(255, 99, 71);</font></div><div><br/></div><div>Then somewhere inside the Color we keep a private static Map with all the objects already instantiated:</div><div><font face="Source Code Pro">class Color {</font></div><div><font face="Source Code Pro">    private static final Map &lt; Integer, Color &gt; CACHE =</font></div><div><font face="Source Code Pro">        new HashMap &lt; &gt; ();</font></div><div><font face="Source Code Pro">    private final int hex;</font></div><div><font face="Source Code Pro">    static Color makeFromPalette(int red, int green, int blue) {</font></div><div><font face="Source Code Pro">        final int hex = red &lt;&lt; 16 + green &lt;&lt; 8 + blue;</font></div><div><font face="Source Code Pro">        return Color.CACHE.computeIfAbsent(</font></div><div><font face="Source Code Pro">            hex, h - &gt; new Color(h)</font></div><div><font face="Source Code Pro">        );</font></div><div><font face="Source Code Pro">    }</font></div><div><font face="Source Code Pro">    private Color(int h) {</font></div><div><font face="Source Code Pro">        return new Color(h);</font></div><div><font face="Source Code Pro">    }</font></div><div><font face="Source Code Pro">}</font></div><div><br/></div><div>It is very effective performance-wise. With a small object like our Color the problem may not be so obvious, but when objects are bigger, their instantiation and garbage collection may waste a lot of time.</div><div>True. However, there is an object-oriented way to solve this problem. We just introduce a new class Palette, which becomes a store of colors:</div><div><br/></div><div><font face="Source Code Pro">class Palette {</font></div><div><font face="Source Code Pro">    private final Map &lt; Integer, Color &gt; colors =</font></div><div><font face="Source Code Pro">        new HashMap &lt; &gt; ();</font></div><div><font face="Source Code Pro">    Color take(int red, int green, int blue) {</font></div><div><font face="Source Code Pro">        final int hex = red &lt;&lt; 16 + green &lt;&lt; 8 + blue;</font></div><div><font face="Source Code Pro">        return this.computerIfAbsent(</font></div><div><font face="Source Code Pro">            hex, h - &gt; new Color(h)</font></div><div><font face="Source Code Pro">        );</font></div><div><font face="Source Code Pro">    }</font></div><div><font face="Source Code Pro">}</font></div><div><br/></div><div>Now, we make an instance of Palette once and ask it to return a color to us every time we need it:</div><div><font face="Source Code Pro">Color tomato = palette.take(255, 99, 71);</font></div><div><font face="Source Code Pro">// Later we will get the same instance:</font></div><div><font face="Source Code Pro">Color red = palette.take(255, 99, 71);</font></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="width: 1236px; padding: 8px; border: 1px solid;"><div>can you explain the purpose of the service locator pattern ?</div></td></tr><tr><td style="width: 1236px; padding: 8px; border: 1px solid;"><div><span style="font-weight: bold;">The purpose of the Service Locator pattern is to return the service instances on demand.</span> This is useful for decoupling service consumers from concrete classes.</div><div>An implementation will consist of the following components:</div><ul><li><div>Client – the client object is a service consumer. It's responsible for invoking the request from the service locator<br/></div></li><li><div>Service Locator – is a communication entry point for returning the services from the cache<br/></div></li><li><div>Cache – an object for storing service references to reuse them later<br/></div></li><li><div>Initializer – creates and registers references to services in the cache<br/></div></li></ul><ul><li><div>Service – the Service component represents the original services or their implementation</div></li></ul><div><br/></div><div>The original service object is looked up by the locator and returned on demand.</div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="width: 1236px; padding: 8px; border: 1px solid;"><div>can you show an implementation of the service locator pattern ?</div></td></tr><tr><td style="width: 1236px; padding: 8px; border: 1px solid;"><div>First, we'll create a <span style="font-style: italic;">MessagingService</span> interface for sending messages in different ways:</div><div><font face="Source Code Pro">public interface MessagingService {</font></div><div><font face="Source Code Pro">    String getMessageBody();</font></div><div><font face="Source Code Pro">    String getServiceName();</font></div><div><font face="Source Code Pro">}</font></div><div><br/></div><div>Next, we'll define two implementations of the interface above, that send messages through email and SMS:</div><div><font face="Source Code Pro">public class EmailService implements MessagingService {</font></div><div><font face="Source Code Pro">    public String getMessageBody() {</font></div><div><font face="Source Code Pro">        return &quot;email message&quot;;</font></div><div><font face="Source Code Pro">    }</font></div><div><font face="Source Code Pro">    public String getServiceName() {</font></div><div><font face="Source Code Pro">        return &quot;EmailService&quot;;</font></div><div><font face="Source Code Pro">    }</font></div><div><font face="Source Code Pro">}</font></div><div><font face="Source Code Pro"><br/></font></div><div>The <span style="font-style: italic;">SMSService</span> class definition is similar to the <span style="font-style: italic;">EmailService</span> class.</div><div><br/></div><div>After defining the two services, we have to define the logic to initialize them:</div><div><font face="Source Code Pro">public class InitialContext {</font></div><div><font face="Source Code Pro">    public Object lookup(String serviceName) {</font></div><div><font face="Source Code Pro">        if (serviceName.equalsIgnoreCase(&quot;EmailService&quot;)) {</font></div><div><font face="Source Code Pro">            return new EmailService();</font></div><div><font face="Source Code Pro">        } else if (serviceName.equalsIgnoreCase(&quot;SMSService&quot;)) {</font></div><div><font face="Source Code Pro">            return new SMSService();</font></div><div><font face="Source Code Pro">        }</font></div><div><font face="Source Code Pro">        return null;</font></div><div><font face="Source Code Pro">    }</font></div><div><font face="Source Code Pro">}</font></div><div><font face="Source Code Pro"><br/></font></div><div>The last component we need before putting the service locator object together is the cache.</div><div>In our example, this is a simple class with a <span style="font-style: italic;">List</span> property:</div><div><font face="Source Code Pro">public class Cache {</font></div><div><font face="Source Code Pro">    private List&lt;MessagingService&gt; services = new ArrayList&lt;&gt;();</font></div><div><font face="Source Code Pro">    public MessagingService getService(String serviceName) {</font></div><div><font face="Source Code Pro">        // retrieve from the list</font></div><div><font face="Source Code Pro">    }</font></div><div><font face="Source Code Pro">    public void addService(MessagingService newService) {</font></div><div><font face="Source Code Pro">        // add to the list</font></div><div><font face="Source Code Pro">    }</font></div><div><font face="Source Code Pro">}</font></div><div><font face="Source Code Pro"><br/></font></div><div>Finally, we can implement our service locator class:</div><div><font face="Source Code Pro">public class ServiceLocator {</font></div><div><font face="Source Code Pro">    private static Cache cache = new Cache();</font></div><div><font face="Source Code Pro">    public static MessagingService getService(String serviceName) {</font></div><div><font face="Source Code Pro">        MessagingService service = cache.getService(serviceName);</font></div><div><font face="Source Code Pro">        if (service != null) {</font></div><div><font face="Source Code Pro">            return service;</font></div><div><font face="Source Code Pro">        }</font></div><div><font face="Source Code Pro">        InitialContext context = new InitialContext();</font></div><div><font face="Source Code Pro">        MessagingService service1 = (MessagingService) context</font></div><div><font face="Source Code Pro">          .lookup(serviceName);</font></div><div><font face="Source Code Pro">        cache.addService(service1);</font></div><div><font face="Source Code Pro">        return service1;</font></div><div><font face="Source Code Pro">    }</font></div><div><font face="Source Code Pro">}</font></div><div><font face="Source Code Pro"><br/></font></div><div>The logic here is fairly simple. The class holds an instance of the <span style="font-style: italic;">Cache.</span> Then, in the <span style="font-style: italic;">getService()</span> method, it will first check the cache for an instance of the service. Then, if that's <span style="font-style: italic;">null,</span> it will call the initializing logic and add the new object to the cache.</div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="width: 1236px; padding: 8px; border: 1px solid;"><div>what are the differences between dependency injectoin and the service locator pattern ?</div></td></tr><tr><td style="width: 1236px; padding: 8px; border: 1px solid;"><div>At first glance, the Service Locator pattern may look similar to another well-known pattern – namely, Dependency Injection.</div><div>First, it's important to note that <span style="font-weight: bold;">both Dependency Injection and the Service Locator pattern are implementations of the Inversion of Control concept</span>.</div><div><span style="font-weight: bold;">The key difference here is that the client object still creates its dependencies</span>. It just uses the locator for that, meaning it needs a reference to the locator object.</div><div>By comparison, when using the dependency injection, the class is given the dependencies. The injector is called only once at startup to inject dependencies into the class.</div><div><br/></div><div><br/></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div>when we should avoid the use of the service locator ?</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div>Finally, let's consider a few reasons to avoid using the Service Locator pattern. </div><div>One argument against it is that it makes unit testing difficult. With dependency injection, we can pass mock objects of the dependent class to the tested instance. On the other hand, this is a bottleneck with the Service Locator pattern. Another issue is that it's trickier to use APIs based on this pattern. The reason for this is that the dependencies are hidden inside the class and they're only verified at runtime.</div><div>Despite all of this, the Service Locator pattern is easy to code and understand, and can be a great choice for small applications.</div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="width: 1236px; padding: 8px; border: 1px solid;"><div>how can you implement  decorator pattern with streams in java 8 ?</div></td></tr><tr><td style="width: 1236px; padding: 8px; border: 1px solid;"><div><img src="New cards design pattern_files/Image.png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><div><br/></div><div>To use all the power of Java 8 I recommend to add a special interface for all decorators, the DecoratingComponent. The abstract superclass for decorators implements that interface but, as before, only holds a reference to Component.</div><div>It is important to notice that due to the definition of the new interface (see below) nothing changes for the concrete decorators. They are exactly identical in both realizations of the pattern. The abstract class also undergoes virtually no change (see further below) so switching to this solution has no noticeable costs.</div><div style="text-align:start;"></div><div><br/></div><div>The new interface DecoratingComponent extends the basic component interface and provides factory methods for decorators. These are static or <a href="http://blog.codefx.org/java/everything-about-default-methods/">default/defender methods</a> (so they are already implemented <a href="http://stackoverflow.com/a/23476994">and would be final if they could be</a>) and no abstract methods should be declared. This way, the new interface does not add an extra burden on the implementations further down the inheritance tree.</div><div style="text-align:start;"></div><div>To quickly move from a Component to a DecoratingComponent, the interface should have a static method which takes the first and returns the latter. Since DecoratingComponent extends Component and adds no abstract methods, this is trivial. Simply create an anonymous implementation and forward all calls to the adapted component.</div><div><br/></div><div>The general approach would look like this:</div><div><font face="Source Code Pro">static DecoratingComponent from(Component component) {</font></div><div><font style="font-family: &quot;Source Code Pro&quot;;">  DecoratingComponent adapted = new DecoratingComponent() {</font></div><div><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><font face="Source Code Pro">@Override</font></div><div><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><font face="Source Code Pro">public SomeReturn someMethod(SomeArgument argument) {</font></div><div><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><font face="Source Code Pro">return component.someMethod(argument);</font></div><div><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><font face="Source Code Pro">}</font></div><div><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><font face="Source Code Pro">// ... more methods here ...</font></div><div><font face="Source Code Pro">  };</font></div><div><font face="Source Code Pro">return adapted;</font></div><div><font face="Source Code Pro">}</font></div><div><br/></div><div><br/></div><div>In case of the DecoratingHyperlinkListener it is much easier because it’s a functional interface so a lambda expression can be used:</div><div><font face="Source Code Pro">static DecoratingHyperlinkListener from(HyperlinkListener listener) {</font></div><div><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><font face="Source Code Pro">return event -&gt; listener.hyperlinkUpdate(event);</font></div><div><font face="Source Code Pro">}</font></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Generic Decoration. </span>This is the essential method of the interface:</div><div><font face="Source Code Pro">default DecoratingComponent decorate(</font></div><div><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><font face="Source Code Pro">Function&lt;? super DecoratingComponent, ? extends DecoratingComponent&gt;</font></div><div><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><font face="Source Code Pro">decorator) {</font></div><div><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><font face="Source Code Pro">return decorator.apply(this);</font></div><div><font face="Source Code Pro">}</font></div><div><br/></div><div><br/></div><div>It takes a function from one decorating component to another as an argument. It applies the function to itself to create a decorated instance, which is then returned.</div><div>This method can be used throughout the whole code to decorate any component in a simple and readable way:</div><div><font face="Source Code Pro">Component some = ...;</font></div><div><font face="Source Code Pro">DecoratingComponent decorated = DecoratingComponent</font></div><div><font face="Source Code Pro">// create an instance of 'DecoratingComponent' from the 'Component'</font></div><div><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><font face="Source Code Pro">.from(some)</font></div><div><font face="Source Code Pro">// now decorate it</font></div><div><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><font face="Source Code Pro">.decorate(component -&gt; new MyCoolComponentDecorator(component, ...));</font></div><div><font face="Source Code Pro"><br/></font></div><div><font face="Source Code Pro">// if you already have an instance of 'DecoratingComponent', it get's easier</font></div><div><font face="Source Code Pro">decorated = decorated</font></div><div><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><font face="Source Code Pro">.decorate(component -&gt; new MyBestComponentDecorator(component, ...));</font></div><div><font face="Source Code Pro"><br/></font></div><div><font face="Source Code Pro">// constructor references are even clearer (but cannot always be used)</font></div><div><font face="Source Code Pro">decorated = decorated.decorate(MyBestComponentDecorator::new);</font></div><div><font face="Source Code Pro"><br/></font></div><div style="text-align:start;"></div><div><span style="font-weight: bold;">Concrete Decorations</span></div><div>You can also add methods to decorate instances with concrete decorators:</div><div><font face="Source Code Pro">default DecoratingHyperlinkListener logEvents() {</font></div><div><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><font face="Source Code Pro">return LogEventsToConsole.decorate(this);</font></div><div><font face="Source Code Pro">}</font></div><div><font face="Source Code Pro">default DecoratingHyperlinkListener onHoverMakeVisible(JComponent component) {</font></div><div><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><span style="font-family: &quot;Source Code Pro&quot;;"> </span><font face="Source Code Pro">return OnHoverMakeComponentVisible.decorate(this, component);</font></div><div><font face="Source Code Pro">}</font></div><div><br/></div><div>They make decorating very succinct and readable:</div><div><font face="Source Code Pro">DecoratingComponent decorated = ...</font></div><div><font face="Source Code Pro">decorated = decorated.logEvents();</font></div><div><br/></div><div><br/></div><div>But it is debatable whether these methods should really be added. While they are very convenient, a strong argument can be made against them as they create a circular dependency. Not only do the decorators know about the interface (which they implement indirectly via the abstract superclass), now the interface also knows its implementations. In general this is a pungent code smell.</div><div><br/></div><div>The final call is not yet in on this but I recommend a pragmatic middle way. I let the interface know about the implementations which live in the same package. This will be the generic ones as they do not reference anything too concrete from the rest of my code. But I would not let it know about every crazy decorator I created deep in the bowels of the system. (And of course I would neither add all those decorators to the same package unless it’s already called <span style="font-style: italic;">the_kraken</span>…)</div><div><br/></div><div>Worse though, all decorators would have to expose the fact that they are an AbstractDecorator. Suddenly there is an abstract class, which was only created to ease the implementation, creeping through the whole code base.</div><div><br/></div><div><br/></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="width: 1236px; padding: 8px; border: 1px solid;"><div>why in the decorated stream design you putted an extra interface ?</div></td></tr><tr><td style="width: 1236px; padding: 8px; border: 1px solid;"><div>Yes, yes, all those Java 8 features are very nice but couldn’t you simply add these methods to AbstractDecorator? Good question!</div><div>Of course, I could’ve just added them there. But I don’t like that solution for two reasons.</div><div><br/></div><ol><li><div><span style="font-weight: bold;">Single Responsibility Principle. </span>First, that would blur the responsibilities of the classes. The new interface is responsible for decorating instances of Component, the abstract superclass is responsible for enabling easy implementation of decorators. These are not the same things and they do not change for the same reason. The new interface might change whenever a new decorator has to be included. The abstract class will change whenever Component changes.</div></li></ol><div><br/></div><ol start="2"><li><div><span style="font-weight: bold;">Type Hierarchy. </span>If these methods were added to AbstractDecorator, they could only be called on such instances. So all decorators would have to inherit from that class, which limits the range for future implementations. Who knows, maybe some really good reason comes up, why another class can not be an AbstractDecorator.</div></li></ol></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="width: 1236px; padding: 8px; border: 1px solid;"><div>what are the consideration you need to take care when implementing the decorator pattern with the extra interface ?</div></td></tr><tr><td style="width: 1236px; padding: 8px; border: 1px solid;"><div><span style="font-weight: bold;">Changes To The Abstract Decorator Class. </span>If you have access to the class, you should let it implement DecoratingComponent instead of Component. As no new abstract methods were introduced this entails no further changes. This is shown in the UML diagram above. If you can not change the class, your decorators will only implement Component. This will keep you from using their constructors to create a function which maps a component to a decorating component. As you need that function as an argument for the decorate method, you have to change that method to look as follows:</div><div><br/></div><div><font face="Source Code Pro">// note the more general second type of the 'Function' interface</font></div><div><font face="Source Code Pro">default DecoratingComponent decorate(</font></div><div><font face="Source Code Pro">Function&lt;? super DecoratingComponent, ? extends Component&gt; decorator) {</font></div><div><font face="Source Code Pro">// create the decorated instance as before</font></div><div><font face="Source Code Pro">Component decorated = decorator.apply(this);</font></div><div><font face="Source Code Pro">// since it is no 'DecoratingComponent' use 'from' to turn it into one</font></div><div><font face="Source Code Pro">return from(decorated);</font></div><div><font face="Source Code Pro">}</font></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Changes To The Decorators</span></div><div>No changes to those classes are necessary. Unless of course, you are one of those crazy people who use static factory methods. Than you would have to make sure that they declare their return type as DecoratingComponent or you’re in the same situation as when the abstract superclass can not implement the new interface. If you can not change the decorator classes, the same solution works here.</div><div><br/></div><div><span style="font-weight: bold;">Example</span></div><div>So let’s look at the snippet from above again:</div><div><span style="font-family: &quot;Source Code Pro&quot;;"><br/></span></div><div><font face="Source Code Pro">HyperlinkListener listener = this::changeHtmlViewBackgroundColor; </font><span style="font-family: &quot;Source Code Pro&quot;;">// create a 'HyperlinkListener' with a method reference</span></div><div><font face="Source Code Pro"><br/></font></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><br/></span></div><div><font face="Source Code Pro">listener = DecoratingHyperlinkListener </font><span style="font-family: &quot;Source Code Pro&quot;;">// decorate that instance with different behaviors </span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">// (</span><span style="font-family: &quot;Source Code Pro&quot;;">note that each call actually returns a new instance</span><span style="font-family: &quot;Source Code Pro&quot;;"> so the result has to be assigned to a variable)</span></div><div><font face="Source Code Pro">     .from(listener) </font><span style="font-family: &quot;Source Code Pro&quot;;">// adapt the 'HyperlinkListener' to be a 'DecoratingHyperlinkListener'</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;">                     // (looks better if it is not on its own line)</span></div><div><font face="Source Code Pro">     .onHoverMakeVisible(urlLabel) </font><span style="font-family: &quot;Source Code Pro&quot;;">// call some concrete decorator functions</span></div><div><font face="Source Code Pro">     .onHoverSetUrlOn(urlLabel)</font></div><div><font face="Source Code Pro">     .logEvents()</font></div><div><font face="Source Code Pro">     .decorate(l -&gt; new OnActivateHighlightComponent(l, urlLabel)) </font><span style="font-family: &quot;Source Code Pro&quot;;">// call the generic decorator function with a lambda expression</span></div><div><span style="font-family: &quot;Source Code Pro&quot;;"><br/></span></div><div><font face="Source Code Pro">.decorate(OnEnterLogUrl::new); </font><span style="font-family: &quot;Source Code Pro&quot;;">// call the generic decorator function with a constructor reference</span></div></td></tr><tr><td style="width: 1236px; padding: 8px; border: 1px solid;"><div><br/></div></td></tr></tbody></table><div><br/></div></div><div><br/></div></span>
</div></body></html> 