1_ Which answer choice can replace line 6 so the code continues to produce the same output?
3: List<String> rug = new ArrayList<>();
4: rug.add("circle");
5: rug.add("square");
6: System.out.println(rug);
A. System.out.println(rug.asString);
B. System.out.println(rug.asString());
C. System.out.println(rug.toString);
D. System.out.println(rug.toString());
|
2_ Which best describes this code?
class Stats {
private int data;
public int getData() {
return data;
}
public void setData(int data) {
this.data = data;
}
}
A. It is a singleton.
B. It is well encapsulated.
C. It is immutable.
D. It is both well encapsulated and immutable.
|
3_ What design pattern or principle ensures that there will be no more than one instance of a
class?
A. Encapsulation
B. Immutability
C. Singleton
D. Static
|
4_ What is the output of this code?
class Laptop extends Computer {
public void startup() {
System.out.print("laptop-");
}
}
public class Computer {

public void startup() {
System.out.print("computer-");
}
public static void main(String[] args) {
Computer computer = new Laptop();
Laptop laptop = new Laptop();
computer.startup();
laptop.startup();
}
}
A. computer-laptop-
B. laptop-computer-
C. laptop-laptop-
D. None of the above
|
5_ Which method can be correctly inserted into this class to meet the contract of the
equals() method? You may assume that text is not null.
class Button {
private String text;
public int hashCode() {
return text.hashCode();
}
}
A.
public boolean equals(Object o) {
if ( o == null ) return true;
if (! (o instanceof Button)) return false;
return text.equals(o.text);
}
B.
public boolean equals(Object o) {
if ( o == null ) return true;
Button b = (Button) o;
return text.equals(b.text);
}

C.
public boolean equals(Object o) {
if (! (o instanceof Button)) return false;
return text.equals(o.text);
}
D.
public boolean equals(Object o) {
if (! (o instanceof Button)) return false;
Button b = (Button) o;
return text.equals(b.text);
}
|
6_ Fill in the blanks: means the state of an object cannot be changed while
means that it can.
A. Immutability, mutability
B. Rigidity, flexibility
C. Static, instance
D. None of the above
|
7_ Which is the first line to fail to compile?
class Tool {
void use() { } // r1
}
class Hammer extends Tool {
private void use() { } // r2
public void bang() { } // r3
}
A. r1
B. r2
C. r3
D. None of the above
|
8_ Which of these classes properly implement(s) the singleton pattern?
class ExamAnswers {
private static ExamAnswers instance = new ExamAnswers();
private List<String> answers = new ArrayList<>();

public static List<String> getAnswers() {
return instance.answers;
}
}
class TestAnswers {
private static TestAnswers instance = new TestAnswers();
private List<String> answers = new ArrayList<>();
public static TestAnswers getTestAnswers() {
return instance;
}
public List<String> getAnswers() {
return answers;
}
}
A. ExamAnswers
B. TestAnswers
C. Both classes
D. Neither class
|
9_ What does the following print?
public class Transport {
static interface Vehicle {}
static class Bus implements Vehicle {}
public static void main(String[] args) {
Bus bus = new Bus();
boolean n = null instanceof Bus;
boolean v = bus instanceof Vehicle;
boolean b = bus instanceof Bus;
System.out.println(n + " " + v + " " + b);
}
}
A. true true true
B. false true true
C. false false false
D. None of the above

|
10_ What technique allows multiple variables from the same class to be shared across all
instances of a class?
A. Encapsulation
B. Immutability
C. Singleton
D. Static
|
11_ Which is not a requirement for a class to be immutable?
A. A private constructor is provided.
B. Any instance variables are private.
C. Methods cannot be overridden.
D. There are no setter methods.
|
12_ Which statement is true about encapsulation while providing the broadest access allowed?
A. Variables are public and methods are private.
B. Variables are public and methods are public.
C. Variables are private and methods are public.
D. Variables are private and methods are private.
|
13_ What does the following print?
class Laptop extends Computer {
String type = "laptop";
}
public class Computer {
String type = "computer";
public static void main(String[] args) {
Computer computer = new Laptop();
Laptop laptop = new Laptop();
System.out.print(computer.type + "," + laptop.type);
}
}
A. computer,laptop
B. laptop,computer
C. laptop,laptop
D. None of the above
|
14_ Which of these classes is/are immutable?
public final class Flower {
private final String name;
private final List<Integer> counts;
public Flower(String name, List<Integer> counts) {

this.name = name;
this.counts = counts;
}
public String getName() {
return name;
}
public List<Integer> getCounts() {
return counts;
}
}
public final class Plant {
private final String name;
private final List<Integer> counts;
public Plant(String name, List<Integer> counts) {
this.name = name;
this.counts = new ArrayList<>(counts);
}
public String getName() {
return name;
}
public List<Integer> getCounts() {
return new ArrayList<>(counts);
}
}
A. Flower
B. Plant
C. Both classes
D. Neither class
|
15_ Which methods compile?
private static int numShovels;
private int numRakes;
public int getNumShovels() {
return numShovels;
}
public int getNumRakes() {
return numRakes;
}

A. Just getNumRakes()
B. Just getNumShovels()
C. Both methods
D. Neither method
|
16_ Which methods compile?
private static int numShovels;
private int numRakes;
public static int getNumShovels() {
return numShovels;
}
public static int getNumRakes() {
return numRakes;
}
A. Just getNumRakes()
B. Just getNumShovels()
C. Both methods
D. Neither method
|
17_ How many lines of the main method fail to compile?
11: static interface Vehicle {}
12: static class Bus implements Vehicle {}
13:
14: public static void main(String[] args) {
15: Bus bus = new Bus();
16:
17: System.out.println(null instanceof Bus);
18: System.out.println(bus instanceof Vehicle);
19: System.out.println(bus instanceof Bus);
20: System.out.println(bus instanceof ArrayList);
21: System.out.println(bus instanceof Collection);
22: }
A. One
B. Two
C. Three
D. Four

|
18_ Which variable declaration is the first line not to compile?
class Building {}
class House extends Building{}
public void convert() {
Building b = new Building();
House h = new House();
Building bh = new House();
Building p = (House) b;
House q = (Building) h;
Building r = (Building) bh;
House s = (House) bh;
}
A. p
B. q
C. r
D. s
|
19_ Which statement is true about the code that can fill in the blank?
class Sticker {
public int hashCode() {
return 1;
}
public boolean equals(Object o) {
return ;
}
}
A. It must return false.
B. It must return true.
C. It can return either true or false.
D. None of the above.
|
20_ What change is needed to make Secret well encapsulated?
import java.util.*;
public class Secret {
private int number = new Random().nextInt(10);
public boolean guess(int candidate) {
return number == candidate;
}
}

A. Change number to use a public access modifier.
B. Declare a private constructor.
C. Remove the guess method.
D. None. It is already well encapsulated.
|
21_ Which of these classes best implement(s) the singleton pattern?
class ExamAnswers {
private static ExamAnswers instance = new ExamAnswers();
private List<String> answers = new ArrayList<>();
private ExamAnswers() {}
public ExamAnswers getExamAnswers() {
return instance;
}
public List<String> getAnswers() {
return answers;
}
}
class TestAnswers {
private static TestAnswers instance = new TestAnswers();
private List<String> answers = new ArrayList<>();
private TestAnswers() {}
public static TestAnswers getTestAnswers() {
return instance;
}
public List<String> getAnswers() {
return answers;
}
}
A. ExamAnswers
B. TestAnswers
C. Both classes
D. Neither class
|
22_ How many lines does the following code output?
public class Cars {
static {
System.out.println("static");
}
private static void drive() {

System.out.println("fast");
}
public static void main(String[] args) {
drive();
drive();
}
}
A. One
B. Two
C. Three
D. None of the above. The code does not compile.
|
23_ Which is not a true statement given this diagram?
com.light
Flashlight
• private replaceBulb()
• public turnOn()
Phone
• protected display()
• public charge()
com.dark
Blanket
• wash()
Tent
• private pitch()
• public goCamping()
A. Instance methods in the Blanket class can call the Flashlight class’s turnOn().
B. Instance methods in the Flashlight class can call the Flashlight class’s
replaceBulb().
C. Instance methods in the Phone class can call the Blanket class’s wash().
D. Instance methods in the Tent class can call the Tent class’s pitch().
|
24_ Given the diagram in the previous question, how many of the classes can call the
display() method?
A. One
B. Two
C. Three
D. Four
|
25_ What does the following print?
1: class SmartWatch extends Watch {
2: private String getType() { return "smart watch"; }
3: public String getName(String suffix) {

4: return getType() + suffix;
5: }
6: }
7: public class Watch {
8: private String getType() { return "watch"; }
9: public String getName(String suffix) {
10: return getType() + suffix;
11: }
12: public static void main(String[] args) {
13: Watch watch = new Watch();
14: SmartWatch smartWatch = new SmartWatch();
15: System.out.print(watch.getName(","));
16: System.out.print(smartWatch.getName(""));
17: }
18: }
A. smart watch,watch
B. watch,smart watch
C. watch,watch
D. None of the above
|
26_ What does the following print?
public class Transport {
static interface Vehicle {}
static class Bus implements Vehicle {}
static class Van extends Bus {}
public static void main(String[] args) {
Bus bus = new Van();
Van van = new Van();
Van[] vans = new Van[0];
boolean b = bus instanceof Vehicle;
boolean v = van instanceof Vehicle;
boolean a = vans instanceof Vehicle[];
System.out.println(b + " " + v + " " + a);
}
}

A. true true true
B. false true true
C. true false false
D. None of the above. The code does not compile
|
27_ Which of the following correctly fills in the blank so this code compiles and prints true?
public class Button {
private String text;
public int hashCode() {
return text.hashCode();
}
public boolean equals(Object o) {
if ( ) return false;
Button b = (Button) o;
return text.equals(b.text);
}
public static void main(String[] args) {
Button b1 = new Button();
Button b2 = new Button();
b1.text = "mickey";
b2.text = "mickey";
System.out.println(b1.equals(b2));
}
}
A. (o instanceof Button)
B. (o instanceOf Button)
C. !(o instanceof Button)
D. !(o instanceOf Button)
|
28_ Which is the first line to fail to compile?
class Tool {
void use() { } // r1
}
class Hammer extends Tool {
private void use(String s) { } // r2
public void bang() { } // r3
}

A. r1
B. r2
C. r3
D. None of the above
|
29_ What is lazy instantiation?
A. A technique that can be used in an immutable class to wait until the first use to create
the object
B. A technique that can be used in a singleton to wait until the first use to create the
object
C. A technique that can be used in an immutable class to save memory when creating the
object
D. A technique that can be used in a singleton to save memory when creating the object
|
30_ Which variable declaration is the first line not to compile?
30: class Building {}
31: class House extends Building{}
32:
33: public void convert() {
34: Building b = new Building();
35: House h = new House();
36: Building bh = new House();
37: House p = (House) b;
38: House q = (House) h;
39: House r = (House) bh;
40: }
A. p
B. q
C. r
D. None of the above
|
31_ Which statement about encapsulation is not true?
A. Encapsulation allows putting extra logic in the getter and setter methods.
B. Encapsulation can use immutable instance variables in the implementation.
C. Encapsulation causes two classes to be more tightly tied together.
D. Encapsulation makes it easier to change the instance variables in the future.
|
32_ Which of these classes is/are immutable?
public class Flower {
private final String name;

private final List<Integer> counts;
public Flower(String name, List<Integer> counts) {
this.name = name;
this.counts = new ArrayList<>(counts);
}
public final String getName() {
return name;
}
public final List<Integer> getCounts() {
return new ArrayList<>(counts);
}
}
public class Plant {
private final String name;
private final List<Integer> counts;
public Plant(String name, List<Integer> counts) {
this.name = name;
this.counts = new ArrayList<>(counts);
}
public String getName() {
return name;
}
public List<Integer> getCounts() {
return new ArrayList<>(counts);
}
}
A. Flower
B. Plant
C. Both classes
D. Neither class
|
33_ How many lines does the following code output?
public class Cars {
private static void drive() {
static {
System.out.println("static");
}
System.out.println("fast");

}
public static void main(String[] args) {
drive();
drive();
}
}
A. One
B. Two
C. Three
D. None of the above. The code does not compile.
|
34_ How many of the following pairs of values can fill in the blanks to comply with the
contract
of the hashCode() and equals() methods?
class Sticker {
public int hashCode() {
return ;
}
public boolean equals(Object o) {
return ;
}
}
I. 1, false
II. 1, true
III. new Random().nextInt(), false
IV. new Random().nextInt(), true
A. None
B. One
C. Two
D. Three
|
35_ How do you change the value of an instance variable in an immutable class?
A. Call the setter method.
B. Remove the final modifier and set the instance variable directly.
C. Use a method other than Option A or B.
D. You can’t.

|
36_ Which technique or pattern requires instance variables to implement?
A. Is-a
B. Object composition
C. Singleton
D. None of the above
|
37_ How many lines of output does the following generate?
public class HowMany {
static {
System.out.println("any");
}
{
System.out.println("more");
}
public static void main(String[] args) {
new HowMany();
new HowMany();
}
}
A. Two
B. Three
C. Four
D. None of the above. The code does not compile.
|
38_ Which is the first line to fail to compile?
class Tool {
default void use() { } // r1
}
class Hammer extends Tool {
public void use() { } // r2
public void bang() { } // r3
}
A. r1
B. r2
C. r3
D. None of the above

|
39_ Which variable declaration is the first line to throw a ClassCastException at runtime?
class Building {}
class House extends Building{}
public void convert() {
Building b = new Building();
House h = new House();
Building bh = new House();
House p = (House) b;
House q = (House) h;
House r = (House) bh;
}
A. p
B. q
C. r
D. None of the above
|
40_ Which of the following values can fill in the blank for the class to be correctly
implemented?
class Sticker {
public int hashCode(Object o) {
return ;
}
public boolean equals(Object o) {
return true;
}
}
I. -1
II. 5
III. new Random().nextInt()
A. I
B. I and II
C. I, II, and III
D. I and III

|
1_ Which of the following is required for all valid lambda expressions?
A. ()
B. ->
C. {}
D. Parameter data type(s)
|
2_ What is the output of the following application?
package holiday;
enum DaysOff {
Thanksgiving, PresidentsDay, ValentinesDay
}
public class Vacation {
public static void main(String... unused) {
final DaysOff input = DaysOff.Thanksgiving;
switch(input) {
default:
case DaysOff.ValentinesDay:
System.out.print("1");
case DaysOff.PresidentsDay:
System.out.print("2");
}
}
}
A. 1
B. 2
C. 12
D. None of the above
|
3_ Fill in the blanks: A functional interface must contain or inherit and may
optionally include .
A. at least one abstract method, the @Override annotation
B. exactly one method, static methods
C. exactly one abstract method, the @FunctionalInterface annotation
D. at least one static method, at most one default method
|
4_ Which of the following class types cannot be marked final or abstract?
A. Static nested class
B. Local inner class
C. Anonymous inner class
D. Member inner class

|
5_ Which of the following is a valid lambda expression?
A. r -> {return 1==2}
B. (q) -> true
C. (x,y) -> {int test; return test>0;}
D. a,b -> true
|
6_ Which of the following properties of an enum can be marked abstract?
A. The enum class definition
B. An enum method
C. An enum value
D. None of the above
|
7_ What is the output of the following application?
package world;
public class Matrix {
private int level = 1;
class Deep {
private int level = 2;
class Deeper {
private int level = 5;
public void printReality() {
System.out.print(level);
System.out.print(" "+Matrix.Deep.this.level);
System.out.print(" "+Deep.this.level);
}
}
}
public static void main(String[] bots) {
Matrix.Deep.Deeper simulation = new Matrix().new Deep().new Deeper();
simulation.printReality();
}
}
A. 1 1 2
B. 5 2 2
C. 5 2 1
D. The code does not compile.

|
8_ A local inner class can access which type of local variables?
I. final
II. private
III. effectively final
A. I only
B. I and II
C. III only
D. I and III
|
9_ What is the output of the following application?
package finance;
enum Currency {
DOLLAR, YEN, EURO
}
abstract class Provider {
protected Currency c = Currency.EURO;
}
public class Bank extends Provider {
protected Currency c = Currency.DOLLAR;
public static void main(String[] pennies) {
int value = 0;
switch(new Bank().c) {
case 0:
value--; break;
case 1:
value++; break;
}
System.out.print(value);
}
}
A. 0
B. 1
C. The code does not compile.
D. The code compiles but throws an exception at runtime.

|
10_ What statement best describes the notion of effectively final in Java?
A. A local variable that is marked final
B. A static variable that is marked final
C. A local variable that is not marked final but whose primitive value or object reference
does not change after it is initialized
D. A local variable that is not marked final but whose primitive value or object reference
does not change after a certain point in the method
|
11_ What is the output of the following application?
package race;
interface Drive {
int SPEED = 5;
default int getSpeed() { return SPEED; }
}
interface Hover {
int MAX_SPEED = 5;
default int getSpeed() { return MAX_SPEED; }
}
public class Car implements Drive, Hover {
public static void main(String[] gears) {
class RaceCar extends Car {
@Override public int getSpeed() { return 10; }
};
System.out.print(new RaceCar().getSpeed());
}
}
A. 5
B. 10
C. The code does not compile due to the definition of Racecar.
D. The code does not compile for some other reason.
|
12_ Fill in the blanks: It is possible to extend an but not an
.
A. interface, abstract class
B. abstract class, enum
C. enum, interface
D. abstract class, interface

|
13_ Which of the following results is not a possible output of this program?
package sea;
enum Direction { NORTH, SOUTH, EAST, WEST; };
public class Ship {
public static void main(String[] compass) {
System.out.print(Direction.valueOf(compass[0]));
}
}
A. WEST is printed.
B. south is printed.
C. An ArrayIndexOutOfBoundsException is thrown at runtime.
D. An IllegalArgumentException is thrown at runtime.
|
14_ Which of the following is not an advantage of using enumerated types in Java?
A. Ensure consistency of data across an application.
B. Offer ability to create new enumerated values at runtime.
C. Provide access to fixed constants whose value does not change during the course of the
application.
D. Support cases where a value can only take one of a limited number of options.
|
15_ Given the following enum declaration, how many lines contain compilation errors?
package rainbow;
enum Light {}
public enum Color extends Light {
RED, BLUE, ORANGE, GREEN
protected Color() {}
}
A. None, the code compiles as is.
B. One
C. Two
D. Three
|
16_ Which of the following cannot include a static method in its definition?
A. Abstract class
B. Static nested class
C. Interface
D. Local inner class

|
17_ What is the output of the following application?
package ai;
interface Pump {
void pump(double psi);
}
interface Bend extends Pump {
void bend(double tensileStrength);
}
public class Robot {
public static final void apply(Bend instruction, double input) { // r1
instruction.bend(input);
}
public static void main(String... future) {
final Robot r = new Robot();
r.apply(x -> System.out.print(x+" bent!"), 5);
}
}
A. 5.0 bent!
B. The code does not compile because Bend is not a functional interface.
C. The code does not compile because of line r1.
D. None of the above.
|
18_ What is the best reason for applying the @Override annotation to a method?
A. It is required to implement an interface method.
B. It is required to override a method.
C. The method will fail to compile if it is not actually overriding another method.
D. There are no good reasons other than as a form of documentation.
|
19_ What is the output of the following application?
package space;
public class Bottle {
public static class Ship {
private enum Sail { // w1
TALL {protected int getHeight() {return 100;}},
SHORT {protected int getHeight() {return 2;}};
protected abstract int getHeight();
}
public Sail getSail() {

return Sail.TALL;
}
}
public static void main(String[] stars) {
Bottle bottle = new Bottle();
Ship q = bottle.new Ship(); // w2
System.out.print(q.getSail());
}
}
A. TALL
B. The code does not compile because of line w1.
C. The code does not compile because of line w2.
D. The code compiles but the application does not produce any output at runtime.
|
20_ Which of the following is not a valid lambda expression?
A. (Integer j, k) -> 5
B. (p,q) -> p+q
C. (Integer x, Integer y) -> x*y
D. (left,right) -> {return "null";}
|
21_ What is the output of the following application?
1: package fruit;
2:
3: interface Edible { void eat(); }
4: public class ApplePicking {
5: public static void main(String[] food) {
6: Edible apple = new Edible() {
7: @Override
8: void eat() {
9: System.out.print("Yummy!");
10: }
11: }
12: }
13: }
A. The application completes without printing anything.
B. Yummy!
C. One line of this application fails to compile.
D. Two lines of this application fail to compile.

|
22_ What is the output of the following application?
package forest;
public class Woods {
static class Tree {}
public static void main(String[] leaves) {
int water = 10+5;
final class Oak extends Tree { // p1
public int getWater() {
return water; // p2
}
}
System.out.print(new Oak().getWater());
}
}
A. 15
B. The code does not compile because of line p1.
C. The code does not compile because of line p2.
D. None of the above
|
23_ Fill in the blanks: allow Java to support multiple inheritance, and
anonymous inner classes can of them.
A. Abstract classes, extend at most one
B. Abstract classes, extend any number
C. Interfaces, implement at most one
D. Interfaces, implement any number
|
24_ What is the output of the following application?
package vessel;
class Problem extends Exception {}
abstract class Danger {
protected abstract void isDanger() throws Problem;
}
public class SeriousDanger extends Danger {
protected void isDanger() throws Exception { // m1
throw new RuntimeException();
}
public static void main(String[] will) throws Throwable { // m2
new SeriousDanger().isDanger(); // m3
}
}

A. The code does not compile because of line m1
B. The code does not compile because of line m2.
C. The code does not compile because of line m3.
D. The code compiles but throws an exception at runtime.
|
25_ Which of the following is not a true statement about interfaces and abstract classes?
A. Interfaces can only extend other interfaces, while abstract classes can extend both
abstract and concrete classes.
B. Unlike abstract classes, interfaces can be marked final.
C. Abstract classes offer support for single inheritance, while interfaces offer support for
multiple inheritance.
D. All methods and variables in interfaces are public, while abstract classes can
use various access modifiers for their methods and variables, including private
in some cases.
|
26_ What is the output of the following application?
package weather;
public class Forecast {
public enum Snow { BLIZZARD, SQUALL, FLURRY }
public static void main(String[] modelData) {
System.out.print(Snow.BLIZZARD.ordinal());
System.out.print(" "+Snow.valueOf("flurry".toUpperCase()).name());
}
}
A. 0 FLURRY
B. 1 FLURRY
C. The code does not compile.
D. The code compiles but throws an exception at runtime.
|
27_ Fill in the blank: The primary reason default interface methods were added to Java is to
support .
A. polymorphism
B. concrete methods in interfaces
C. multiple inheritance
D. backward compatibility
|
28_ What is the output of the following application?
package zoo;
public class Penguin {

private int volume = 1;
private class Chick {
private static int volume = 3;
void chick() {
System.out.print("Honk("+Penguin.this.volume+")!");
}
}
public static void main(String... eggs) {
Penguin pen = new Penguin();
final Penguin.Chick littleOne = pen.new Chick();
littleOne.chick();
}
}
A. Honk(1)!
B. Honk(3)!
C. The code does not compile.
D. The code compiles but the output cannot be determined until runtime.
|
29_ Let’s say Dinosaur is a class that contains a public member inner class called
Pterodactyl. Given that dino is an instance of Dinosaur, how would you instantiate a
new Pterodactyl from within a static method, such as main()?
A. new Pterodactyl();
B. dino.Pterodactyl();
C. Dinosaur.new Pterodactyl();
D. dino.new Pterodactyl();
|
30_ What is the result of compiling the following program?
package desert;
interface CanBurrow {
public abstract void burrow();
}
@FunctionalInterface interface HasHardShell extends CanBurrow {} // k1
abstract class Tortoise implements HasHardShell { // k2
public abstract int toughness();
}
public class DesertTortoise extends Tortoise { // k3
public int toughness() { return 11; }
}

A. The code does not compile because of line k1.
B. The code does not compile because of line k2.
C. The code does not compile because of line k3.
D. The code compiles without issue.
|
31_ Which statement(s) about the following Twins class are true?
package clone;
interface Alex {
default void write() {}
static void publish() {}
void think();
}
interface Michael {
public default void write() {}
public static void publish() {}
public void think();
}
public class Twins implements Alex, Michael {
@Override public void write() {}
@Override public static void publish() {}
@Override public void think() {
System.out.print("Thinking...");
}
}
I. The class fails to compile because of the write() method.
II. The class fails to compile because of the publish() method.
III. The class fails to compile because of the think() method.
A. I only
B. II only
C. I and II
D. II and III
|
32_ Fill in the blanks: A(n) and a(n) can define
static methods.
A. abstract class, local inner class
B. anonymous inner class, interface
C. member inner class, enum
D. enum, static inner class

|
33_ Which lambda expression can replace the instance of new BiologyMaterial() in the
Scientist class and produce the same results under various inputted values?
package university;
@FunctionalInterface interface Study {
abstract int learn(String subject, int duration);
}
class BiologyMaterial implements Study {
@Override public int learn(String subject, int duration) {
if(subject == null)
return duration;
else
return duration+1;
}
}
public class Scientist {
public static void main(String[] courses) {
final Study s = new BiologyMaterial() {};
System.out.print(s.learn(courses[0], Integer.parseInt(courses[1])));
}
}
A. (p,q) -> q==null ? p : p+1
B. (c,d) -> {int d=1; return c!=null ? d+1 : d;}
C. (x,y) -> {return x==null ? y : y+1;}
D. None of the above
|
34_ Given the following enum declaration, how many lines contain compilation errors?
package myth;
public enum Proposition {
TRUE(-10) { @Override String getNickName() { return "RIGHT"; }},
FALSE(-10) { public String getNickName() { return "WRONG"; }},
UNKNOWN(0) { @Override public String getNickName() { return "LOST"; }}
private final int value;
Proposition(int value) {
this.value = value;
}
public int getValue() {

return this.value;
}
protected abstract String getNickName();
}
A. None. The code compiles as is.
B. One
C. Two
D. Three
|
35_ What is the output of the following application?
package math;
interface AddNumbers {
int add(int x, int y);
static int subtract(int x, int y) { return x-y; }
default int multiply(int x, int y) { return x*y; }
}
public class Calculator {
protected void calculate(AddNumbers add, int a, int b) {
System.out.print(add.add(a, b));
}
public static void main(String[] moreNumbers) {
final Calculator ti = new Calculator();
ti.calculate((k,p) -> p+k+1, 2, 5); // j1
}
}
A. 8
B. The code does not compile because AddNumbers is not a functional interface.
C. The code does not compile because of line j1.
D. None of the above
|
36_ Given the class declaration below, what expression can be used to fill in the blank to return
the size variable defined in the Bottle class, printing 14 at runtime?
package baby;
final public class Bottle {
final private int size = 14;
final protected class Insert {

private final int size = 25;
public final int getSize() {
return ;
}
}
final Insert insert = new Insert();
final public static void main(String[] feed) {
System.out.print(new Bottle().insert.getSize());
}
}
A. Bottle.this.size
B. this.size
C. this.Bottle.size
D. The code does not compile, regardless of what is placed in the blank.
|
37_ What is the output of the following application?
package ocean;
abstract interface CanSwim {
public void swim();
}
public class Turtle {
public static void main(String[] seaweed) {
int distance = 7;
CanSwim seaTurtle = {
@Override
public void swim() {
System.out.print(distance);
}
};
seaTurtle.swim();
}
}
A. The application completes without printing anything.
B. 7
C. One line of this application fails to compile.
D. Two lines of this application fail to compile.

|
38_ What is the output of the following application?
package present;
interface Toy { String play(); }
public class Gift {
public static void main(String[] matrix) {
abstract class Robot {}
class Transformer extends Robot implements Toy {
public String name = "GiantRobot";
public String play() {return "DinosaurRobot";}
}
Transformer prime = new Transformer () {
public String play() {return name;} // y1
};
System.out.print(prime.play()+" "+name);
}
}
A. GiantRobot GiantRobot
B. GiantRobot DinosaurRobot
C. The code does not compile because of line y1.
D. None of the above
|
39_ What is the result of compiling the following program?
package ballroom;
class Leader {}
class Follower {}
abstract public class Dancer {
public Leader getPartner() { return new Leader(); }
abstract public Leader getPartner(int count); // u1
}
abstract class SwingDancer extends Dancer {
public Follower getPartner() { // u2
return new Follower(); // u3
}
}

A. The code does not compile because of line u1.
B. The code does not compile because of line u2.
C. The code does not compile because of line u3.
D. The code compiles without issue.
|
40_ What is the output of the following application?
package prepare;
public class Ready {
protected static int first = 2;
private final short DEFAULT_VALUE = 10;
private static class GetSet {
int first = 5;
static int second = DEFAULT_VALUE;
}
private GetSet go = new GetSet();
public static void main(String[] begin) {
Ready r = new Ready();
System.out.print(r.go.first);
System.out.print(", "+r.go.second);
}
}
A. 2, 5
B. 5, 10
C. The code does not compile because of the GetSet class body.
D. The code does not compile for another reason.


|
1_ Which of the following can fill in the blank to make the code compile?
public class News< > {}
I. ?
II. News
III. Object
A. None of them
B. I
C. II and III
D. I, II, and III
|
2_ Which method is available on both List and Stream implementations?
A. filter()
B. forEach()
C. replace()
D. sort()
|
3_ We are running a library. Patrons select books by name. They get at the back of the checkout
line. When they get to the front, they scan the book’s ISBN. The checkout system finds
the book based on this number and marks the book as checked out. Of these choices, which
data structures best represent the line to check out the book and the book lookup to mark it
as checked out, respectively?
A. ArrayDeque, TreeMap
B. ArrayDeque, TreeSet
C. ArrayList, TreeMap
D. ArrayList, TreeSet
|
4_ Which cannot fill in the blank for this code to compile?
Collection<String> c = new <>();
c.add("pen");
c.remove("pen");
System.out.println(c.isEmpty());
A. ArrayDeque
B. TreeMap
C. TreeSet
D. All of these can fill in the blank.

|
5_ Suppose we want to implement a Comparator<String> so that it sorts the longest
strings first. You may assume there are no nulls. Which method could implement such a
comparator?
A.
public int compare(String s1, String s2) {
return s1.length() - s2.length();
}
B.
public int compare(String s1, String s2) {
return s2.length() – s1.length();
}
C.
public int compare(Object obj1, object obj2) {
String s1 = (String) obj1;
String s2 = (String) obj2;
return s1.length() - s2.length();
}
D.
public int compare(Object obj1, object obj2) {
String s1 = (String) obj1;
String s2 = (String) obj2;
return s2.length() – s1.length();
}
|
6_ Suppose we want to store JellyBean objects. Which of the following pairs require
JellyBean to implement the Comparable interface or create a Comparator in order
to add them to the Collection?
A. ArrayList and ArrayDeque
B. HashMap and HashSet
C. HashMap and TreeMap
D. TreeMap and TreeSet
|
7_ What is a common reason for a stream pipeline not to run?
A. The source doesn’t generate any items.
B. There are no intermediate operations.
C. The terminal operation is missing.
D. None of the above

|
8_ We want this code to print the titles of each book twice. Why doesn’t it?
LinkedList<String> list = new LinkedList<>();
list.add("Grapes of Wrath");
list.add("1984");
list.forEach(System.out::println);
Iterator it = list.iterator();
while (it.hasMore())
System.out.println(it.next());
A. The generic type of Iterator is missing.
B. The hasMore() method should be changed to hasNext().
C. The iteration code needs to be moved before the forEach() since the stream is used up.
D. None of the above. The code does print each book title twice.
|
9_ What is the result of the following?
ArrayList<Integer> list = new ArrayList<>();
list.add(56);
list.add(56);
list.add(3);
TreeSet<Integer> set = new TreeSet<>(list);
System.out.print(set.size());
System.out.print(" " );
System.out.print(set.iterator().next());
A. 2 3
B. 2 56
C. 3 3
D. 3 56
|
10_ What best describes a reduction?
A. An intermediate operation where it filters the stream it receives
B. An intermediate operation where it mathematically divides each element in the stream
C. A terminal operation where a single value is generated by reading each element in the
prior step in a stream pipeline

D. A terminal operation where one element is returned from the prior step in a stream
pipeline without reading all the elements
|
11_ What is the output of the following?
5: ArrayDeque<Integer> d = new ArrayDeque<>();
6: d.offer(18);
7: d.offer(5);
8: d.push(13);
9: System.out.println(d.poll() + " " + d.poll());
A. 13 18
B. 18 5
C. 18 13
D. None of the above
|
12_ What is the output of the following?
class Magazine {
private String name;
public Magazine(String name) {
this.name = name;
}
public int compareTo(Magazine m) {
return name.compareTo(m.name);
}
public String toString() {
return name;
}
}
public class Newstand {
public static void main(String[] args) {
Set<Magazine> set = new TreeSet<>();
set.add(new Magazine("highlights"));
set.add(new Magazine("Newsweek"));
set.add(new Magazine("highlights"));
System.out.println(set.iterator().next());
}
}
A. highlights
B. Newsweek

C. The code does not compile.
D. The code compiles but throws an exception at runtime.
|
13_ What is the result of the following?
6: List<String> list = new ArrayList<>();
7: list.add("Monday");
8: list.add(String::new);
9: list.add("Tuesday");
10: list.remove(0);
11: System.out.println(list.get(0));
A. An empty String
B. Monday
C. The code does not compile.
D. The code compiles but throws an exception at runtime.
|
14_ How many lines does this code output?
List<String> list = new LinkedList<>();
list.add("Archie");
list.add("X-Men");
list.stream().forEach(s -> System.out.println(s));
list.stream().forEach(s -> System.out.println(s));
A. Two
B. Four
C. The code does not compile.
D. The code compiles but throws an exception at runtime.
|
15_ Which line in the main() method doesn’t compile or points to a class that doesn’t compile?
1: interface Comic<C> {
2: void draw(C c);
3: }
4: class ComicClass<C> implements Comic<C> {
5: public void draw(C c) {
6: System.out.println(c);
7: }
8: }
9: class SnoopyClass implements Comic<Snoopy> {
10: public void draw(Snoopy c) {
11: System.out.println(c);

12: }
13: }
14: class SnoopyComic implements Comic<Snoopy> {
15: public void draw(C c) {
16: System.out.println(c);
17: }
18: }
19: public class Snoopy {
20: public static void main(String[] args) {
21: Comic<Snoopy> c1 = c -> System.out.println(c);
22: Comic<Snoopy> c2 = new ComicClass<>();
23: Comic<Snoopy> c3 = new SnoopyClass();
24: Comic<Snoopy> c4 = new SnoopyComic();
25: }
26: }
A. Line 21
B. Line 22
C. Line 23
D. Line 24
|
16_ What is the output of the following?
Stream<String> s = Stream.of("Atlanta", "Chicago", "New York");
long count = s.filter(c -> c.startsWith("C")).count();
System.out.print(count);
A. 1
B. 2
C. The code does not compile.
D. The code compiles but throws an exception at runtime.
|
17_ Fill in the blank to make this code compile:
public class Truck implements Comparable<Truck> {
private int id;
public Truck(int id) {
this.id = id;
}
@Override
{

return id - t.id;
}
}
A. public int compare(Truck t)
B. public int compare(Truck t1, Truck t2)
C. public int compareTo(Truck t)
D. public int compareTo(Truck t1, Truck t2)
|
18_ In a stream pipeline, which can return a value other than a Stream?
A. Source
B. Intermediate operation
C. Terminal operation
D. None of the above
|
19_ Rewrite this lambda using a constructor reference:
n -> new ArrayList<>(n)
A. ArrayList::new;
B. ArrayList::new();
C. ArrayList::new(n);
D. ArrayList::new[n];
|
20_ What is the result of the following?
Comparator<Integer> c = (x, y) -> y-x;
List<Integer> ints = Arrays.asList(3, 1, 4);
Collections.sort(ints, c);
System.out.println(Collections.binarySearch(ints, 1));
A. 0
B. 1
C. The code does not compile.
D. The result is not defined.
|
21_ How many lines does this code output?
List<String> list = new LinkedList<>();
list.add("Archie");
list.add("X-Men");
Stream<String> s = list.stream();
s.forEach(System.out::println);
s.forEach(System.out::println);

A. Two
B. Four
C. The code does not compile.
D. The code compiles but throws an exception at runtime.
|
22_ Which option cannot fill in the blank to print Clean socks?
class Wash<T> {
T item;
public void clean(T item) {
System.out.println("Clean " + item);
}
}
public class LaundryTime {
public static void main(String[] args) {
wash.clean("socks");
}
}
A. Wash wash = new Wash();
B. Wash wash = new Wash<String>();
C. Wash<String> wash = new Wash<>();
D. All three can fill in the blank.
|
23_ We want this code to print the titles of each book twice. Why doesn’t it?
LinkedList<String> list = new LinkedList<>();
list.add("Grapes of Wrath");
list.add("1984");
list.stream().forEach(System.out::println);
Iterator it = list.iterator();
while (it.hasNext())
System.out.println(it.next());
A. The generic type of Iterator is missing.
B. The hasNext() method should be changed to isNext().
C. The iteration code needs to be moved before the forEach() since the stream is used up.
D. None of the above. The code does print each book title twice.

|
24_ Rewrite this lambda using a method reference:
() -> Math.random()
A. Math.random
B. Math::random
C. Math::random()
D. None of the above
|
25_ Which operation can occur more than once in a stream pipeline?
Source Intermediate Terminal
A. Source
B. Intermediate operation
C. Terminal operation
D. None of the above
|
26_ Which type allows inserting a null value?
A. ArrayDeque
B. ArrayList
C. TreeSet
D. All of these allow nulls.
|
27_ Fill in the blank so this code outputs three lines:
List<String> list = new ArrayList<>();
list.add("Atlanta");
list.add("Chicago");
list.add("New York");
list.stream().filter( ).forEach(System.out::println);
A. String::isEmpty
B. ! String::isEmpty
C. String::! isEmpty
D. None of the above
|
28_ What is the output of the following?
TreeMap<String, Integer> map = new TreeMap<>();
map.put("3", 3);
map.put("three", 3);

map.put("THREE", 3);
System.out.println(map.firstKey() + " " + map.lastKey());
A. 3 three
B. 3 THREE
C. three 3
D. THREE 3
|
29_ Which fills in the blank in the method signature to allow this code to compile?
import java.util.*;
public class ExtendingGenerics {
private static < , U> U add(T list, U element) {
list.add(element);
return element;
}
public static void main(String[] args) {
List<String> values = new ArrayList<>();
add(values, "duck");
add(values, "duck");
add(values, "goose");
System.out.println(values);
}
}
A. ? extends Collection<U>
B. ? implements Collection<U>
C. T extends Collection<U>
D. T implements Collection<U>
|
30_ What is the result of the following?
List<String> list = new ArrayList<>();
list.add("Austin");
list.add("Boston");
list.add("San Francisco");
list.removeIf(a -> a.length() > 10);
System.out.println(list.size());
A. 1
B. 2
C. 3
D. None of the above

|
31_ What does the following output?
ArrayDeque<Integer> dice = new ArrayDeque<>();
dice.offer(3);
dice.offer(2);
dice.offer(4);
System.out.print(dice.stream().filter(n -> n != 4));
A. 2
B. 3
C. The code does not compile.
D. None of the above
|
32_ Which of the following cannot fill in the blank to make the code compile?
private void output( <?> x) {
x.forEach(System.out::println);
}
A. ArrayDeque
B. Collection
C. TreeMap
D. None of the above
|
33_ How many lines does this code output?
List<String> list = new LinkedList<>();
list.add("Archie");
list.add("X-Men");
list.stream().forEach(System.out.println);
list.stream().forEach(System.out.println);
A. Two
B. Four
C. The code does not compile.
D. The code compiles but throws an exception at runtime.
|
34_ What is the output of the following?
class Magazine implements Comparable<Magazine> {
private String name;
public Magazine(String name) {
this.name = name;
}
@Override
public int compareTo(Magazine m) {

return name.compareTo(m.name);
}
@Override
public String toString() {
return name;
}
}
public class Newstand {
public static void main(String[] args) {
Set<Magazine> set = new TreeSet<>();
set.add(new Magazine("highlights"));
set.add(new Magazine("Newsweek"));
set.add(new Magazine("highlights"));
System.out.println(set.iterator().next());
}
}
A. highlights
B. Newsweek
C. The code does not compile.
D. The code compiles but throws an exception at runtime.
|
35_ How many lines does the following code output?
import java.util.*;
class Blankie {
String color;
String getColor() {
return color;
}
}
public class PreSchool {
public static void main(String[] args) {
Blankie b1 = new Blankie();
Blankie b2 = new Blankie();
b1.color = "pink";
List<Blankie> list = Arrays.asList(b1, b2);
list.stream().filter(Blankie::getColor).forEach(System.out::println);
}
}

A. One
B. Two
C. The code does not compile.
D. The code compiles but throws an exception at runtime.
|
36_ Which statement about a source in a Stream is true?
A. The source is mandatory in a stream pipeline.
B. The source is only allowed to return primitives.
C. The source must be retrieved by calling the stream() method.
D. The source must return a finite number of elements.
|
37_ What does the following output?
List<String> list = new ArrayList<>();
list.add("Austin");
list.add("Boston");
list.add("San Francisco");
long c = list.stream().filter(a -> a.length() > 10).count();
System.out.println(c + " " + list.size());
A. 1 1
B. 1 3
C. 2 3
D. None of the above
|
38_ Which options can fill in the blanks to print Cleaned 2 items?
import java.util.*;
class Wash<T Collection> {
T item;
public void clean(T items) {
System.out.println("Cleaned " + items.size() + " items");
}
}
public class LaundryTime {
public static void main(String[] args) {
Wash<List> wash = new
wash.clean(Arrays.asList("sock", "tie")); }
}

A. extends, Wash<ArrayList>();
B. extends, Wash<List>();
C. super, Wash<ArrayList>();
D. super, Wash<List>();
|
39_ Which of the following declares a Comparator where all objects are treated as equal?
A. Comparator<Character> comp = (c1)-> 0;
B. Comparator<Character> comp = (c1)-> {0};
C. Comparator<Character> comp = (c1, c2)-> 0;
D. Comparator<Character> comp = (c1, c2)-> {0};
|
40_ Why can’t String::charAt be used as a method reference?
A. Method references can only be used on static methods.
B. Method references can pass either the instance or the parameter from the lambda, but
not both.
C. The charAt() method takes an int rather than Integer parameter.
D. There is no charAt() method in the String class.

|
1_ Fill in the blanks: The functional interface does not take any inputs,
while the functional interface does not return any data.
A. IntConsumer, LongSupplier
B. IntSupplier, Function
C. Supplier, DoubleConsumer
D. UnaryOperator, Consumer
|
2_ Which functional interface takes a long value as an input argument and has an accept()
method?
A. LongConsumer
B. LongFunction
C. LongPredicate
D. LongSupplier
|
3_ What is the output of the following application?
package beach;
import java.util.function.*;
class Tourist {
public Tourist(double distance) {
this.distance = distance;
}
public double distance;
}
public class Lifeguard {
private void saveLife(Predicate<Tourist> canSave, Tourist tourist) {
System.out.print(canSave.test(tourist) ? "Saved" : "Too far"); // y1
}
public final static void main(String... sand) {
new Lifeguard().saveLife(s -> s.distance<4, new Tourist(2)); // y2
}
}
A. Saved
B. Too far
C. The code does not compile because of line y1.
D. The code does not compile because of line y2.

|
4_ Which of the following statements about DoubleSupplier and Supplier<Double> is
not true?
A. Both are functional interfaces.
B. Lambdas for both can return a double value.
C. Lambdas for both cannot return a null value.
D. One supports a generic type, the other does not.
|
5_ Which functional interface, when filled into the blank, allows the class to compile?
package space;
import java.util.function.*;
public class Asteroid {
public void mine( lambda) {
// TODO: Apply functional interface
}
public static void main(String[] debris) {
new Asteroid().mine((s,p) -> s+p);
}
}
A. BiConsumer<Integer,Double>
B. BiFunction<Integer,Double,Double>
C. BiFunction<Integer,Integer,Double>
D. Function<Integer,Double>
|
6_ Assuming the proper generic types are used, which lambda expression cannot be assigned
to a ToDoubleBiFunction functional interface reference?
A. (Integer a, Double b) -> {int c; return b;}
B. (h,i) -> (long)h
C. (String u, Object v) -> u.length()+v.length()
D. (x,y) -> {int z=2; return y/z;}
|
7_ Which of the following is not a functional interface in the java.util.function package?
A. BiPredicate
B. DoubleUnaryOperator
C. ObjectDoubleConsumer
D. ToLongFunction

|
8_ What is the output of the following application?
package zoo;
import java.util.function.*;
public class TicketTaker {
private static int AT_CAPACITY = 100;
public int takeTicket(int currentCount, IntUnaryOperator<Integer> counter) {
return counter.applyAsInt(currentCount);
}
public static void main(String...theater) {
final TicketTaker bob = new TicketTaker();
final int oldCount = 50;
final int newCount = bob.takeTicket(oldCount,t -> {
if(t>AT_CAPACITY) {
throw new RuntimeException("Sorry, max has been reached");
}
return t+1;
});
System.out.print(newCount);
}
}
A. 51
B. The code does not compile because of lambda expression.
C. The code does not compile for a different reason.
D. The code compiles but prints an exception at runtime.
|
9_ Which functional interface returns a primitive value?
A. BiPredicate
B. CharSupplier
C. LongFunction
D. UnaryOperator
|
10_ Which functional interface, when entered into the blank below, allows the class to compile?
package groceries;
import java.util.*;
import java.util.function.*;
public class Market {

private static void checkPrices(List<Double> prices,
scanner) {
prices.forEach(scanner);
}
public static void main(String[] right) {
List<Double> prices = Arrays.asList(1.2, 6.5, 3.0);
checkPrices(prices,
p -> {
String result = p<5 ? "Correct" : "Too high";
System.out.println(result);
});
}
}
A. Consumer
B. DoubleConsumer
C. Supplier<Double>
D. None of the above
|
11_ Which of the following three functional interfaces is not equivalent to the other two?
A. BiFunction<Double,Double,Double>
B. BinaryOperator<Double>
C. DoubleFunction<Double>
D. None of the above. All three are equivalent.
|
12_ Which lambda expression can be passed to the magic() method?
package show;
import java.util.function.*;
public class Magician {
public void magic(BinaryOperator<Long> lambda) {
lambda.apply(3L, 7L);
}
}
A. magic((a) -> a)
B. magic((b,w) -> (long)w.intValue())
C. magic((c,m) -> {long c=4; return c+m;})
D. magic((Integer d, Integer r) -> (Long)r+d)

|
13_ What is the output of the following program?
package ai;
import java.util.function.*;
public class Android {
public void wakeUp(Supplier supplier) { // d1
supplier.get();
}
public static void main(String... electricSheep) {
Android data = new Android();
data.wakeUp(() -> System.out.print("Program started!")); // d2
}
}
A. Program started!
B. The code does not compile because of line d1 only.
C. The code does not compile because of line d2 only.
D. The code does not compile because of both lines d1 and d2.
|
14_ Which statement about all UnaryOperator functional interfaces (generic and primitive) is
correct?
A. The input type must be compatible with the return type.
B. Some of them take multiple arguments.
C. They each take a generic argument.
D. They each return a primitive value.
|
15_ Starting with DoubleConsumer and going downward, fill in the missing values for the table.
Functional Interface # Parameters
DoubleConsumer
IntFunction
LongSupplier
ObjDoubleConsumer
A. 0, 1, 1, 1
B. 0, 2, 1, 2
C. 1, 1, 0, 2
D. 1, 1, 0, 1

|
16_ Starting with DoubleConsumer and going downward, fill in the values for the table. For the
choices below, assume R is a generic type.
Functional Interface Return Type
DoubleConsumer
IntFunction
LongSupplier
ObjDoubleConsumer
A. double, R, long, R
B. R, int, long, R
C. void, int, R, void
D. void, R, long, void
|
17_ Fill in the blanks: In the Collection interface, the method removeIf() takes a
, while the method forEach() takes a .
A. Function, Function
B. Predicate, Consumer
C. Predicate, Function
D. Predicate, UnaryOperator
|
18_ What is the output of the following application?
package nesting;
import java.util.function.*;
public class Doll {
private int layer;
public Doll(int layer) {
super();
this.layer = layer;
}
public static void open(UnaryOperator<Doll> task, Doll doll) {
while((doll = task.accept(doll)) != null) {
System.out.print("X");
}
}

public static void main(String[] wood) {
open(s -> {
if(s.layer<=0) return null;
else return new Doll(s.layer––);
}, new Doll(5));
}
}
A. XXXXX
B. The code does not compile because of the lambda expression.
C. The code does not compile for a different reason.
D. The code compiles but produces an infinite loop at runtime.
|
19_ Which functional interface has a get() method?
A. Consumer
B. Function
C. Supplier
D. UnaryOperator
|
20_ The following diagram shows input arguments being applied to three functional interfaces
of unknown type. Which three functional interfaces, inserted in order from left to right,
could be used to complete the diagram?
int
? ? ? int
int
Double
A. DoubleBinaryOperator
ToDoubleBiFunction<Integer,Double>
UnaryOperator<Integer>
B. BinaryOperator<Double>
BiFunction<Integer,Integer,Double>
UnaryOperator<Integer>
C. Function<Double,Integer>
BiFunction<Integer,Integer,Double>
DoubleToIntFunction
D. BiFunction<Integer,Double,Integer>
BinaryOperator<Integer>
IntUnaryOperator

|
21_ Which statement about functional interfaces and lambda expressions is not true?
A. A lambda expression may be compatible with multiple functional interfaces.
B. A lambda expression must be assigned to a functional interface when it is declared.
C. A method can return a lambda expression in the form of a functional interface
instance.
D. The compiler uses deferred execution to skip determining whether a lambda expression
compiles or not.
|
22_ Which expression is compatible with the IntSupplier functional interface?
A. () -> 1<10 ? "3" : 4
B. () -> {return 1/0;}
C. () -> return 4
D. System.out::print
|
23_ What is the output of the following application?
package tps;
import java.util.*;
class Boss {
private String name;
public Boss(String name) {
this.name = name;
}
public String getName() {return name.toUpperCase();}
public String toString() {return getName();}
}
public class Initech {
public static void main(String[] reports) {
final List<Boss> bosses = new ArrayList(8);
bosses.add(new Boss("Jenny"));
bosses.add(new Boss("Ted"));
bosses.add(new Boss("Grace"));
bosses.removeIf(s -> s.equalsIgnoreCase("ted"));
System.out.print(bosses);
}
}
A. [JENNY, GRACE]
B. [tps.Boss@4218224c, tps.Boss@815f19a]
C. The code does not compile because of the lambda expression.
D. The code does not compile for a different reason.

|
24_ Which of the following method references can be passed to a method that takes
Consumer<Object> as an argument?
I. ArrayList::new
II. String::new
III. System.out::println
A. I only
B. I, II, and III
C. I and III
D. III only
|
25_ Which of the following is a valid functional interface in the java.util.function package?
A. FloatPredicate
B. ToDoubleBiFunction
C. UnaryIntOperator
D. TriPredicate
|
26_ Which functional interface, when filled into the blank, prevents the class from compiling?
package morning;
import java.util.function.*;
public class Sun {
public static void dawn( sunrise) {}
public void main(String... rays) {
dawn(s -> s+1);
}
}
A. DoubleUnaryOperator
B. Function<String,String>
C. IntToLongFunction
D. UnaryOperator
|
27_ Which functional interface does not have the correct number of generic arguments?
A. BiFunction<T,U,R>
B. DoubleFunction<T,R>
C. ToDoubleFunction<T>
D. ToIntBiFunction<T,U>

|
28_ Which lambda expression, when filled into the blank, allows the code to compile?
package ballroom;
import java.util.function.*;
public class Dance {
public static Integer rest(BiFunction<Integer,Double,Integer> takeABreak) {
return takeABreak.apply(3, 10.2);
}
public static void main(String[] participants) {
rest( );
}
}
A. (int n, double e) -> (int)(n+e)
B. (n,w,e) -> System.out::print
C. (s,w) -> 2*w
D. (s,e) -> s.intValue()+e.intValue()
|
29_ Fill in the blank: is the only functional interface that does not involve
double, int, or long.
A. BooleanSupplier
B. CharPredicate
C. FloatUnaryOperator
D. ShortConsumer
|
30_ What is the output of the following application?
package savings;
import java.util.function.*;
public class Bank {
private int savingsInCents;
private static class ConvertToCents {
static DoubleToIntFunction f = p -> p*100;
}
public static void main(String... currency) {
Bank creditUnion = new Bank();
creditUnion.savingsInCents = 100;
double deposit = 1.5;
creditUnion.savingsInCents += ConvertToCents.f.applyAsInt(deposit); // j1

System.out.print(creditUnion.savingsInCents);
}
}
A. 200
B. 250
C. The code does not compile because of line j1.
D. None of the above
|
31_ Which functional interface takes a double value and has a test() method?
A. DoubleConsumer
B. DoublePredicate
C. DoubleUnaryOperator
D. ToDoubleFunction
|
32_ Given the following class, how many lines contain compilation errors?
1: package showtimes;
2: import java.util.*;
3: import java.util.function.*;
4: public class FindMovie {
5: private Function<String> printer;
6: protected FindMovie() {
7: printer = s -> {System.out.println(s); return s;}
8: }
9: void printMovies(List<String> movies) {
10: movies.forEach(printer);
11: }
12: public static void main(String[] screen) {
13: List<String> movies = new ArrayList<>();
14: movies.add("Stream 3");
15: movies.add("Lord of the Recursion");
16: movies.add("Silence of the Lambdas");
17: new FindMovie().printMovies(movies);
18: }
19: }
A. None. The code compiles as is.
B. One
C. Two
D. Three

|
33_ Which lambda expression cannot be assigned to a DoubleToLongFunction functional
interface?
A. a -> null==null ? 1 : 2L
B. e -> (int)(10.0*e)
C. (double m) -> {long p = (long)m; return p;}
D. (Double s) -> s.longValue()
|
34_ Which of the following is not a functional interface in the java.util.function package?
A. DoublePredicate
B. LongUnaryOperator
C. ShortSupplier
D. ToIntBiFunction
|
35_ Which functional interface, when filled into the blank, allows the class to compile?
package sleep;
import java.util.function.*;
class Sheep {}
public class Dream {
int MAX_SHEEP = 10;
int sheepCount;
public void countSheep( backToSleep) {
while(sheepCount<MAX_SHEEP) {
// TODO: Apply lambda
sheepCount++;
}
}
public static void main(String[] dark) {
new Dream().countSheep(System.out::println);
}
}
A. Consumer<Sheep>
B. Function<Sheep,void>
C. UnaryOperator<Sheep>
D. None of the above

|
36_ What is the output of the following application?
package pet;
import java.util.*;
import java.util.function.*;
public class DogSearch {
void reduceList(List<String> names, Predicate<String> tester) {
names.removeIf(tester);
}
public static void main(String[] treats) {
int MAX_LENGTH = 2;
DogSearch search = new DogSearch();
List<String> names = new ArrayList<>();
names.add("Lassie");
names.add("Benji");
names.add("Brian");
MAX_LENGTH += names.size();
search.reduceList(names, d -> d.length()>MAX_LENGTH);
System.out.print(names.size());
}
}
A. 2
B. 3
C. The code does not compile because of lambda expression.
D. The code does not compile for a different reason.
|
37_ Which functional interface takes two values and has an apply() method?
A. BiConsumer
B. BiFunction
C. BiPredicate
D. DoubleBinaryOperator
|
38_ Which of the following lambda expressions can be passed to a method that takes
IntFunction<Integer> as an argument?
I. (Integer f) -> f
II. (v) -> null
III. s -> s
A. I, II, and III
B. II and III only
C. III only
D. None of the above

|
39_ What is the output of the following application?
package lot;
import java.util.function.*;
public class Warehouse {
private int quantity = 40;
private final BooleanSupplier stock;
{
stock = () -> quantity>0;
}
public void checkInventory() {
if(stock.get())
System.out.print("Plenty!");
else {
System.out.print("On Backorder!");
}
}
public static void main(String... widget) {
final Warehouse w13 = new Warehouse();
w13.checkInventory();
}
}
A. Plenty!
B. On Backorder!
C. The code does not compile because of the checkInventory() method.
D. The code does not compile for a different reason.
|
40_ Which of the following statements about functional interfaces is true?
A. It is possible to define a functional interface that returns two data types.
B. It is possible to define a primitive functional interface that uses float, char, or short.
C. It is not possible to define a functional interface that does not take any arguments nor
return any value.
D. None of the primitive functional interfaces include generic arguments.

|
1_ Which of the following fills in the blank so that the code outputs one line but uses a poor
practice?
import java.util.*;
public class Cheater {
int count = 0;
public void sneak(Collection<String> coll) {
coll.stream(). ;
}
public static void main(String[] args) {
Cheater c = new Cheater();
c.sneak(Arrays.asList("weasel"));
}
}
A. peek(System.out::println)
B. peek(System.out::println).findFirst()
C. peek(r -> System.out.println(r)).findFirst()
D. peek(r -> {count++; System.out.println(r); }).findFirst()
|
2_ Which can fill in the blank to have the code print true?
Stream<Integer> stream = Stream.iterate(1, i -> i+1);
boolean b = stream. (i -> i > 5);
System.out.println(b);
A. anyMatch
B. allMatch
C. noneMatch
D. None of the above
|
3_ On a DoubleStream, how many of the methods average(), count(), and sum() return an
OptionalDouble?
A. None
B. One
C. Two
D. Three

|
4_ How many of the following can fill in the blank to have the code print 44?
Stream<String> stream = Stream.of("base", "ball");
stream. (s -> s.length()).forEach(System.out::print);
I. map
II. mapToInt
III. mapToObject
A. None
B. One
C. Two
D. Three
|
5_ What is the result of the following?
IntStream s = IntStream.empty();
System.out.print(s.average().getAsDouble());
A. The code prints 0.
B. The code prints 0.0.
C. The code does not compile.
D. The code compiles but throws an exception at runtime.
|
6_ Which of these stream pipeline operations takes a Predicate as a parameter and returns
an Optional?
A. anyMatch()
B. filter()
C. findAny()
D. None of the above
|
7_ What is the result of the following?
List<Double> list = new ArrayList<>();
list.add(5.4);
list.add(1.2);
Optional<Double> opt = list.stream().sorted().findFirst();
System.out.println(opt.get() + " " + list.get(0));
A. 1.2 1.2
B. 1.2 5.4
C. 5.4 5.4
D. None of the above

|
8_ Fill in the blank so this code prints 8.0.
IntStream stream = IntStream.of(6, 10);
LongStream longs = stream.mapToLong(i -> i);
System.out.println( );
A. longs.average().get()
B. longs.average().getAsDouble()
C. longs.getAverage().get()
D. longs.getAverage().getAsDouble()
|
9_ How many of these collectors can fill in the blank to make this code compile?
Stream<Character> chars = Stream.of(
'o', 'b', 's', 't', 'a', 'c', 'l', 'e');
chars.map(c -> c).collect(Collectors. );
I. toArrayList()
II. toList()
III. toMap()
A. None
B. One
C. Two
D. Three
|
10_ What does the following output?
import java.util.*;
public class MapOfMaps {
public static void main(String[] args) {
Map<Integer, Integer> map = new HashMap<>();
map.put(9, 3);
Map<Integer, Integer> result = map.stream().map((k,v) -> (v,k));
System.out.println(result.keySet().iterator().next());
}
}
A. 3
B. 9
C. The code does not compile.
D. The code compiles but throws an exception at runtime.

|
11_ Which of the following creates an Optional that returns true when calling
opt.isPresent()?
I. Optional<String> opt = Optional.empty();
II. Optional<String> opt = Optional.of(null);
III. Optional<String> opt = Optional.ofNullable(null);
A. I
B. I and II
C. I and III
D. None of the above
|
12_ What is the output of the following?
Stream<String> s = Stream.of("speak", "bark", "meow", "growl");
BinaryOperator<String> merge = (a, b) -> a;
Map<Integer, String> map = s.collect(toMap(String::length, k -> k, merge));
System.out.println(map.size() + " " + map.get(4));
A. 2 bark
B. 2 meow
C. 4 bark
D. None of the above
|
13_ What is the output of the following?
1: package reader;
2: import java.util.stream.*;
3:
4: public class Books {
5: public static void main(String[] args) {
6: IntegerStream pages = IntegerStream.of(200, 300);
7: IntegerSummaryStatistics stats = pages.summaryStatistics();
8: long total = stats.getSum();
9: long count = stats.getCount();
10: System.out.println(total + "-" + count);
11: }
12: }
A. 500-0
B. 500-2
C. The code does not compile.
D. The code compiles but throws an exception at runtime.

|
14_ If this method is called with Stream.of("hi"), how many lines are printed?
public static void print(Stream<String> stream) {
Consumer<String> print = System.out::println;
stream.peek(print)
.peek(print)
.map(s -> s)
.peek(print)
.forEach(print);
}
A. Three
B. Four
C. The code compiles but does not output anything.
D. The code does not compile.
|
15_ What is true of the following code?
Stream<Character> stream = Stream.of('c', 'b', 'a'); // z1
stream.sorted().findAny().ifPresent(System.out::println); // z2
A. It is guaranteed to print the single character a.
B. It can print any single character of a, b, or c.
C. It does not compile because of line z1.
D. It does not compile because of line z2.
|
16_ Suppose you have a stream pipeline where all the elements are of type String. Which of the
following can be passed to the intermediate operation sorted()?
A. (s,t) -> s.length() - t.length()
B. String::isEmpty
C. Both of these
D. Neither of these
|
17_ Fill in the blanks so that both methods produce the same output for all inputs.
private static void longer(Optional<Boolean> opt) {
if (opt. ())
System.out.println("run: " + opt.get());
}
private static void shorter(Optional<Boolean> opt) {
opt.map(x -> "run: " + x). (System.out::println);
}

A. isNotNull, isPresent
B. ifPresent, isPresent
C. isPresent, forEach
D. isPresent, ifPresent
|
18_ What is the output of this code?
Stream<Boolean> bools = Stream.iterate(true, b -> !b);
Map<Boolean, List<Boolean>> map = bools.limit(1)
.collect(partitioningBy(b -> b));
System.out.println(map);
A. {true=[true]}
B. {false=null, true=[true]}
C. {false=[], true=[true]}
D. None of the above
|
19_ What does the following output?
Set<String> set = new HashSet<>();
set.add("tire-");
List<String> list = new LinkedList<>();
Deque<String> queue = new ArrayDeque<>();
queue.push("wheel-");
Stream.of(set, list, queue)
.flatMap(x -> x.stream())
.forEach(System.out::print);
A. [tire-][wheel-]
B. tire-wheel-
C. None of the above.
D. The code does not compile.
|
20_ What is the output of the following?
Stream<String> s = Stream.of("over the river",
"through the woods",
"to grandmother's house we go");
s.filter(n -> n.startsWith("t"))
.sorted(Comparator::reverseOrder)
.findFirst()
.ifPresent(System.out::println);

A. over the river
B. through the woods
C. to grandmother's house we go
D. None of the above
|
21_ Which fills in the blank so the code is guaranteed to print 1?
Stream<Integer> stream = Stream.of(1, 2, 3);
System.out.println(stream. );
A. findAny()
B. first()
C. min()
D. None of the above
|
22_ Which of the following can be the type for x?
private static void spot( x) {
x.filter(y -> ! y.isEmpty())
.map(y -> 8)
.ifPresent(System.out::println);
}
I. List<String>
II. Optional<Collection>
III. Optional<String>
IV. Stream<Collection>
A. I
B. IV
C. II and III
D. II and IV
|
23_ Which can fill in the blank to have the code print true?
Stream<Integer> stream = Stream.iterate(1, i -> i);
boolean b = stream. (i -> i > 5);
System.out.println(b);
A. anyMatch
B. allMatch
C. noneMatch
D. None of the above

|
24_ What collector turns the stream at left to the Map at right?
Sree
Ken
Kumar
Ye
Dan
true Sree Kumar
Ken Ye Dan
false
A. grouping()
B. groupingBy()
C. partitioning()
D. partitioningBy()
|
25_ Which fills in the blank for this code to print 667788?
IntStream ints = IntStream.empty();
IntStream moreInts = IntStream.of(66, 77, 88);
Stream.of(ints, moreInts). (x -> x).forEach(System.out::print);
A. flatMap
B. flatMapToInt
C. map
D. None of the above
|
26_ Fill in the blank so this code prints 8.0 Note that it must not print OptionalDouble[8.0].
LongStream stream = LongStream.of(6, 10);
LongSummaryStatistics stats = stream.summaryStatistics();
System.out.println( );
A. stats.avg()
B. stats.average()
C. stats.average().get()
D. stats.getAverage()
|
27_ Which can independently fill in the blank to output No dessert today?
import java.util.*;
public class Dessert {
public static void main(String[] yum) {
eatDessert(Optional.of("Cupcake"));
}

private static void eatDessert(Optional<String> opt) {
System.out.println(opt. );
}
}
A. get("No dessert today")
B. orElse("No dessert today")
C. orElseGet(() -> "No dessert today")
D. None of the above
|
28_ What does the following output?
Stream<Character> chars = Stream.generate(() -> 'a');
chars.filter(c -> c < 'b')
.sorted()
.findFirst()
.ifPresent(System.out::print);
A. a
B. The code runs successfully without any output.
C. The code enters an infinite loop.
D. The code compiles but throws an exception at runtime.
|
29_ How many of the following can fill in the blank to have the code print the single digit 9?
LongStream stream = LongStream.of(9);
stream. (p -> p).forEach(System.out::print);
I. mapToDouble
II. mapToInt
III. mapToLong
A. None
B. One
C. Two
D. Three
|
30_ Suppose you have a stream with one element and the code
stream.xxxx.forEach(System.out::println). Filling in xxxx from
top to bottom in the table, how many elements can be printed out?
xxxx Number elements printed
filter()
flatMap()
map()

A. Zero or one, zero or more, exactly one
B. Zero or one, exactly one, zero or more
C. Zero or one, zero or more, zero or more
D. Exactly one, zero or more, zero or more
|
31_ What is the output of the following?
Stream<Character> stream = Stream.of('c', 'b', 'a');
System.out.println(stream.sorted().findFirst());
A. It is guaranteed to print the single character a.
B. It can print any single character of a, b, or c.
C. The code does not compile.
D. None of the above
|
32_ What is the output of the following?
public class Compete {
public static void main(String[] args) {
Stream<Integer> is = Stream.of(8, 6, 9);
Comparator<Integer> c = (a, b) -> a - b;
is.sort(c).forEach(System.out::print);
}
}
A. 689
B. 986
C. The code does not compile
D. The code compiles but throws an exception at runtime.
|
33_ What is the result of the following?
class Ballot {
private String name;
private int judgeNumber;
private int score;
public Ballot(String name, int judgeNumber, int score) {
this.name = name;
this.judgeNumber = judgeNumber;
this.score = score;
}
// all getters and setters
}

public class Speaking {
public static void main(String[] args) {
Stream<Ballot> ballots = Stream.of(
new Ballot("Mario", 1, 10),
new Ballot("Christina", 1, 8),
new Ballot("Mario", 2, 9),
new Ballot("Christina", 2, 8)
);
Map<String, Integer> scores = ballots.collect(
groupingBy(Ballot::getName, summingInt(Ballot::getScore))); // w1
System.out.println(scores.get("Mario"));
}
}
A. The code prints 2.
B. The code prints 19.
C. The code does not compile due to line w1.
D. The code does not compile due to a different line.
|
34_ Which can fill in the blank so this code outputs true?
import java.util.function.*;
import java.util.stream.*;
public class HideAndSeek {
public static void main(String[] args) {
Stream<Boolean> hide = Stream.of(true, false, true);
boolean found = hide.filter(b -> b). ();
System.out.println(found);
}
}
A. Only anyMatch
B. Only allMatch
C. Both anyMatch and allMatch
D. The code does not compile with any of these options.
|
35_ What does the following output?
Set<String> set = new HashSet<>();
set.add("tire-");
List<String> list = new LinkedList<>();
Deque<String> queue = new ArrayDeque<>();
queue.push("wheel-");

Stream.of(set, list, queue)
.flatMap(x -> x)
.forEach(System.out::print);
A. [tire-][wheel-]
B. tire-wheel-
C. None of the above
D. The code does not compile.
|
36_ When working with a Stream<String>, which of these types can be returned from the
collect() terminal operator by passing arguments to Collectors.groupingBy()?
I. Map<Integer, List<String>>
II. Map<Boolean, HashSet<String>>
III. List<String>
A. I
B. II
C. I and II
D. I, II, and III
|
37_ Which line can replace line 18 without changing the output of the program?
1: class Runner {
2: private int numberMinutes;
3: public Runner(int n) {
4: numberMinutes = n;
5: }
6: public int getNumberMinutes() {
7: return numberMinutes;
8: }
9: public boolean isFourMinuteMile() {
10: return numberMinutes < 4*60;
11: }
12: }
13: public class Marathon {
14: public static void main(String[] args) {
15: Stream<Runner> runners = Stream.of(new Runner(250),
16: new Runner(600), new Runner(201));
17: long count = runners
18: .filter(Runner::isFourMinuteMile)
19: .count();
20: System.out.println(count);
21: }
22: }

A. .map(Runner::isFourMinuteMile)
B. .mapToBool(Runner::isFourMinuteMile)
.filter(b -> b == true)
C. .mapToBoolean(Runner::isFourMinuteMile)
.filter(b -> b == true)
D. None of the above
|
38_ Which method is not available on the IntSummaryStatistics class?
A. getCountAsLong()
B. getMax()
C. toString()
D. None of the above—all three methods are available.
|
39_ Which can fill in the blank so this code outputs Caught it?
import java.util.*;
public class Catch {
public static void main(String[] args) {
Optional opt = Optional.empty();
try {
apply(opt);
} catch (IllegalArgumentException e) {
System.out.println("Caught it");
}
}
private static void apply(Optional<Exception> opt) {
opt. (IllegalArgumentException::new);
}
}
A. orElse
B. orElseGet
C. orElseThrow
D. None of the above. The main() method does not compile.
|
40_ A developer tries to rewrite a method that uses flatMap() without using that intermediate
operator. Which pair of method calls shows the withoutFlatMap() method is not equivalent
to the withFlatMap() method?

public static void main(String[] args) {
List<String> list = new LinkedList<>();
Deque<String> queue = new ArrayDeque<>();
queue.push("all queued up");
queue.push("last");
}
private static void withFlatMap(Collection<?> coll) {
Stream.of(coll)
.flatMap(x -> x.stream())
.forEach(System.out::print);
System.out.println();
}
private static void withoutFlatMap(Collection<?> coll) {
Stream.of(coll)
.filter(x -> !x.isEmpty())
.map(x -> x)
.forEach(System.out::print);
System.out.println();
}
A. withFlatMap(list); withoutFlatMap(list);
B. withFlatMap(queue); withoutFlatMap(queue);
C. Both pairs disprove the claim.
D. Neither pair disproves this claim.

|
1_ If a try, a catch, and a finally statement are used together but no exception is generated,
which blocks are executed and in which order?
A. try
B. try, catch
C. try, catch, finally
D. try, finally
|
2_ Fill in the blanks: A try statement a catch or a finally block, while a
try-with-resources statement .
A. is not required to contain, is not required to contain either
B. is not required to contain, must contain one of them
C. must contain, is not required to contain either
D. must contain, must contain a catch block
|
3_ What is the output of the following application?
package park;
class LostBallException extends Exception {}
public class Ball {
public void toss() throw LostBallException {
throw new ArrayStoreException();
}
public static void main(String[] bouncy) {
try {
new Ball().toss();
} catch (Throwable e) {
System.out.print("Caught!");
}
}
}
A. Caught!
B. The code does not compile because LostBallException is not handled or declared in
the main() method.
C. The code does not compile because ArrayStoreException is not handled or declared
in the toss() method.
D. The code does not compile for a different reason.
|
4_ Which symbol(s) can be used to separate exception types in a multi-catch statement?
I. &
II. |
III. ||

A. II only
B. III only
C. II and III
D. I, II, and III
|
5_ What is the result of executing the following application with assertions enabled?
1: package ice;
2: public class Igloo {
3: public static void main(String[] bricks) {
4: int flakes = 10;
5: double assert = 7.0;
6: assert (true :"");
7: assert flakes++>5;
8: }
9: }
A. It throws an AssertionError at runtime.
B. It prints nothing at runtime.
C. Exactly one line of code does not compile.
D. Two lines of code do not compile.
|
6_ Which of the following classes is a checked exception?
A. java.lang.Error
B. java.lang.IllegalStateException
C. java.text.ParseException
D. java.lang.RuntimeException
|
7_ How many constructors in WhaleSharkException compile in the following class?
package friendly;
public class WhaleSharkException extends Exception {
public WhaleSharkException() {
super("Friendly shark!");
}
public WhaleSharkException(String message) {
super(new Exception(new WhaleSharkException()));
}
public WhaleSharkException(Exception cause) {}
}
A. None
B. One
C. Two
D. Three

|
8_ Given the following class diagram, which two classes are missing in the hierarchy starting
with the bottom and going upward?
Error
UnsupportedOperationException
?
?
Throwable
A. IOException, Exception
B. RuntimeException, Exception
C. IllegalArgumentException, RuntimeException
D. IllegalStateException, RuntimeException
|
9_ How many lines of text does the following program print?
package lighting;
import java.io.IOException;
public class Light {
public void turnOn() throws IOException {
new IOException("Not ready");
}
public static void main(String[] b) throws Exception {
try {
new Light().turnOn();
} catch (RuntimeException b) { // y1
System.out.println(b);
throw new IOException(); // y2
} finally {
System.out.println("complete");
}
}
}
A. One
B. Two
C. The code does not compile because of line y1.
D. The code does not compile because of line y2.

|
10_ Which statement, when inserted into the main() method of a program, guarantees an
AssertionError will be thrown at runtime?
A. assert(0,"Invalid");
B. assert 0==1;
C. assert 0==0;
D. None of the above
|
11_ What is the output of the following application?
package paper;
import java.io.Closeable;
public class PrintCompany {
class Printer implements Closeable { // r1
public void print() {
System.out.println("This just in!");
}
public void close() {}
}
public void printHeadlines() {
try {Printer p = new Printer()} { // r2
p.print();
}
}
public static void main(String[] headlines) {
new PrintCompany().printHeadlines(); // r3
}
}
A. This just in!
B. The code does not compile because of line r1.
C. The code does not compile because of line r2.
D. The code does not compile because of line r3.
|
12_ Which statement about try-with-resources is not true?
A. If the try block and close() method both throw an exception, the one thrown by the
close() method is suppressed.
B. A catch block is not required.
C. If more than one resource is used, the resources are closed in the order they were
created.
D. Parentheses are used for the resource declaration section, even if more than one
resource is used.

|
13_ How many lines of text does the following program print?
package bee;
class SpellingException extends RuntimeException {}
public class SpellChecker {
public final static void main(String... participants) {
try {
if(!"cat".equals("kat")) {
new SpellingException();
}
} catch (SpellingException | NullPointerException e) {
System.out.println("Spelling problem!");
} catch (Exception e) {
System.out.println("Unknown Problem!");
} finally {
System.out.println("Done!");
}
}
}
A. One
B. Two
C. Three
D. The code does not compile.
|
14_ Which exception classes, when inserted into the blank in the Problems class, allow the
code to compile?
package more;
class MissingMoneyException extends Exception {}
class MissingFoodException extends Exception {}
public class Problems {
public void doIHaveAProblem() throws MissingMoneyException,
MissingFoodException {
System.out.println("No problems");
}
public static void main(String[] lots) throws {
try {
final Problems p = new Problems();
p.doIHaveAProblem();
} catch (Exception e) {

throw e;
}
}
}
I. Exception
II. MissingMoneyException
III. MissingMoneyException, MissingFoodException
A. I only
B. III only
C. I and III
D. I, II, and II
|
15_ Which statement about Closeable and AutoCloseable is true?
A. AutoCloseable extends Closeable.
B. The close() method in a class that implements AutoCloseable cannot throw an
IOException.
C. The close() method in a class that implements Closeable cannot throw an
Exception.
D. There is no difference; one was added for backward compatibility.
|
16_ Which expression, when inserted into the blank in the following class, allows the code to
compile?
package sun;
import java.io.*;
public class Beach {
class TideException extends Exception {}
public void surf() throws RuntimeException {
try {
throw new TideException();
} catch ( ) {}
}
}
A. Exception a | RuntimeException f
B. IllegalStateException | TideException t
C. TideException | IOException i
D. TideException | Exception x

|
17_ Which statement about a multi-catch statement is true?
A. The exception types must be ordered from broadest to narrowest.
B. The exception types must be ordered from narrowest to broadest.
C. The variable of a multi-catch block with more than one exception cannot be reassigned
within the block.
D. The variable of a multi-catch block with one exception type cannot be reassigned within
the block.
|
18_ Given the following class, how many lines contain compilation errors?
package move;
interface Closing {
void close() throws Exception;
}
class Shelf implements Closing {
public void close() throws Exception {}
}
public class Step {
static {
try (Shelf shelf = new Shelf()) {
throws new IllegalArgumentException();
} catch (Exception e) {
} catch (IllegalArgumentException e) {
} finally {
shelf.close();
}
}
}
A. None
B. Two
C. Three
D. Four
|
19_ Which of the following is not true of using a try-with-resources statement?
A. Associated catch blocks are run before the declared resources have been closed.
B. It is compatible with all classes that implement the AutoCloseable interface.
C. It is compatible with all classes that implement the Closeable interface.
D. It shortens the amount of code a developer must write.

|
20_ Assuming the following application is executed with assertions enabled, what is the result?
package input;
public class DataIntegrity {
private int score;
public DataIntegrity() {
super();
DataIntegrity.this.score = 5;
}
public static void main(String[] books) {
final DataIntegrity johnny5 = new DataIntegrity();
assert(johnny5.score>2) : johnny5.score++;
assert johnny5.score>=5 : System.out.print("No input");
System.out.print("Made it!");
}
}
A. An AssertionError is thrown with a message of 5.
B. An AssertionError is thrown with a message of No input.
C. Made it! is printed.
D. The code does not compile.
|
21_ Which of the following classes is an unchecked exception?
A. java.io.IOException
B. java.io.NotSerializableException
C. java.sql.SQLException
D. java.util.MissingResourceException
|
22_ What is the result of compiling and executing the following class?
package wind;
public class Storm {
public static void main(String... rain) throws Exception {
try (final AutoCloseable weatherTracker = new AutoCloseable() {
public void close() throws RuntimeException {}
}) {
System.out.println(weatherTracker.toString());
} catch (Exception e) {
if(weatherTracker != null) {
weatherTracker.close();
}

} finally {
System.out.println("Storm gone");
}
}
}
A. It prints one line.
B. It prints two lines.
C. It does not compile due to an error in the declaration of the weatherTracker resource.
D. It does not compile for a different reason.
|
23_ Which of the following is not a command that enables or disables assertions at runtime?
A. -di
B. -disableassertions
C. -ea
D. -enableassertions
|
24_ What is the output of the following application?
package signlanguage;
import java.io.Closeable;
class ReadSign implements Closeable {
public void close() {}
public String get() {return "Hello";}
}
class MakeSign implements AutoCloseable {
public void close() {}
public void send(String message) {
System.out.print(message);
}
}
public class Translate {
public static void main(String... hands) {
try (ReadSign r = new ReadSign();
MakeSign w = new MakeSign();) {
w.send(r.get());
}
}
}
A. Hello
B. The code does not compile because of the ReadSign class.
C. The code does not compile because of the try-with-resources statement.
D. None of the above

|
25_ What is the output of the following application?
package what;
class FunEvent implements AutoCloseable {
public void close() {
System.out.print("1");
}
}
public class Happening {
public static void main(String... lots) {
try (FunEvent f = new FunEvent()) {
System.out.print("2");
throw new ArithmeticException();
} catch (Exception e) {
System.out.print("3");
} finally {
System.out.print("4");
}
}
}
A. 214
B. 2134
C. 2314
D. The code does not compile.
|
26_ Which statement best describes how a class that implements the AutoCloseable interface
should be written?
A. The close() method is optional since the AutoCloseable interface defines a default
implementation.
B. The close() method should avoid modifying data after it has been run once.
C. The close() method should not throw any exceptions.
D. The close() method should return a status code.
|
27_ Which statement about the following program is correct?
package dogpark;
public class Fetch {
public int play(String dogName) throws Exception {
try {
throw new RuntimeException(dogName);
} catch (Exception e) {
throw new RuntimeException(e);
}

}
public static final void main(String[] ball) throws RuntimeException {
new Fetch().play("Webby");
new Fetch().play("Georgette");
}
}
A. The program prints one exception at runtime.
B. The program prints two exceptions at runtime.
C. The class does not compile because of the play() method.
D. The class does not compile because of the main() method.
|
28_ Which of the following is not a good use of assertions?
A. Check method post conditions.
B. Modify local variables.
C. Test control flow invariants.
D. Validate class invariants.
|
29_ Which statement about the following application is correct?
package highway;
import java.io.*;
class CarCrash extends RuntimeException {}
public class Car {
public static void main(String[] seatbelts) throws Exception { // w1
try {
throw new IOException("Auto-pilot error");
} catch (Exception | CarCrash e) { // w2
throw e;
} catch (Exception a) { // w3
throw a;
}
}
}
A. The code does not compile because of line w1.
B. The code does not compile because of line w2.
C. The code does not compile because of line w3.
D. The code compiles and runs without issue.

|
30_ Which statements about the following classes are true?
public class Dopey extends Grumpy {}
public class Grumpy extends Exception {}
public class Happy extends IOException {}
public class Sleepy extends IllegalStateException {}
public class Sneezy extends Throwable {}
I. Four of the classes are checked exceptions.
II. Two of the classes are unchecked exceptions.
III. None of the class declarations contain any compilation errors.
A. I only
B. I and III
C. II and III
D. I, II, and III
|
31_ What is the output of the following application?
package vortex;
class TimeException extends Exception {}
class TimeMachine implements AutoCloseable {
int v;
public TimeMachine(int v) {this.v = v;}
public void close() throws Exception {
System.out.print(v);
}
}
public class TimeTraveler {
public static void main(String[] twelve) {
try (TimeMachine timeSled = new TimeMachine(1);
TimeMachine delorean = new TimeMachine(2);
TimeMachine tardis = new TimeMachine(3)) {
} catch (TimeException e) {
System.out.print(4);
} finally {
System.out.print(5);
}
}
}
A. 1235
B. 3215
C. 41235
D. The code does not compile.

|
32_ Which expression, when inserted into the blank in the following class, allows the code to
compile?
package music;
public class Bells {
class Player implements AutoCloseable {
@Override public void close() throws RingException {}
}
class RingException extends Exception {
public RingException(String message) {}
}
public static void main(String[] notes) throws Throwable {
try (Player p = null) {
throw new Exception();
} catch (Exception e) {
} catch ( ) {
}
}
}
A. Error r
B. IllegalStateException b
C. RingException p
D. The code does not compile regardless of the expression used.
|
33_ Given the following two variables, which assertion statement compiles successfully?
int age = 22;
final String name = "Josephine";
A. assert (age=2);
B. assert age!=age : (1<age ? "Error" : 10);
C. assert name.equals("") : () -> "Oops";
D. assert name.length()<(long)age : return "Mistake";
|
34_ Which statement about the following program is true?
package tag;
class MissedCallException extends Exception {}
public class Phone {
static void makeCall() throws RuntimeException {
throw new ArrayIndexOutOfBoundsException("Call");
}
public static void main(String[] messages) {

try {
makeCall();
} catch (MissedCallException e) {
throw new RuntimeException("Voicemail");
} finally {
throw new RuntimeException("Text");
}
}
}
A. An exception is printed at runtime with Call in the message.
B. An exception is printed at runtime with Voicemail in the message.
C. An exception is printed at runtime with Text in the message.
D. The code does not compile.
|
35_ Which statement about the following program is correct?
package fairy;
public class Tale {
class BearException extends RuntimeException {}
class WolfException extends RuntimeException {}
class DragonException extends RuntimeException {}
public int tellStory() {
try {} catch (BearException d) {
d = new RuntimeException();
throw d;
} catch (WolfException | DragonException e) {
e = new RuntimeException();
throw e;
}
return 3;
}
public static void main(String... wand) throws RuntimeException{
new Tale().tellStory();
}
}
A. The class compiles and does not print anything at runtime.
B. The code does not compile solely due to the first catch block in tellStory().
C. The code does not compile solely due to the second catch block in tellStory().
D. The code does not compile due to errors in both catch blocks in tellStory().

|
36_ What is the output of the following application?
package classical;
import java.io.*;
class OutOfTuneException extends Exception {
OutOfTuneException(String message) { super(message); }
}
public class Piano {
public void play() throws OutOfTuneException, FileNotFoundException {
throw new OutOfTuneException("Sour note!");
}
public static void main(String... keys) throws OutOfTuneException {
final Piano piano = new Piano();
try {
piano.play();
} catch (Exception e) {
throw e;
} finally {
System.out.println("Song finished!");
}
}
}
A. Song finished!
B. An exception is printed with Sour note! in the stack trace.
C. Both of the above
D. None of the above
|
37_ Given the following class, which command causes the class to throw an AssertionError at
runtime?
public class Falcon extends Exception {
private int parsec = 12;
public Falcon(String name) {
super(name);
}
public static void main(String[] aluminum) {
assert new Falcon(null).parsec<12;
}
}
A. java Falcon
B. java -ea -da:Falcon Falcon
C. java -da -ea:Falcon Falcon
D. The code does not compile.

|
38_ What is the output of the following application?
package db;
import java.io.*;
import java.sql.*;
public class DatabaseHelper {
static class MyDatabase implements Closeable {
public void close() throws SQLException {
System.out.print("2");
}
public void write(String data) {}
public String read() {return null;}
}
public static void main(String... files) throws Exception {
try (MyDatabase myDb = new MyDatabase()) {
// TODO: Decide what to read/rite
} finally {
System.out.print("1");
}
}
}
A. 12
B. 21
C. The code does not compile because of the MyDatabase class.
D. The code does not compile because of the try-with-resources statement.
|
39_ How many lines of text does the following program print?
package tron;
class DiskPlayer implements AutoCloseable {
public void close() throws Exception {}
}
public class LightCycle {
public static void main(String... bits) {
try (DiskPlayer john = new DiskPlayer()) {
System.out.println("ping");
} finally {
System.out.println("pong");
}

System.out.println("return");
}
}
A. One
B. Two
C. Three
D. The code does not compile.
|
40_ Given the application below, what is the name of the class printed at line e1?
package canyon;
final class FallenException extends Exception {}
final class HikingGear implements AutoCloseable {
@Override public void close() throws Exception {
throw new FallenException();
}
}
public class Cliff {
public final void climb() throws Exception {
try (HikingGear gear = new HikingGear()) {
throw new RuntimeException();
}
}
public static void main(String... rocks) {
try {
new Cliff().climb();
} catch (Throwable t) {
System.out.println(t); // e1
}
}
}
A. canyon.FallenException
B. java.lang.RuntimeException
C. The code does not compile.
D. The code compiles, but the answer cannot be determined until runtime.

|
1_ What package is the LocalTime class in?
A. java.date
B. java.lang
C. java.time
D. java.util
|
2_ How many of the classes Duration, LocalDateTime, and LocalTime have the concept of a
time zone?
A. None
B. One
C. Two
D. Three
|
3_ Which class has a getSeconds() method?
A. Only the Duration class
B. Only the Period class
C. Both the Duration and Period classes
D. Neither class
|
4_ Which of these represents the earliest date/time?
A. 2017-02-15T03:00+01:00[Europe/Berlin]
B. 2017-02-15T04:00+02:00[Europe/Helsinki]
C. 2017-02-15T05:00+01:00[Europe/Warsaw]
D. None of the above. We have a tie.
|
5_ Most of the United States observes daylight savings time on March 12, 2017, by moving the
clocks forward an hour at 2 a.m. What does the following code output?
LocalDate localDate = LocalDate.of(2017, 3, 12);
LocalTime localTime = LocalTime.of(1, 0);
ZoneId zone = ZoneId.of("America/New_York");
ZonedDateTime z = ZonedDateTime.of(localDate, localTime, zone);
Duration duration = Duration.ofHours(3);
ZonedDateTime later = z.plus(duration);
System.out.println(later.getHour());
A. 4
B. 5
C. 6
D. None of the above

|
6_ What does the following output?
int year = 1874;
int month = Month.MARCH;
int day = 24;
LocalDate date = LocalDate.of(year, month, day);
System.out.println(date.isBefore(LocalDate.now()));
A. false
B. true
C. The code does not compile.
D. The code compiles but throws an exception at runtime.
|
7_ Which correctly fills in the blank to print 2017-01-15?
LocalDate hatDay = LocalDate.of(2017, Month.JANUARY, 15);
DateTimeFormatter f = DateTimeFormatter.ISO_DATE;
System.out.println( );
I. f.format(hatDay)
II. f.formatDate(hatDay)
III. hatDay.format(f)
A. I
B. III
C. I and III
D. II and III
|
8_ Which of the answer choices is true given the following?
2017-01-07T10:00-07:00[America/Phoenix]
2017-01-07T08:00-08:00[America/Vancouver]
A. The first date/time is one hour earlier than the second.
B. The first date/time is three hours earlier than the second.
C. The first date/time is one hour later than the second.
D. The first date/time is three hours later than the second.
|
9_ Given that daylight savings time starts on March 12, 2017, at 2 a.m. and clocks jump from
1:59 a.m. to 03:00 a.m., which of the following can fill in the blank so the code doesn’t
throw an exception?
LocalDate localDate = LocalDate.of(2017, 3, 12);
LocalTime localTime = LocalTime.of( );
ZoneId zone = ZoneId.of("America/New_York");
ZonedDateTime z = ZonedDateTime.of(localDate, localTime, zone);

A. 2, 0
B. 3, 0
C. Either of the above will run without throwing an exception.
D. Both of these will cause an exception to be thrown.
|
10_ What is the result of the following?
11: LocalDate waffleDay = LocalDate.of(2017, Month.MARCH, 25);
12: Period period = Period.of(1, 6, 3);
13: LocalDate later = waffleDay.plus(period);
14: later.plusDays(1);
15: LocalDate thisOne = LocalDate.of(2018, Month.SEPTEMBER, 28);
16: LocalDate thatOne = LocalDate.of(2018, Month.SEPTEMBER, 29);
17: System.out.println(later.isBefore(thisOne) + " "
18: + later.isBefore(thatOne));
A. false false
B. false true
C. true true
D. The code does not compile.
|
11_ What is a possible result of the following?
LocalDate montyPythonDay = LocalDate.of(2017, Month.MAY, 10);
LocalDate aprilFools = LocalDate.of(2018, Month.APRIL, 1);
Duration duration = Duration.ofDays(1);
LocalDate result = montyPythonDay.minus(duration);
System.out.println(result + " " + aprilFools.isBefore(result));
A. 2017-05-09 false
B. 2017-05-09 true
C. The code does not compile.
D. None of the above
|
12_ What is the result of running this code?
12: LocalDate pieDay = LocalDate.of(2017, Month.JANUARY, 23);
13: LocalTime midnight = LocalTime.of(0, 0);
14: LocalDateTime pieTime = LocalDateTime.of(pieDay, midnight);
15:
16: DateTimeFormatter f = DateTimeFormatter
17: .ofLocalizedDate(FormatStyle.SHORT);
18: f.format(pieDay);
19: f.format(pieTime);
20: f.format(midnight);

A. The code runs successfully.
B. The code throws an exception on line 19.
C. The code throws an exception on line 20.
D. The code does not compile.
|
13_ In the United States, daylight savings time ends on November 5th, 2017 at 02:00 a.m. and
we repeat the previous hour. What is the output of the following?
import java.time.*;
public class FallBack {
public static void main(String[] args) {
LocalDate localDate = LocalDate.of(2017, Month.NOVEMBER, 5);
LocalTime localTime = LocalTime.of(1, 0);
ZoneId zone = ZoneId.of("America/New_York");
ZonedDateTime z = ZonedDateTime.of(localDate, localTime, zone);
for (int i = 0; i < 6; i++)
z.plusHours(1);
System.out.println(z.getHour());
}
}
A. 5
B. 6
C. 7
D. None of the above
|
14_ What format pattern would you pass to a DateTimeFormatter so it creates hour and minute
output such as 02:33?
A. HH:MM
B. HH:mm
C. hh:MM
D. hh:mm
|
15_ LocalTime.of() has a number of overloads. Which of the following is not one of them?
A. LocalTime.of(int hour, int minute)
B. LocalTime.of(int hour, int minute, int second)
C. LocalTime.of(int hour, int minute, int second, int nanoOfSecond)
D. LocalTime.of(int hour, int minute, int second, int nanoOfSecond,
int picoSeconds)

|
16_ How many of the classes LocalDate, Period, and ZonedDate have a method to get
the year?
A. None
B. One
C. Two
D. Three
|
17_ Which statement is not true about these two variables?
Duration duration = Duration.ofDays(1);
Period period = Period.ofDays(1);
A. Both output the same value when calling toString().
B. The Duration object compiles because durations are for smaller units of time.
C. The Period object compiles because periods are for larger units of time.
D. None of the above
|
18_ What is a possible output of this code?
LocalTime time = LocalTime.of(1,2,3,4);
System.out.println(time);
A. 01:02:03.4
B. 01:02:03.000000004
C. 01/01/1970 01:02:03.4
D. 01/01/1970 01:02:03.000000004
|
19_ What does the following print?
import java.time.*;
import java.time.format.*;
public class PolarBear {
public static void main(String[] args) {
LocalDate polarBearDay = LocalDate.of(2017, 2, 27);
DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy dd MMM");
System.out.println(polarBearDay.format(formatter));
}
}
A. 2017 27 Jan
B. 2017 27 Feb
C. 2017 Jan 27
D. 2017 Feb 27

|
20_ Which contains a constant named HOURS?
A. ChronoUnit
B. Duration
C. Instant
D. Period
|
21_ The United States observes daylight savings time on March 12, 2017, by moving the clocks
forward an hour at 2 a.m. What does the following code output?
LocalDate localDate = LocalDate.of(2017, 3, 12);
LocalTime localTime = LocalTime.of(13, 0);
ZoneId zone = ZoneId.of("America/New_York");
ZonedDateTime z = ZonedDateTime.of(localDate, localTime, zone);
Duration duration = Duration.ofHours(3);
ZonedDateTime later = z.plus(duration);
System.out.println(later.getHour());
A. 13
B. 16
C. 17
D. None of the above
|
22_ What is a possible result of the following?
LocalDate montyPythonDay = LocalDate.of(2017, Month.MAY, 10);
LocalTime time = LocalTime.of(5, 40);
LocalDateTime dateTime = LocalDateTime.of(montyPythonDay, time);
Duration duration = Duration.ofDays(1);
LocalDateTime result = dateTime.minus(duration);
System.out.println(result);
A. 2017-05-09
B. 2017-05-09T05:40
C. 2017-05-10T05:40
D. None of the above
|
23_ Which correctly fills in the blank to print 2017-01-15?
LocalDate hatDay = LocalDate.of(2017, Month.JANUARY, 15);
DateFormatter f = DateFormatter.ISO_DATE;
System.out.println( );
A. f.format(hatDate)
B. hatDay.format(f)
C. Both of the above
D. Neither of the above

|
24_ LocalDateTime.of() has a number of overloads. Which of the following is not one
of them?
A. LocalDateTime.of(LocalDate date, LocalTime time)
B. LocalDateTime.of(LocalDate date, int hour, int minute)
C. LocalDateTime.of(int year, int month, int day, int hour, int minute)
D. LocalDateTime.of(int year, Month month, int day, int hour, int minute)
|
25_ In the United States, daylight savings time for 2017 starts at 2 a.m. on March 12th and
ends at 2 a.m. on November 5th. Given the sequence in the following image, what time
comes next on March 12th, July 4th, and November 5th, respectively?
1:58 1:59 ?
A. 01:00, 02:00, 01:00
B. 01:00, 02:00, 03:00
C. 03:00, 02:00, 01:00
D. 03:00, 02:00, 03:00
|
26_ What is the output of the following?
LocalDate date1 = LocalDate.of(2017, Month.MARCH, 3);
LocalDate date2 = LocalDate.of(2017, Month.FEBRUARY, 31);
System.out.println(date1.equals(date2));
A. false
B. true
C. The code does not compile.
D. The code compiles but throws an exception at runtime.
|
27_ Given this date/time and time zone offset, what time is it in GMT?
2017-03-09T16:00-10:00[US/Hawaii]
A. 02:00
B. 04:00
C. 06:00
D. 10:00
|
28_ What is a possible output of the following?
LocalDate trainDay = LocalDate.of(2017, 5, 13);
LocalTime time = LocalTime.of(10, 0);
ZoneId zone = ZoneId.of("America/Los_Angeles");

ZonedDateTime zdt = ZonedDateTime.of(trainDay, time, zone);
Instant instant = zdt.toInstant();
instant = instant.plus(1, ChronoUnit.DAYS);
System.out.println(instant);
A. 2017-05-13T10:00-07:00[America/Los_Angeles]
B. 2017-05-13T17:00:00Z
C. 2017-05-14T10:00-07:00[America/Los_Angeles]
D. 2017-05-14T17:00:00Z
|
29_ What is the output of the following?
LocalDate date = LocalDate.of(2017, Month.JULY, 17);
LocalTime time = LocalTime.of(10, 0);
ZoneId zone = ZoneId.of("America/New_York");
ZonedDateTime iceCreamDay = ZonedDateTime.of(date, time, zone);
time = time.plusMonths(1);
System.out.println(iceCreamDay.getMonthValue());
A. 6
B. 7
C. 8
D. The code does not compile.
|
30_ What does the following print?
import java.time.*;
import java.time.format.*;
public class PolarBear {
public static void main(String[] args) {
LocalDate polarBearDay = LocalDate.of(2017, 2, 27);
DateTimeFormatter formatter = DateTimeFormatter
.ofPattern("Holiday: yyyy dd MMM");
System.out.println(polarBearDay.format(formatter));
}
}
A. Holiday: 2017 27 Jan
B. Holiday: 2017 27 Feb
C. The code does not compile.
D. The code compiles but throws an exception at runtime.

|
31_ Which of these represents the earliest date/time?
A. 2017-02-15T16:00+07:00[Asia/Bangkok]
B. 2017-02-15T18:00+04:00[Asia/Dubai]
C. 2017-02-15T20:00+08:00[Asia/Kuala_Lumpur]
D. None of the above. We have a tie.
|
32_ What is the result of the following?
11: LocalDate waffleDay = LocalDate.of(2017, Month.MARCH, 25);
12: Period period = Period.ofYears(1).ofMonths(6).ofDays(3);
13: LocalDate later = waffleDay.plus(period);
14: later.plusDays(1);
15: LocalDate thisOne = LocalDate.of(2018, Month.SEPTEMBER, 28);
16: LocalDate thatOne = LocalDate.of(2018, Month.SEPTEMBER, 29);
17: System.out.println(later.isBefore(thisOne) + " "
18: + later.isBefore(thatOne));
A. false false
B. false true
C. true true
D. The code does not compile.
|
33_ How many of the following can fill in the blank so this code compiles and prints 31?
LocalDate xmas = LocalDate.of(2017, 12, 25);
LocalDate blackFriday = LocalDate.of(2017, 11, 24);
long shoppingDaysLeft = ;
System.out.println(shoppingDaysLeft);
I. blackFriday.until(xmas, ChronoUnit.DAYS)
II. blackFriday.until(xmas, TemporalUnit.DAYS)
III. ChronoUnit.DAYS.between(blackFriday, xmas)
IV. TemporalUnit.DAYS.between(blackFriday, xmas)
A. One
B. Two
C. Three
D. Four
|
34_ How many of these classes cause a compiler error when filling in the blank: LocalDate,
LocalDateTime, LocalTime, ZonedDateTime?
private static String formatMe( obj) {
DateTimeFormatter f = DateTimeFormatter.ofLocalizedTime(FormatStyle.MEDIUM);
return f.format(obj);
}

A. None
B. One
C. Two
D. Three
|
35_ What is the output of the following?
LocalDate date = LocalDate.of(2017, Month.JULY, 17);
LocalTime time = LocalTime.of(10, 0);
ZoneId zone = ZoneId.of("America/New_York");
ZonedDateTime iceCreamDay = ZonedDateTime.of(date, time, zone);
date = date.plusMonths(1);
System.out.println(iceCreamDay.getMonthValue());
A. 6
B. 7
C. 8
D. The code does not compile.
|
36_ Which of the following can fill in the blank to make this code compile?
public boolean isItMyBirthday(LocalDateTime dateTime) {
return now.getMonth() == dateTime.getMonth()
&& now.getDayOfMonth() == dateTime.getDayOfMonth();
}
A. LocalDate now = LocalDate.now();
B. LocalDate now = new LocalDate();
C. ZonedDate now = ZonedDate.now();
D. ZonedDate now = new ZonedDate();
|
37_ What is the output of the following?
LocalDate date1 = LocalDate.of(2017, Month.MARCH, 3);
LocalDate date2 = date1.plusDays(2).minusDays(1).minusDays(1);
System.out.println(date1.equals(date2));
A. false
B. true
C. The code does not compile.
D. The code compiles but throws an exception at runtime.

|
38_ What is a possible output of the following?
LocalDate date = LocalDate.of(2017, 5, 13);
LocalTime time = LocalTime.of(10, 0);
LocalDateTime trainDay = LocalDateTime.of(date, time);
Instant instant = trainDay.toInstant();
instant = instant.plus(1, ChronoUnit.DAYS);
System.out.println(instant);
A. 2017-05-14T10:00-07:00[America/Los_Angeles]
B. 2017-05-14T17:00:00Z
C. The code does not compile.
D. The code compiles but throws an exception at runtime.
|
39_ What is the result of the following?
public class PiDay {
public static void main(String[] args) {
LocalDateTime pi = LocalDateTime.of(2017, 3, 14, 1, 59);
DateTimeFormatter formatter = DateTimeFormatter
.ofPattern("M.ddhhmm");
System.out.println(formatter.format(pi));
}
}
A. 3.140159
B. 59.140103
C. The code does not compile.
D. The code compiles but throws an exception at runtime.
|
40_ Daylight savings time ends on November 5, 2017 at 2 a.m. when we repeat the hour.
Suppose
we have a ZonedDateTime that outputs 2017-11-05T01:00-04:00[America/
New_York] when calling toString(). What is a possible value of the ZonedDateTime
obtained by adding an hour to this value?
A. 2017-11-05T01:00-04:00[America/New_York]
B. 2017-11-05T02:00-04:00[America/New_York]
C. 2017-11-05T01:00-05:00[America/New_York]
D. 2017-11-05T02:00-05:00[America/New_York]

|
1_ Fill in the blanks: Writer is that related stream classes .
A. a concrete class, extend
B. an abstract class, extend
C. an interface, extend
D. an interface, implement
|
2_ Which of the following methods is defined in java.io.File?
A. createDirectory()
B. getLength()
C. listFile()
D. renameTo()
|
3_ Which method in InputStream can be used in place of calling skip(1)?
A. jump()
B. mark()
C. read()
D. reset()
|
4_ Which methods are classes that implement java.io.Serializable required to implement?
A. deserialize()
B. serial()
C. serialize()
D. None of the above
|
5_ Fill in the blanks: Given a valid Console instance, reader() returns a ,
while writer() returns a .
A. PrintReader, PrintWriter
B. PrintReader, Writer
C. Reader, Writer
D. StringReader, Writer
|
6_ Assuming the file path referenced in the following class is accessible and able to be written,
what is the output of the following program?
package alarm;
import java.io.*;
public class Smoke {
public void sendAlert(File fn) {
try(BufferedWriter w = new BufferedWriter(new FileOutputStream(fn))) {
w.write("ALERT!");
w.flush();
w.write('!');

System.out.print("1");
} catch (IOException e) {
System.out.print("2");
} finally {
System.out.print("3");
}
}
public static void main(String[] testSignal) {
new Smoke().sendAlert(new File("alarm.txt"));
}
}
A. 3
B. 13
C. 23
D. The code does not compile.
|
7_ Which class is used to read information about a directory within the file system?
A. java.io.File
B. java.io.Directories
C. java.io.Directory
D. java.io.Path
|
8_ Which of the following is a high-level stream class that can only be used to wrap a
low-level stream?
A. FileOutputStream
B. FileReader
C. ObjectInputStream
D. PrintWriter
|
9_ Assume the file prime6.txt exists and contains the first six prime numbers as bytes: 2, 3,
5, 7, 11, |
13_ What is the output of the following application?
package numbers;
import java.io.*;
public class PrimeReader {
public static void main(String[] real) throws Exception {
try (InputStream is = new FileInputStream("prime6.txt")) {
is.skip(1);
is.read();
is.skip(1);
is.read();

is.mark(4);
is.skip(1);
is.reset();
System.out.print(is.read());
}
}
}
A. 11
B. 13
C. The code does not compile.
D. The code compiles but throws an exception at runtime.
|
10_ Fill in the blanks: For a given file, the absolute is the path from the to the
file, while the relative path is the path from the to the file.
A. current directory, current working directory
B. parent directory, temporary directory
C. root directory, current working directory
D. root directory, parent directory
|
11_ Which statement best describes the following two methods?
public void writeSecret1() throws IOException {
final Writer w = new BufferedWriter(
new FileWriter("dont.open"));
w.write("Secret passcode");
w.close();
}
public void writeSecret2() throws IOException {
try(final Writer w = new BufferedWriter(
new FileWriter("dont.open"))) {
w.write("Secret passcode");
}
}
A. Both methods compile and are equivalent to each other.
B. Neither method compiles.
C. Only one of the methods compiles.
D. The methods compile, but one method may lead to a resource leak.

|
12_ What is the result of compiling and executing the following program?
package vacation;
import java.io.*;
import java.util.*;
public class Itinerary {
private List<String> activities = new ArrayList<>();
private static Itinerary getItinerary(String name) {
return null;
}
public static void printItinerary() throws Exception {
Console c = new Console();
final String name = c.readLine("What is your name?");
final Itinerary stuff = getItinerary(name);
stuff.activities.forEach(s -> c.printf(s));
}
public static void main(String[] holidays) throws Exception {
printItinerary();
}
}
A. The code does not compile.
B. The code compiles and prints a NullPointerException at runtime.
C. The code compiles but does not print anything at runtime.
D. None of the above
|
13_ Given the following diagram, which two classes can be placed in the blank boxes?
OutputStream
FilterOutputStream
A. BufferedOutputStream and PrintStream
B. BufferedOutputStream and PrintOutputStream
C. ByteArrayOutputStream and Stream
D. FileOutputStream and OutputStream

|
14_ Let’s say we want to write an instance of Cereal to disk, having a name value of
CornLoops.
What is the value of name after this object has been read using the
ObjectInputStream’s
readObject() method?
package breakfast;
public class Cereal {
private String name = "CocoaCookies";
private transient int sugar;
public Cereal() {
super();
this.name = "CaptainPebbles";
}
{
name = "SugarPops";
}
public String getName() { return name; }
public void setName(String name) {
this.name = name;
}
public int getSugar() { return sugar; }
public void setSugar(int sugar) {
this.sugar = sugar;
}
}
A. CaptainPebbles
B. CornLoops
C. SugarPops
D. None of the above
|
15_ Which statement best describes the difference between a Writer and an OutputStream class?
A. Only one of them can write text or character data.
B. Only one of them has built-in methods for writing character data.
C. Only one of them has a flush() method to force the data to be written out.
D. One uses a byte array to process character data more efficiently.
|
16_ What is the output of the following application? It is safe to assume the directories referenced
in the class do not exist prior to the execution of the program and that the file system
is available and able to be written.
package job;
import java.io.*;
public class Resume {

public void resetWorkingDirectory() throws Exception {
File f1 = new File("/templates/proofs");
f1.mkdirs();
File f2 = new File("/templates");
f2.mkdir(); // k1
new File(f2,"draft.doc").createNewFile();
f1.delete();
f2.delete(); // k2
}
public static void main(String... leads) {
try {
new Resume().resetWorkingDirectory();
} catch (Exception e) {
new RuntimeException(e);
}
}
}
A. Line k1 does not compile or triggers an exception at runtime.
B. Line k2 does not compile or triggers an exception at runtime.
C. The code compiles and runs without printing an exception.
D. None of the above
|
17_ Given the following class, three of the values ensure it runs properly on various different
systems. Which value does not?
package magic;
import java.io.*;
public class Store {
private final String directory;
public Store(String directory) {
this.directory = directory;
}
public File getDatabaseFolder(String file) {
return new File(directory + + file);
}
}
A. java.io.File.separator
B. new File(new String()).separatorChar
C. System.getProperty("file.separator")
D. System.getProperty("path.separator")

|
18_ How many compilation errors does the following class contain?
package hero;
import java.io.*;
public class Guitar {
public void readMusic(File f) {
try (BufferedReader r = new BufferedReader(FileReader(f))) {
final String music = null;
try {
while((music = r.readLine()) != null)
System.out.println(music);
} catch (IOException e) {}
} catch (FileNotFoundException e) {
throw new RuntimeException(e);
} finally {}
}}
A. None
B. One
C. Two
D. Three
|
19_ What is the difference between the two Console methods, format() and printf()?
A. One of them takes an optional list of arguments; the other does not.
B. One of them takes String as input; the other takes an Object.
C. There is no difference between the two methods.
D. Trick question! printf() is not defined in Console.
|
20_ Let’s say you want to write a lot of text data to a file in an efficient manner. Which two
java.io stream classes are best to use?
A. FileOutputStream and BufferedOutputStream
B. FileOutputWriter and FileBufferedWriter
C. FileWriter and BufferedWriter
D. ObjectOutputStream and BufferedWriter
|
21_ Assume the file referenced in the StudentManager class exists and contains data. Which
statement about the following class is correct?
package school;
import java.io.*;
class Student implements Serializable {}
public class StudentManager {

public static void main(String[] grades) {
try(ObjectInputStream ios = new ObjectInputStream(
new FileInputStream(new File("C://students.data")))) {
Student record;
while((record = (Student)ios.readObject()) != null) {
System.out.print(record);
}
} catch (EOFException e) {
} catch (Exception e) {
throw new RuntimeException(e);
}
}
}
A. The code does not compile.
B. The code compiles but prints an exception at runtime.
C. The program runs and prints all students in the file.
D. The program runs but may only print some students in the files.
|
22_ Which java.io class does not have a complementary input stream?
A. BufferedOutputStream
B. BufferedWriter
C. FileWriter
D. PrintWriter
|
23_ Assuming the path /Earth does not exist within the file system, what is the output of the
following program?
package center;
import java.io.*;
public class Journey {
public static void main(String[] dig) {
File file = new File("/Earth");
System.out.print(file.getParent()
+" - "
+file.getParent().getParent()); } }
A. / - /
B. / - null
C. The code does not compile.
D. The code compiles but throws an exception at runtime.

|
24_ Which statements about executing the following program are true?
package test;
import java.io.*;
public class Turing {
public static void main(String... robots) {
Console c = System.console();
final String response = c.readLine("Are you human?");
System.err.print(response);
}
}
I. The program may ask the user a question and print the response to the error stream.
II. The program may throw a NullPointerException at runtime.
III. The program may wait indefinitely.
A. I
B. I and III
C. II and III
D. I, II, and III
|
25_ Which of the following statements about the deleteTree() method is correct?
public void deleteTree(File f) {
if(!f.isDirectory())
f.delete();
else {
Stream.of(f.list())
.forEach(s -> deleteTree(s));
f.deleteDirectory();
}
}
A. It compiles and is capable of deleting a directory tree.
B. If one line were modified, it would be capable of deleting a directory tree.
C. If two lines were modified, it would be capable of deleting a directory tree.
D. None of the above
|
26_ Which of the following is not a built-in stream in Java?
A. System.err
B. System.in

C. System.info
D. System.out
|
27_ Assuming the file path referenced in the following class is accessible and able to be written,
what is the output of the following program?
package store;
import java.io.*;
public class Furniture {
public final static void main(String... inventory) throws Exception {
Writer w = new FileWriter("couch.txt");
try (BufferedWriter bw = new BufferedWriter(w)) {
bw.write("Blue coach on Sale!");
} finally {
w.flush();
w.close();
}
System.out.print("Done!");
}
}
A. Done!
B. The code does not compile for one reason.
C. The code does not compile for two reasons.
D. The code compiles but throws an exception at runtime.
|
28_ Given an instance of Console c, which of the following method calls is not a way to read
input from the user?
A. c.reader().read()
B. c.reader().readLine()
C. c.readLine()
D. c.readPassword()
|
29_ The copyPidgin() method is used to copy the contents of one file to another. Which
statement about the implementation is correct?
package birds;
import java.io.*;
public class Pidgin {
public void copyPidgin(File s, File t) throws Exception {
try(InputStream is = new FileInputStream(s);
OutputStream os = new FileOutputStream(t)) {
byte[] data = new byte[123];

int chirps;
while((chirps = is.read(data))>0) {
os.write(data);
}}
}}
A. The class does not compile because read(byte[]) and write(byte[]) can only be
called on BufferedInputStream and BufferOutputStream, respectively.
B. The method correctly copies the contents of all files.
C. The method correctly copies the contents of some files.
D. The method will always throw an exception at runtime because the data array size is
not a power of 2.
|
30_ Using what you know about java.io stream class names, what would a nonexistent class
named BufferedFileReader most likely be used for?
A. Reading a small text file from a remote network
B. Reading an image from disk
C. Reading large text files from a file system
D. Reading serialized data from disk
|
31_ What is the output of the following application?
package factory;
import java.io.*;
public class WidgetProcessor {
public int getWidgetNumber(byte[] data) throws Exception {
try (InputStream is = new ByteArrayInputStream(data)) {
is.read(new byte[2]);
if(!is.markSupported()) return -1;
is.mark(5);
is.read();is.read();
is.skip(3);
is.reset();
return is.read();
}
}
public static void main(String... sprockets) throws Exception {
final WidgetProcessor p = new WidgetProcessor();
System.out.print(p.getWidgetNumber(new byte[] {1,2,3,4,5,6,7}));
}
}

A. 3
B. 5
C. 7
D. An exception is thrown at runtime.
|
32_ Assuming the working directory is accessible, empty, and able to be written, how many file
system objects does the following class create?
1: package kitchen;
2: import java.io.*;
3: public class Bakers {
4: public static void main(String... tooMany) throws IOException {
5: File cake = new File("cake.txt");
6: Writer pie = new FileWriter("pie.txt");
7: pie.flush();
8: new File("fudge.txt").mkdirs();
9: } }
A. None
B. One
C. Two
D. Three
|
33_ Let’s say you wanted to read data from a file stored on disk that consists of String, long,
and Object values? Given that the file is quite large, you intend to use three classes to
achieve this result. Which of the following is not one of the three classes you should use?
A. BufferedInputStream
B. BufferedReader
C. FileInputStream
D. ObjectInputStream
|
34_ Which statement best describes the following two methods?
public String getNameQuick() throws IOException {
final BufferedReader r = new BufferedReader(
new FileReader("saved.name"));
final String name = r.readLine();
r.flush();
return name;
}
public String getNameSafely() throws IOException {
try(final BufferedReader r = new BufferedReader(

new FileReader("saved.name"))) {
final String name = r.readLine();
r.flush();
return name;
}}
A. Both methods compile and are equivalent to each other.
B. Neither method compiles.
C. Only one of the methods compiles.
D. The methods compile, but one method may lead to a resource leak.
|
35_ What is the output of the following application? Assume the System.console() is
available
and the user enters badxbad and presses Enter.
package hardway;
import java.io.*;
public class InconvenientImplementation {
public static void main(String... dontDoThis) throws Exception {
Console c = System.console();
if(c != null) {
c.writer().write('P');
c.writer().write('a');
c.writer().write('s');
c.writer().write('s');
c.writer().flush(); // t1
int i;
StringBuilder sb = new StringBuilder();
while((i = c.reader().read()) != 'x') { // t2
sb.append((char)i);
}
c.writer().format("Result: %s",sb.toString());
}
}
}
A. Result: bad
B. Line t1 does not compile or triggers an exception at runtime.
C. Line t2 does not compile or triggers an exception at runtime.
D. None of the above

|
36_ Why does Console readPassword() return a char array rather than a String?
A. It improves performance.
B. It improves security.
C. Passwords must be stored as a char array.
D. String cannot hold the individual password characters.
|
37_ Which statement about the following program is true?
package mystical;
import java.io.*;
public class Unicorn {
public void findUnicorns() {
try(InputStream o = new ObjectInputStream(readBook())) {
while(o.read() != -1) {
System.out.println(o.read());
}
} catch (Throwable t) {
throw new RuntimeException(t);
}
}
private InputStream readBook() throws IOException {
return new BufferedInputStream(new FileReader("magic.book"));
}
public static void main(String... horn) {
new Unicorn().findUnicorns();
}
}
A. The code does not compile.
B. The program prints every byte in the file without throwing an exception.
C. The program prints every other byte in the file without throwing an exception.
D. The program throws an EOFException when the end of the file is reached.
|
38_ Choose the class that is least likely to be marked Serializable.
A. A class that holds data about the amount of rain that has fallen in a given year
B. A class that manages the memory of running processes in an application
C. A class that stores information about apples in an orchard
D. A class that tracks the amount of candy in a gumball machine

|
39_ What is the output of the following application?
package cell;
import java.io.*;
public class TextMessage {
public String receiveText() throws Exception {
try (Reader r = new FileReader("messages.txt")) {
StringBuilder s = new StringBuilder();
int c;
while((c = r.read()) != -1) {
s.append((char)c);
if(r.markSupported()) {
r.mark(100);
r.skip(10);
r.reset();
}
}
return s.toString();
}
}
public void sendText(String message) throws Exception {
try (Writer w = new FileWriter("messages.txt")) {
for(int i=0; i<message.length(); i++) {
w.write(message.charAt(i));
w.skip(1);
}
}
}
public static void main(String[] minutes) throws Exception {
final TextMessage m = new TextMessage();
m.sendText("You up?");
System.out.println(m.receiveText());
} }
A. You up?
B. Y o u u p ?
C. The code does not compile because of the receiveText() method.
D. The code does not compile because of the sendText() method.

|
40_ What is the output of the following program? Assume the file paths referenced in the class
exist and are able to be written to and read from.
package heart;
import java.io.*;
public class Valve implements Serializable {
private int chambers = -1;
private transient Double size = null;
private static String color;
public Valve() {
this.chambers = 3;
color = "BLUE";
}
public static void main(String[] love) throws Throwable {
try (ObjectOutputStream o = new ObjectOutputStream(
new FileOutputStream("scan.txt"))) {
final Valve v = new Valve();
v.chambers = 2;
v.size = 10.0;
v.color = "RED";
o.writeObject(v);
}
new Valve();
try (ObjectInputStream o = new ObjectInputStream(
new FileInputStream("scan.txt"))) {
Valve v = (Valve)o.readObject();
System.out.print(v.chambers+","+v.size+","+v.color);
}
}
{ chambers = 4; }
}
A. 2,null,RED
B. 2,null,BLUE
C. 3,10.0,RED
D. The code does not compile.

|
1_ Fill in the blanks: A(n) is a file that contains a reference to another file or
directory, while a(n) is a file that contains content.
A. irregular file, regular file
B. regular file, opaque file
C. symbolic link, regular file
D. symbolic link, symbolic directory
|
2_ Which methods listed below are found in the NIO.2 Path interface?
I. getRoot()
II. isDirectory()
III. listFiles()
IV. toRealPath()
A. I only
B. I, II, and III
C. I and IV
D. II and III
|
3_ Assuming the file /secret/hide.txt exists and is marked hidden, what is result of
executing
the following program?
package hidden;
import java.nio.file.*;
public class Finder {
public void findHiddenFile(Path p) throws Exception {
if(File.isHidden(p)) {
System.out.print("Found!");
}
}
public static void main(String[] folders) throws Exception {
final Finder f = new Finder();
f.findHiddenFile(Paths.get("/secret/hide.txt"));
}
}
A. The class does not compile.
B. An exception is printed at runtime.
C. Found! is printed at runtime.
D. Nothing is printed at runtime.

|
4_ Fill in the blanks: Files.walk() performs a traversal, while
Files.find() performs a traversal.
A. breadth-first, breadth-first
B. breadth-first, depth-first
C. depth-first, breadth-first
D. depth-first, depth-first
|
5_ When reading file information, what is an advantage of using an NIO.2 attribute interface
rather than reading the values individually from Files methods?
A. Costs fewer round-trips to the file system
B. Guarantees performance improvement
C. Has support for symbolic links
D. Reduces memory leaks
|
6_ What is the result of compiling and executing the following program? Assume the current
directory is /stock and the path /stock/sneakers does not exist prior to execution.
package shoe;
import java.io.*;
import java.nio.file.*;
public class Sneaker {
public void setupInventory(Path desiredPath) throws Exception {
Path suggestedPath = Paths.get("sneakers");
if(Files.isSameFile(suggestedPath, desiredPath) // j1
&& !Files.exists(suggestedPath))
Files.createDirectories(desiredPath); // j2
}
public static void main(String[] socks) throws Exception {
Path w = new File("/stock/sneakers").toPath(); // j3
new Sneaker().setupInventory(w);
}
}
A. The directory /stock/sneakers is created.
B. Line j1 does not compile or produces an exception at runtime.
C. Line j2 does not compile or produces an exception at runtime.
D. Line j3 does not compile or produces an exception at runtime.

|
7_ Assuming the path referenced below exists and contains a symbolic link that references
/again, what is the expected result of executing the following code snippet?
System.out.print(Files.walk(Paths.get("/again/and/again")).count());
A. An exception is thrown at runtime.
B. A number is printed at runtime.
C. The process hangs indefinitely.
D. The result cannot be determined with the information given.
|
8_ Which method in the NIO.2 Files class is equivalent to the java.io.File method
length()?
A. length()
B. size()
C. getLength()
D. None of the above
|
9_ Assuming the current working directory is /home, then what is the output of the following
program?
1: package magic;
2: import java.nio.file.*;
3: public class Magician {
4: public String doTrick(Path path) {
5: return path.subpath(2,3)
6: .getName(1)
7: .toAbsolutePath()
8: .toString();
9: }
10: public static void main(String... cards) {
11: final Magician m = new Magician();
12: System.out.print(m.doTrick(
13: Paths.get("/bag/of/tricks/.././disappear.txt")));
14: } }
A. /home/tricks
B. /home
C. The code does not compile.
D. The code compiles but prints an exception at runtime.

|
10_ Which methods listed below are found in the NIO.2 Files class?
I. isSameFile()
II. length()
III. relativize()
IV. mkdir()
A. I only
B. I, II, and IV
C. II and III
D. IV only
|
11_ The following code snippet, which attempts to move a file system record from
oldHardDrivePath
to newHardDrivePath, results in an exception at runtime.
Which of the following is the most likely type of exception to be thrown?
Files.move(oldHardDrivePath,newHardDrivePath,REPLACE_EXISTING);
A. AtomicMoveNotSupportedException
B. DirectoryNotEmptyException
C. FileAlreadyExistsException
D. None of the above since the line of code does not compile
|
12_ Which of the following can be filled into the blank that would allow the method to
compile?
public String getPathName(String fileName) {
final Path p = ;
return p.getFileName();
}
I. new File(fileName).toPath()
II. new Path(fileName)
III. FileSystems.getDefault().getPath(fileName)
A. I and II
B. I and III
C. II
D. None of the above

|
13_ Which statement about the following class is correct?
package clone;
import java.io.*;
import java.nio.file.*;
public class Rewriter {
public static void copy(Path source, Path target) throws Exception {
try (BufferedReader r = Files.newBufferedReader(source);
Writer w = Files.newBufferedWriter(target)) {
String temp = null;
while((temp = r.readLine()) != null) {
w.write(temp);
}
}
}
public static void main(String[] tooMany) throws Throwable {
Rewriter.copy(Paths.get("/original.txt"),
FileSystems.getDefault().getPath("/","unoriginal.txt"));
}
}
A. The class compiles without issue.
B. The class never throws an exception at runtime.
C. The implementation correctly copies a regular file.
D. All of the above
|
14_ Fill in the blanks: The Files. method returns a List, while the
Files. method returns a Stream.
A. lines(), readAllLines()
B. lines(), readLines()
C. readAllLines(), lines()
D. readLines(), lines()
|
15_ What is the output of the following application?
1: package yellow;
2: import java.nio.file.*;
3: public class Road {
4: public boolean findHome() {
5: Path oftenTraveled = Paths.get("/highway/street/spot.txt");
6: Path lessTraveled = Paths.get("/highway/street/house/../.");
7: lessTraveled.resolve("spot.txt");
8: return oftenTraveled.equals(lessTraveled.normalize());

9: }
10: public static void main(String... emerald) {
11: System.out.print("AM I HOME? "
12: +(new Road().findHome() ? "yes" : " no"));
13: }
14: }
A. AM I HOME? no
B. AM I HOME? yes
C. The class does not compile.
D. The class compiles but throws an exception at runtime.
|
16_ Which of the following is not an advantage of using an NIO.2 Path instead of a
java.io.File to work with files?
A. Contains built-in support for symbolic links
B. Has ability to read operating-system-specific attributes
C. Provides a single method for deleting a directory tree
D. Provides efficient access of file metadata
|
17_ What is the result of executing the following program? Assume the path /driveway exists
and is non-empty, and the directory tree is fully accessible within the file system.
package weather;
import java.io.*;
import java.nio.file.*;
public class Snow {
public static boolean removeSnow(Path flake) throws IOException {
if(!Files.isDirectory(flake) && !Files.isSymbolicLink(flake))
return Files.delete(flake);
else return true;
}
public static void main(String[] cones) throws IOException {
File driveway = new File("/driveway");
for(File f : driveway.listFiles()) {
System.out.println(removeSnow(f.toPath()));
}
}
}
A. The program prints a list of only true values.
B. The program prints a mix of true and false values.
C. The code does not compile.
D. The code compiles but prints an exception at runtime.

|
18_ Which interface name inserted into the blank below allows the code snippet to compile?
Path file = Paths.get("/data/movie.txt");
BasicFileAttributes b = Files.readAttributes(file, );
A. BasicFileAttributes.class
B. DosFileAttributes.class
C. PosixFileAttributes.class
D. All of the above
|
19_ What is the output of the following code snippet? Assume that the current directory is the
root path.
Path p1 = Paths.get("./locks");
Path p2 = Paths.get("/found/red.zip");
System.out.println(p1.relativize(p2));
System.out.println(p2.relativize(p1));
A. ../found/red.zip
../../locks
B. ../../locks
../found/red.zip
C. locks/../found/red.zip
../found/locks
D. None of the above
|
20_ What is the output of the following code snippet? Assume that the current directory is the
root path.
Path p1 = Paths.get("./found/../keys");
Path p2 = Paths.get("/lost/blue.txt");
System.out.println(p1.resolve(p2));
System.out.println(p2.resolve(p1));
A. /lost/blue.txt
./found/../keys
B. /found/../keys/./lost/blue.txt
/lost/blue.txt/keys
C. /lost/blue.txt
/lost/blue.txt/./found/../keys
D. None of the above

|
21_ What is the output of the following application? Assume the application is called with a
valid path that exists and is accessible within the file system.
package charity;
import java.nio.file.*;
public class Roster {
protected void printRoster(Path p) {
for(Path f : Files.list(p)) { // n1
if(f.toString().endsWith(".per")) // n2
System.out.print(f);
}
}
public static void main(String... volunteers) {
new Roster().printRoster(Paths.get(volunteers[0]));
}
}
A. A list of file names is printed at runtime.
B. The class does not compile due to line n1.
C. The class does not compile due to line n2.
D. None of the above
|
22_ Given the following file system diagram, in which forward is a symbolic link to the java
directory, which value does not print /java/Sort.java at runtime?
java
Sort.java Sort.class Heap.m
/
bin forward
objC
Heap.exe
Path p = Paths.get("/", "objC", "bin");
System.out.println(p.resolve(" ").toRealPath());
A. ../backwards/../forward/Sort.java
B. ../forward/./Sort.java
C. ../java/./forward/Sort.java
D. ../../java/Sort.java

|
23_ Using the file system diagram from the previous question, including the symbolic link from
forward to java, how many calls to Files.delete() would need to be made before the
following line could be executed without throwing an exception?
Files.delete(Paths.get("/objC"));
A. One
B. Four
C. Seven
D. None of the above. The symbolic link needs to be removed with
Files.
deleteSymbolicLink() first.
|
24_ Assuming the course.txt file exists and is readable, what is the result of executing the
following
application?
package schoolwork;
import java.io.*;
import java.nio.file.*;
public class Notes {
public void printNotes() {
try (OutputStream out = System.out) { // y1
Files.copy(out, Paths.get("course.txt"));
} catch (IOException e) {
throw new RuntimeException(e);
}
}
public static void main(String[] coursework) {
new Notes().printNotes();
}
}
A. The code compiles but prints an exception at runtime.
B. The class does not compile due to line y1.
C. The code does not compile for some other reason.
D. The program prints the contents of the course.txt file.
|
25_ When reading file information, what is an advantage of loading aBasicFileAttributeView
over a BasicFileAttributes?
A. Allows the hidden attribute to be set
B. Allows the last modified date to be changed
C. All of the file information is read in a single round-trip.
D. There is no advantage.

|
26_ The Rose application is run with an input argument of /flower. The /flower directory
contains five subdirectories, each of which contains five files. How many Path values does
the following application print?
import java.nio.file.*;
public class Rose {
public void tendGarden(Path p) throws Exception {
Files.walk(p,1)
.map(p -> p.toRealPath())
.forEach(System.out::println);
}
public static void main(String... thorns) throws Exception {
new Rose().tendGarden(Paths.get(thorns[0]));
}
}
A. None
B. One
C. Six
D. Thirty-one
|
27_ Which of the following statements, when run independently, produces a
NullPointerException
at runtime?
I. Paths.get("../sang").getParent().getParent()
II. Paths.get("/sing").getParent().getRoot()
III. Paths.get("/song").getRoot().getRoot()
IV. Paths.get("../sung").getRoot().getParent()
A. I and III
B. I and IV
C. II and III
D. IV only
|
28_ Which statement about the following Finalize class is correct?
1: package end;
2: import java.nio.file.*;
3: public class Finalize {
4: public Path makeAbsolute(Path p) {
5: if(p!=null && !p.isAbsolute())
6: return p.toAbsolutePath();

7: return p;
8: }
9: }
A. It does not compile because IOException is neither handled nor declared.
B. It does not compile for some other reason.
C. The method compiles and returns a Path value that is always equivalent to the input
argument.
D. The method compiles and returns a Path value that may not be equivalent to the input
argument.
|
29_ Which of the following is a difference between the createDirectory() and
createDirectories()
methods found in the NIO.2 Files class?
A. One takes multiple Path arguments; the other does not.
B. One throws an exception if a file already exists at the directory path; the other does
not.
C. One declares a checked exception; the other does not.
D. One creates a single directory while the other may create many directories.
|
30_ Assuming the current working directory is /hail, what is the expected output of executing
the following code snippet?
Path w1 = Paths.get("../jungle/.././rain..")
.toAbsolutePath().normalize();
System.out.print(w1.resolve("snow.txt"));
A. /jungle/snow.txt
B. /hail/rain../snow.txt
C. /rain../snow.txt
D. An exception is printed at runtime.
|
31_ What is the output of the following application?
package med;
import java.nio.file.*;
public class Surgeon {
public Path rebuild(Path p) {
Path v = null;
for(int i=0; i<p.getNameCount(); i++)
if(v==null) v = p.getName(i);
else v = v.resolve(p.getName(i));
return v;
}
public static void main(String... tools) {
final Surgeon al = new Surgeon();

Path original = Paths.get("/tissue/heart/chambers.txt");
Path repaired = al.rebuild(original);
System.out.print(original.equals(repaired));
}
}
A. false
B. true
C. The code does not compile.
D. The code compiles but prints an exception at runtime.
|
32_ Under which circumstances does Files.deleteIfExists() not throw an exception?
A. The file system suddenly becomes unavailable.
B. The path does not exist.
C. The path represents a non-empty directory.
D. The process does not have write access to a path.
|
33_ What is the output of the following code snippet? Assume all referenced paths exist within
the file system.
Path v1 = Path.get("/./desert/./").resolve(Paths.get("sand.doc"));
Path v2 = new File("/desert/./cactus/../sand.doc").toPath();
System.out.print(Files.isSameFile(v1,v2));
System.out.print(" "+v1.equals(v2));
System.out.print(" "+v1.normalize().equals(v2.normalize()));
A. false false false
B. true false true
C. true true true
D. None of the above
|
34_ How many lines of the following program contain compilation errors?
public class Song {
public static void organize(Path folder, Path file) throws IOException {
Path p = folder.resolve(file);
BasicFileAttributeView vw = Files.getFileAttributeView(p,
BasicFileAttributes.class);
if(vw.creationTime().toMillis()<System.currentTimeMillis()) {
vw.setTimes(FileTime.fromMillis(System.currentTimeMillis()),
null,null);
}
}
public static void main(String[] audio) throws Exception {

Song.organize(Paths.get("/", "pub"),new File("/songs").toPath());
}
}
A. None
B. One
C. Two
D. Three
|
35_ What is the output of the following application?
package stars;
import java.nio.file.*;
public class Sun {
public void printInfo() {
Path halleysComet = Paths.get("stars/./rocks/../m1.meteor")
.normalize();
Path lexellsComet = Paths.get("./stars/../solar/");
lexellsComet = lexellsComet.subpath(0, 2)
.resolve("m1.meteor")
.normalize();
System.out.print(halleysComet.equals(lexellsComet)
? "Same!" : "Different!");
}
public static void main(String... emerald) {
Sun s = new Sun();
s.printInfo();
}
}
A. Different!
B. Same!
C. The class does not compile.
D. The class compiles but throws an exception at runtime.
|
36_ Assuming the directory /eclipse/projects exists and its contents are accessible, which
statement about the following code snippet is correct?
Path p = Paths.get("/eclipse/projects");
Files.walk(p)
.map(z -> z.toAbsolutePath().toString())
.filter(s -> s.endsWith(".java"))

.collect(Collectors.toList()).forEach(System.out::println);
Files.find(p,Integer.MAX_VALUE,
(w,a) -> w.toAbsolutePath().toString().endsWith(".java"))
.collect(Collectors.toList()).forEach(System.out::println);
A. The first stream statement does not compile.
B. The second stream statement does not compile.
C. Both statements compile but are unlikely to print the same results at runtime.
D. None of the above
|
37_ Assuming the file referenced below exists and is significantly large, which statement about
the following program is correct?
public class SpeedRead {
public void jenniferReads(Path p) {
Files.lines(p);
}
public void jonReads(Path p) {
Files.readAllLines(p);
}
public static void main(String[] pages) {
Path p = Paths.get("/bookshelf/mobydick.txt");
final SpeedRead r = new SpeedRead();
r.jenniferReads(p);
r.jonReads(p);
}
}
A. The code does not compile.
B. The method jenniferReads() is likely to take longer to run.
C. The method jonReads() is likely to take longer to run.
D. It is not possible to know which method will take longer to run.
|
38_ What is the result of executing the following program? Assume the files referenced in the
application both exist and are fully accessible within the file system.
package duplicate;
import static java.nio.file.StandardCopyOption.*;
import static java.nio.file.Files.*;
import java.io.*;
import java.nio.file.*;
public class CopyOfACopy {

public void main(String[] items) throws Exception {
final Path s = new File("apples.zip").toPath();
final Path t = FileSystems.getDefault().getPath("oranges.zip");
copy(s,t,REPLACE_EXISTING); // q1
copy(Files.newBufferedReader(t),t,ATOMIC_MOVE); // q2
}
}
A. Line q1 does not compile.
B. Line q1 produces an exception at runtime.
C. Line q2 does not compile.
D. Line q2 produces an exception at runtime.
|
39_ Which of the following Files methods requires the enclosing method to handle or declare
a checked exception?
A. exists()
B. isDirectory()
C. isSameFile()
D. isSymbolicLink()
|
40_ What is the output of the following application? Assume /all-data exists and is accessible
within the file system.
package numbers;
import java.nio.file.*;
import java.util.stream.Stream;
public class TheCount {
public static Stream<String> readLines(Path p) {
try {
return Files.lines(p);
} catch (Exception e) {
throw new RuntimeException(e);
}
}
public static long count(Path p) throws Exception {
return Files.list(p)
.filter(w -> Files.isRegularFile(w))
.flatMap(s -> readLines(s))
.count();
}

public final static void main(String[] day) throws Exception {
System.out.print(count(Paths.get("/all-data")));
}
}
A. The number of lines in all files in a directory tree
B. The number of lines in all files in a single directory
C. The code does not compile.
D. The code compiles but prints an exception at runtime.


|
1_ Which of the following methods is not available on an ExecutorService instance?
A. execute(Callable)
B. execute(Runnable)
C. submit(Callable)
D. submit(Runnable)
|
2_ Which statements about executing the following TicketTaker application multiple times
are true?
package performance;
import java.util.concurrent.atomic.*;
import java.util.stream.*;
public class TicketTaker {
long ticketsSold;
final AtomicInteger ticketsTaken;
public TicketTaker() {
ticketsSold = 0;
ticketsTaken = new AtomicInteger(0);
}
public void performJob() {
IntStream.iterate(1, p -> p+1)
.parallel()
.limit(10)
.forEach(i -> ticketsTaken.getAndIncrement());
IntStream.iterate(1, q -> q+1)
.limit(5)
.parallel()
.forEach(i -> ++ticketsSold);
System.out.print(ticketsTaken+" "+ticketsSold);
}
public static void main(String[] matinee) {
new TicketTaker().performJob();
}
}
I. The class compiles and runs without throwing an exception.
II. The first number printed is consistently 10.
III. The second number printed is consistently 5.
A. I only
B. I and II
C. I, II, and III
D. None of the above

|
3_ Which of the following is a recommended way to define an asynchronous task?
A. Create a Callable expression and pass it to an instance of Executors.
B. Create a class that extends Thread and overrides the start() method.
C. Create a Runnable expression and pass it to a Thread constructor.
D. All of the above
|
4_ Let’s say you needed a thread executor to create tasks for a CyclicBarrier that has a
barrier
limit of five threads. Which static method in ExecutorService should you
use to obtain it?
A. newSingleThreadExecutor()
B. newSingleThreadScheduledExecutor()
C. newCachedThreadPool()
D. None of these would work.
|
5_ Given the original array, how many of the following for statements result in an exception
at runtime, assuming each is executed independently?
List<Integer> original = new ArrayList<>(Arrays.asList(1,2,3,4,5));
List<Integer> copy1 = new CopyOnWriteArrayList<>(original);
for(Integer w : copy1)
copy1.remove(w);
List<Integer> copy2 = Collections.synchronizedList(original);
for(Integer w : copy2)
copy2.remove(w);
List<Integer> copy3 = new ArrayList<>(original);
for(Integer w : copy3)
copy3.remove(w);
Queue<Integer> copy4 = new ConcurrentLinkedQueue<>(original);
for(Integer w : copy4)
copy4.remove(w);
A. Zero
B. One
C. Two
D. Three
|
6_ Fill in the blanks: is a special case of , in which two or
more active threads try to acquire the same set of locks and are repeatedly unsuccessful.
A. Deadlock, livelock
B. Deadlock, resource starvation
C. Livelock, resource starvation
D. Resource starvation, race conditions

|
7_ What is the output of the following application?
1: package office;
2: import java.util.concurrent.*;
3: public class TpsReport {
4: public void submitReports() {
5: ExecutorService service = Executors.newCachedThreadPool();
6: Future bosses = service.submit(() -> System.out.print(""));
7: service.shutdown();
8: System.out.print(bosses.get());
9: }
10: public static void main(String[] memo) {
11: new TpsReport().submitReports();
12: }
13: }
A. null
B. The code does not compile.
C. Line 7 throws an exception at runtime.
D. Line 8 throws an exception at runtime.
|
8_ Which of the following static methods does not exist in the Executors class?
A. newFixedScheduledThreadPool()
B. newFixedThreadPool()
C. newSingleThreadExecutor()
D. newSingleThreadScheduledExecutor()
|
9_ How many times does the following application print Ready at runtime?
package parade;
import java.util.concurrent.*;
public class CartoonCat {
private void await(CyclicBarrier c) {
try {
c.await();
} catch (Exception e) {}
}
public void march(CyclicBarrier c) {
ExecutorService s = Executors.newSingleThreadExecutor();
for(int i=0; i<12; i++)
s.execute(() -> await(c));
s.shutdown();
}

public static void main(String... strings) {
new CartoonCat().march(new CyclicBarrier(4,
() -> System.out.println("Ready")));
}
}
A. Zero
B. One
C. Three
D. The code does not compile.
|
10_ Which thread-safe class would you use to add elements to the front and back of an ordered
data structure and includes methods for waiting a specified amount of time to do so?
A. BlockingDeque
B. ConcurrentLinkedDeque
C. ConcurrentSkipListSet
D. LinkedBlockingDeque
|
11_ Three of the four methods below always produce the same result whether they are executed
on a serial or parallel ordered stream. Which one does not?
A. findAny()
B. findFirst()
C. limit()
D. skip()
|
12_ What is the result of executing the following application multiple times?
package bears;
import java.util.*;
public class Bounce {
public static void main(String... legend) {
Arrays.asList(1,2,3,4).stream()
.forEach(System.out::println);
Arrays.asList(1,2,3,4).parallel()
.forEachOrdered(System.out::println);
}
}
A. Only the first array is printed in the same order every time.
B. Only the second array is printed in the same order every time.
C. Both arrays are printed in the same order every time.
D. None of the above

|
13_ Fill in the blanks: In the fork/join framework, using the class requires
overriding an abstract compute() method containing a generic return type, while using the
class requires overriding an abstract compute() method containing a
void return type.
A. ForkJoinTask, RecursiveAction
B. RecursiveAction, RecursiveTask
C. RecursiveTask, ForkJoinTask
D. RecursiveTask, RecursiveAction
|
14_ Given the following code snippet, which lambda expression is the best choice for the accumulator,
based on the rules for applying a parallel reduction?
public class GoodAccumulator {
int i;
public void test() {
BiFunction<Integer,Integer,Integer> accumulator = ;
System.out.print(Arrays.asList(1,2,3,4,5)
.parallelStream()
.reduce(0,accumulator,(s1, s2) -> s1 + s2));
}
}
A. (a,b) -> (a-b)
B. (a,b) -> 5
C. (a,b) -> i++
D. None of the above are appropriate.
|
15_ What is the output of the following code snippet?
Callable c = new Callable() {
public Object run() {return 10;}
};
ExecutorService s = Executors.newScheduledThreadPool(1);
for(int i=0; i<10; i++) {
Future f = s.submit(c);
f.get();
}
s.shutdown();
System.out.print("Done!");
A. Done!
B. The code does not compile.
C. The code hangs indefinitely at runtime.
D. The code throws an exception at runtime.

|
16_ The following diagrams represent the order of read/write operations of two threads sharing
a common variable. Each thread first reads the value of the variable from memory and then
writes a new value of the variable back to memory. Which diagram demonstrates proper
synchronization?
A.
Thread 1
Thread 2
Time
Shared Memory
B.
Thread 1
Thread 2
Time
Shared Memory
C.
Thread 1
Thread 2
Time
Shared Memory
D.
Thread 1
Thread 2
Time
Shared Memory
|
17_ What is the output of the following application?
package story;
import java.util.*;
import java.util.concurrent.*;
public class Race {
static ExecutorService service = Executors.newFixedThreadPool(8);
public static int sleep() {
try {
Thread.sleep(1000);
} catch (Exception e) {}
return 1;
}

public static void hare() {
try {
Callable c = () -> sleep();
final Collection<Callable<Integer>> r = Arrays.asList(c,c,c);
List<Future<Integer>> results = service.invokeAll(r);
System.out.println("Hare won the race!");
} catch (Exception e) {e.printStackTrace();}
}
public static void tortoise() {
try {
Callable c = () -> sleep();
final Collection<Callable<Integer>> r = Arrays.asList(c,c,c);
Integer result = service.invokeAny(r);
System.out.println("Tortoise won the race!");
} catch (Exception e) {e.printStackTrace();}
}
public static void main(String[] p) throws Exception {
service.execute(() -> hare());
service.execute(() -> tortoise());
}
}
A. Hare won the race! is printed first.
B. Tortoise won the race! is printed first.
C. The code does not compile.
D. The result is unknown until runtime.
|
18_ Which of the following concurrent collections is sorted?
A. ConcurrentLinkedQueue
B. ConcurrentSkipListMap
C. CopyOnWriteArrayList
D. LinkedBlockingQueue
|
19_ What is the most likely result of executing the following application?
package unknown;
import java.util.concurrent.*;
public class Riddle {
public void sleep() {
try {
Thread.sleep(5000);
} catch (Exception e) {}
}

public String getQuestion(Riddle r) {
synchronized {
sleep();
if(r != null) r.getAnswer(null);
return "How many programmers does it take "
+ "to change a light bulb?";
}
}
public synchronized String getAnswer(Riddle r) {
sleep();
if(r != null) r.getAnswer(null);
return "None, that's a hardware problem";
}
public static void main(String... ununused) {
final Riddle r1 = new Riddle();
final Riddle r2 = new Riddle();
ExecutorService s = Executors.newFixedThreadPool(2);
s.submit(() -> r1.getQuestion(r2));
s.execute(() -> r2.getAnswer(r1));
s.shutdown();
}
}
A. A deadlock is produced at runtime.
B. A livelock is produced at runtime.
C. The application completes successfully.
D. The code does not compile.
|
20_ Which ScheduledExecutorService method can result in the same action being executed
by two threads at the same time?
A. scheduleAtFixedDelay()
B. scheduleAtFixedRate()
C. scheduleWithFixedDelay()
D. There is no such method in ScheduledExecutorService.
|
21_ What is the output of the following application?
package olympics;
import java.util.concurrent.*;
public class Athlete {
int stroke = 0;
public synchronized void swimming() {
stroke++;
}

public static void main(String... laps) {
ExecutorService s = Executors.newFixedThreadPool(10);
Athlete a = new Athlete();
for(int i=0; i<1000; i++) {
s.execute(() -> a.swimming());
}
s.shutdown();
System.out.print(a.stroke);
}
}
A. 1000
B. The code does not compile.
C. The result is unknown until runtime because stroke is not accessed in a thread-safe
manner and a write may be lost.
D. The result is unknown until runtime for some other reason.
|
22_ Which of the following is most likely to be caused by a race condition?
A. A thread perpetually denied access to a resource
B. An int variable incorrectly reporting the number of times an operation was performed
C. Two threads actively trying to restart a blocked process that is guaranteed to always
end the same way
D. Two threads endlessly waiting on each other to release shared locks
|
23_ What is the output of the following application?
package farm;
import java.util.concurrent.*;
public class CountSheep extends RecursiveAction {
static int[] sheep = new int[] {1,2,3,4};
final int start;
final int end;
int count = 0;
public CountSheep(int start, int end) {
this.start = start;
this.end = end;
}
public void compute() {
if(end-start<2) {
count+=sheep[start];
return;
} else {

int middle = start + (end-start)/2;
invokeAll(new CountSheep(start,middle),
new CountSheep(middle,end));
}
}
public static void main(String[] night) {
ForkJoinPool pool = new ForkJoinPool();
CountSheep action = new CountSheep(0,sheep.length);
pool.invoke(action);
pool.shutdown();
System.out.print(action.count);
}
}
A. 0
B. 10
C. The code does not compile.
D. None of the above.
|
24_ Which statement about parallel streams is correct?
A. A parallel stream always executes all stream operations faster than a serial stream.
B. A parallel stream always executes certain stream operations faster than a serial stream.
C. A parallel stream synchronizes its operations so that they are atomic.
D. All streams can be converted to a parallel stream.
|
25_ What is a possible output of the following application?
package salvage;
import java.util.*;
import java.util.concurrent.*;
import java.util.stream.*;
public class Car {
private String model;
private int year;
public Car(String name, int year) {
this.model = name; this.year = year;
}
public int getYear() {return year;}
@Override public String toString() {return model;}
public static void main(String... make) {
List<Car> cars = new ArrayList<>();
cars.add(new Car("Mustang",1967));

cars.add(new Car("Thunderbird",1967));
cars.add(new Car("Escort",1975));
ConcurrentMap<Integer, List<Car>> map = cars
.stream()
.collect(Collectors.groupingByConcurrent(Car::getYear));
System.out.print(map);
}
}
A. {1975=[Escort], 1967=[Thunderbird, Mustang]}
B. {Escort=[1975], Thunderbird=[1967], Mustang=[1967]}
C. The code does not compile.
D. The application throws an exception at runtime because the stream is not parallel.
|
26_ What is the output of the following application?
package exercise;
import java.util.*;
public class Concat {
public String concat1(List<String> values) {
return values.parallelStream()
.reduce("a",
(x,y)->x+y,
String::concat);
}
public String concat2(List<String> values) {
return values.parallelStream()
.reduce((w,z)->z+w).get();
}
public static void main(String... questions) {
Concat c = new Concat();
List<String> list = Arrays.asList("Cat","Hat");
String x = c.concat1(list);
String y = c.concat2(list);
System.out.print(x+" "+y);
}
}
A. aCataHat HatCat
B. CatHat CatHat
C. The code does not compile because concat1() returns an Optional.
D. The code does not compile for a different reason.

|
27_ What is the output of the following application?
package taxes;
import java.util.concurrent.*;
public class Accountant {
public static void completePaperwork() {
System.out.print("[Filing]");
}
public static double getPi() {
return 3.14159;
}
public static void main(String[] args) throws Exception {
ExecutorService x = Executors.newSingleThreadExecutor();
Future<?> f1 = x.submit(() -> completePaperwork());
Future<Object> f2 = x.submit(() -> getPi());
System.out.print(f1.get()+" "+f2.get());
x.shutdown();
}
}
A. [Filing]null 3.14159
B. The declaration of f1 does not compile.
C. The declaration of f2 does not compile.
D. An exception is thrown at runtime.
|
28_ Which statement about the following class is correct?
package my;
import java.util.*;
public class ThreadSafeList {
private List<Integer> data = new ArrayList<>();
public synchronized void addValue(int value) {
data.add(value);
}
public int getValue(int index) {
return data.get(index);
}
public int size() {
synchronized(ThreadSafeList.class) {
return data.size();
}
}
}

A. The code does not compile because of the size() method.
B. The code compiles and is thread-safe.
C. The code compiles and is not thread-safe.
D. The code does not compile for another reason.
|
29_ Which two method names, when filled into the print2() method, produce the same output
as the print1() method? Assume the input arguments for each represent the same nonnull
numeric value, only accessible by a single thread at a time.
public static void print1(int value) {
System.out.println(value--);
System.out.println(++value);
}
public static void print2(AtomicInteger value) {
System.out.println(value. );
System.out.println(value. );
}
A. decrementAndGet() and getAndIncrement()
B. decrementAndGet() and incrementAndGet()
C. getAndDecrement() and getAndIncrement()
D. getAndDecrement() and incrementAndGet()
|
30_ How many times does the following application print 1 at runtime?
package crew;
import java.util.concurrent.*;
import java.util.stream.*;
public class Boat {
private void waitTillFinished(CyclicBarrier c) {
try {
c.await();
System.out.print("1");
} catch (Exception e) {}
}
public void row(ExecutorService service) {
final CyclicBarrier cb = new CyclicBarrier(5);
IntStream.iterate(1, i-> i+1)
.limit(12)
.forEach(i -> service.submit(() -> waitTillFinished(cb)));
}
public static void main(String[] oars) {
ExecutorService service = null;

try {
service = Executors.newCachedThreadPool();
new Boat().row(service);
} finally {
service.isShutdown();
}
}
}
A. 0
B. 10
C. 12
D. None of the above
|
31_ Using the Boat class from the previous question, what is the final state of the application?
A. The application produces an exception at runtime.
B. The application terminates successfully.
C. The application hangs indefinitely because the ExecutorService is never shut down.
D. The application produces a deadlock at runtime.
|
32_ What is the expected output of the following application?
package store;
import java.util.concurrent.*;
import java.util.stream.*;
public class Line {
static BlockingDeque<Integer> queue = new LinkedBlockingDeque<>();
public static void main(String[] participants) throws Exception {
IntStream.iterate(1, i -> i+1).limit(5)
.parallel()
.forEach(s -> queue.offerLast(s,10000,TimeUnit.MILLISECONDS));
IntStream.iterate(1, i -> 5).limit(10)
.parallel()
.forEach(s -> queue.pollFirst(10,TimeUnit.SECONDS));
System.out.print(queue.size());
}
}
A. 0
B. A number from 0 to 5
C. The code does not compile.
D. The code compiles but throws an exception at runtime.

|
33_ Given the original array, how many of the following for statements result in an infinite
loop at runtime, assuming each is executed independently?
List<Integer> original = new ArrayList<>(Arrays.asList(1,2,3));
List<Integer> copy1 = new ArrayList<>(original);
for(Integer q : copy1)
copy1.add(1);
List<Integer> copy2 = new CopyOnWriteArrayList<>(original);
for(Integer q : copy2)
copy2.add(2);
Deque<Integer> copy3 = new ConcurrentLinkedDeque<>(original);
for(Integer q : copy3)
copy3.push(3);
List<Integer> copy4 = Collections.synchronizedList(original);
for(Integer q : copy4)
copy4.add(4);
A. Zero
B. One
C. Two
D. Three
|
34_ Three of the four following options make up the requirements for performing a parallel
reduction with the collect() method, which takes a Collector argument. Choose the
one that is not a requirement.
A. The Collector argument is marked concurrent.
B. The elements of the stream implement the Comparable interface.
C. The stream is parallel.
D. The stream or Collector is marked unordered.
|
35_ Which statement about the following application is true?
package math;
import java.util.concurrent.*;
public class Fun extends RecursiveTask<Integer> {
final int value;
public Fun(int value) {
this.value = value;
}
@Override protected Integer compute() { // w1
if(value<1) {
return 1;

}
final Fun f1 = new Fun(value-1);
final Fun f2 = new Fun(value-2);
return f1.compute() * f2.compute();
}
public static void main(String... data) {
ForkJoinPool pool = new ForkJoinPool();
try {
System.out.print(pool.invoke(new Fun(10)));
} finally {
pool.shutdown();
}
}
}
A. The class does not compile due to line w1.
B. The class does not compile for another reason.
C. The application compiles and uses the fork/join framework correctly.
D. The application compiles but does not use the fork/join framework correctly.
|
36_ Which ExecutorService method guarantees all running tasks are stopped in an orderly
fashion?
A. shutdown()
B. shutdownNow()
C. halt()
D. None of the above
|
37_ Given the following code snippet, what statement about the values printed on lines p1 and
p2 is correct?
List<Integer> db = Collections.synchronizedList(new ArrayList<>());
IntStream.iterate(1, i -> i+1).limit(5)
.parallel()
.map(i -> {db.add(i); return i;})
.forEachOrdered(System.out::print); // p1
System.out.println();
db.forEach(System.out::print); // p2
A. They are always the same.
B. They are sometimes the same.
C. They are never the same.
D. The code will produce a ConcurrentModificationException at runtime.

|
38_ Assuming 10 seconds is enough time for all of the tasks to finish, what is the output of the
following application?
package finance;
import java.util.concurrent.*;
public class Bank {
static int cookies = 0;
public synchronized void deposit(int amount) {
cookies += amount;
}
public static synchronized void withdrawal(int amount) {
cookies -= amount;
}
public static void main(String[] amount) throws Exception {
ExecutorService teller = Executors.newScheduledThreadPool(50);
Bank bank = new Bank();
for(int i=0; i<25; i++) {
teller.submit(() -> bank.deposit(5));
teller.submit(() -> bank.withdrawal(5));
}
teller.shutdown();
teller.awaitTermination(10, TimeUnit.SECONDS);
System.out.print(bank.cookies);
}
}
A. 0
B. The code does not compile.
C. The result is unknown until runtime.
D. An exception is thrown at runtime.
|
39_ What is the output of the following application?
package util;
import java.util.*;
public class SearchList<T> {
private List<T> data;
private boolean foundMatch = false;
public SearchList(List<T> list) {
this.data = list;
}
public void exists(T value,int start, int end) {
if(end-start<=1) {

foundMatch = foundMatch || value.equals(data.get(start));
} else {
final int middle = start + (end-start)/2;
new Thread(() -> exists(value,start,middle)).run();
new Thread(() -> exists(value,middle,end)).run();
}
}
public static void main(String[] a) throws Exception {
List<Integer> data = Arrays.asList(1,2,3,4,5,6);
SearchList<Integer> t = new SearchList<Integer>(data);
t.exists(5, 0, data.size());
System.out.print(t.foundMatch);
}
}
A. true
B. false
C. The code does not compile.
D. The result is unknown until runtime.
|
40_ How many lines of the following code snippet contain compilation errors?
11: ScheduledExecutorService t = Executors
12: .newSingleThreadScheduledExecutor();
13: Future result = t.execute(System.out::println);
14: t.invokeAll(null);
15: t.scheduleAtFixedRate(() -> {return;}, 5, TimeUnit.MINUTES);
A. None. The code compiles as is.
B. One
C. Two
D. Three


|
1_ How many of Connection, Driver, and DriverManager are JDBC interfaces included with
the JDK?
A. None
B. One
C. Two
D. Three
|
2_ Which is found in the java.sql package?
A. DerbyDriver
B. MySqlDriver
C. OracleDriver
D. None of the above
|
3_ What must be the first characters of a database URL?
A. db,
B. db:
C. jdbc,
D. jdbc:
|
4_ Which is responsible for getting a connection to the database?
A. Driver
B. Connection
C. Statement
D. ResultSet
|
5_ Which most accurately fills in the blanks in this sentence? With JDBC 3.0, the driver is
to contain a java.sql.Driver file, and the code getting a Connection
is to call Class.forName().
A. allowed, allowed
B. allowed, required
C. required, allowed
D. required, required
|
6_ Which of these obtains a Connection?
A. Connection.getConnection(url)
B. Driver.getConnection(url)
C. DriverManager.getConnection(url)
D. new Connection(url)
|
7_ Which method is overloaded to allow passing a username and password?
A. forName()
B. getConnection()

C. getStatement()
D. None of the above
|
8_ What is the name of a concrete class that implements Statement and is included in the
core JDK?
A. CallableStatement
B. PreparedStatement
C. StatementImpl
D. None of the above
|
9_ How many of the following could be valid JDBC URL formats for an imaginary driver
named magic and a database named box?
I. jdbc:magic:127.0.0.1:1234/box
II. jdbc:magic:box
III. jdbc:magic:@127.0.0.1:1234
A. None
B. One
C. Two
D. Three
|
10_ Which most accurately fills in the blanks in this sentence? With JDBC 4.0, the driver is
to contain a java.sql.Driver file, and the code getting a Connection
is to call Class.forName().
A. allowed, allowed
B. allowed, required
C. required, allowed
D. required, required
|
11_ Which pair of statements is true when requesting a ResultSet to be both scroll sensitive
and updatable?
I. The scroll sensitive option is passed as a parameter before the updatable parameter.
II. The updatable option is passed as a parameter before the scroll sensitive parameter.
III. If these options are not available, the database driver returns a ResultSet with different
options.
IV. If these options are not available, the database driver throws a SQLException.
A. I, III
B. I, IV
C. II, III
D. II, IV

|
12_ Suppose the blue database exists and we are using a JDBC 4.0 driver. Which is the
outcome
of this code?
String url = "jdbc:derby:blue";
Class.forName(url);
try (Connection conn = DriverManager.getConnection(url);
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("select count(*) from sky")) {
System.out.println(rs.getInt(1));
}
A. It runs successfully and prints the number of rows in the sky table.
B. It throws a ClassNotFoundException.
C. It throws a SQLException.
D. It does not compile.
|
13_ Fill in the blanks: There are ResultSet concurrency modes, and drivers are
required to support .
A. two, both
B. two, one of them
C. three, two of them
D. three, all of them
|
14_ What is the output when run with a JDBC 4.0 driver if the clowns database exists and
contains
an empty clowns table?
String url = "jdbc:derby:clowns";
try (Connection conn = DriverManager.getConnection(url);
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("select count(*) from clowns")) {
System.out.println(rs.getInt(1));
}
A. 0
B. 1
C. The code does not compile.
D. The code compiles but throws an exception at runtime.
|
15_ Consider the three methods execute(), executeQuery(), and executeUpdate(). Fill in
the blanks: of these methods is/are allowed to run a DELETE SQL statement while
of these methods is/are allowed to run an UPDATE SQL statement.
A. One, one
B. One, two
C. Two, one
D. Two, two

|
16_ Assuming the clowns database exists and contains one empty table named clowns, what is
the output of the following when run using a JDBC 4.0 driver?
import java.sql.*;
public class EmptyTable {
public static void main(String[] args) throws SQLException { // s1
String url = "jdbc:derby:clowns";
try (Connection conn = new Connection(url); // s2
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("select * from clowns")) {
if (rs.next())
System.out.println(rs.getString(1));
}
}
}
A. The code terminates successfully without any output.
B. The code does not compile due to line s1.
C. The code does not compile due to line s2.
D. None of the above
|
17_ Which are valid ResultSet types?
I. TYPE_BACKWARD_ONLY
II. TYPE_FORWARD_ONLY
III. TYPE_REVERSE_ONLY
A. II
B. I and II
C. II and III
D. None of the above
|
18_ Given the table books in the figure and a ResultSet created by running the following SQL
statement, which option prints the value 379?
title
character varying(255)
OCA
OCP
379
669
num_pages
integer
select * from cert where title = 'OCA'
A. System.out.println(rs.getInt(1));
B. System.out.println(rs.getInt(2));
C. System.out.println(rs.getInteger(1));
D. System.out.println(rs.getInteger(2));

|
19_ Given the table books in the previous question and a ResultSet created by running this
SQL statement, which option prints OCP?
select title from cert where num_pages > 500
A. System.out.println(rs.getString());
B. System.out.println(rs.getString("0"));
C. System.out.println(rs.getString("1"));
D. System.out.println(rs.getString("title"));
|
20_ Assume the database exists with all referenced table and column names. Which is a true
statement when a JDBC 4.0 driver is used?
String url = "jdbc:derby:precipitation";
try (Connection conn = DriverManager.getConnection(url);
Statement stmt = conn.createStatement(
ResultSet.CONCUR_READ_ONLY,
ResultSet.TYPE_SCROLL_INSENSITIVE);
ResultSet rs = stmt.execute(
"select total from precip where type = 'rain'")) {
System.out.println(rs.getString("total"));
}
A. There is a compiler error on the line of code that creates the Statement.
B. There is a compiler error on the line of code that creates the ResultSet.
C. This code compiles and runs without error.
D. This code throws a SQLException at runtime.
|
21_ Which resources have their close() method called when this code runs?
public static void runQuery(Connection conn) throws SQLException{
try (Statement stmt = conn.createStatement()) {
ResultSet rs = stmt.executeQuery("select * from clowns");
rs.next();
}
}
A. No close() methods are called.
B. Only Statement
C. Only Statement and Connection
D. Only Statement and ResultSet
|
22_ Which statement is true about the JDBC core classes?
A. Driver is an implementation of DriverManager.
B. A general Connection implementation is included in the JDK.

C. A Statement automatically starts in auto-commit mode.
D. A ResultSet automatically starts pointing to the first row of data.
|
23_ Which of the following is required in a database driver implementation?
A. A file named jdbc.driver
B. A file named java.sql.Driver
C. At least one implementation of the Connection interface
D. None of the above
|
24_ Given that the people table has 10 rows, what is the result of the following when using a
driver that supports a scroll sensitive ResultSet?
try (Connection conn = DriverManager.getConnection(url);
Statement stmt = conn.createStatement(
ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY);
ResultSet rs = stmt.executeQuery("select count(*) from people")) {
rs.next();
rs.absolute(0); // q1
System.out.print(rs.getInt(1)); // q2
}
A. 10
B. The code does not compile.
C. Line q1 throws a SQLException.
D. Line q2 throws a SQLException.
|
25_ Given a scrollable updatable ResultSet that contains the following, what does the code
snippet output?
color
character varying(255)
black
blue
red
20
5
0
count
integer
rs = stmt.executeQuery("select * from pens");
rs.afterLast();
rs.previous();
rs.updateInt(2, 10);
rs.updateRow();
rs = stmt.executeQuery("select * from pens where color = 'red'");
while (rs.next())
System.out.println(rs.getInt(2));

A. 0
B. 10
C. The code does not compile.
D. The code compiles but throws an exception at runtime.
|
26_ Given a scrollable updatable ResultSet represented by the image in the previous question,
what does the code snippet output?
rs = stmt.executeQuery("select * from pens");
rs.afterLast();
while(rs.prev())
rs.updateInt(2,0);
rs = stmt.executeQuery("select * from pens where color = 'black'");
while (rs.next())
System.out.println(rs.getInt(2));
A. 0
B. 20
C. The code does not compile.
D. The code compiles but throws an exception at runtime.
|
27_ How many rows are added to the colors table from running the following?
try (Connection conn = DriverManager.getConnection(url);
Statement stmt = conn.createStatement()) {
conn.setAutoCommit(false);
stmt.executeUpdate("insert into colors values ('red')");
stmt.executeUpdate("insert into colors values ('blue')");
conn.commit();
conn.setAutoCommit(true);
stmt.executeUpdate("insert into colors values ('green')");
}
A. None
B. One
C. Two
D. Three
|
28_ Which is true if the clowns database exists and contains an empty clowns table?
String url = "jdbc:derby:clowns";
try (Connection conn = DriverManager.getConnection(url);
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("select count(*) from clowns")) {

rs.next(); // r1
System.out.println(rs.getInt(1)); // r2
}
A. The code compiles and runs without error.
B. The code does not compile.
C. The code compiles but throws an exception at runtime on line r1.
D. The code compiles but throws an exception at runtime on line r2.
|
29_ Suppose the ResultSet is scrollable and contains 10 rows with the values 1–10 respectively.
What is the output of the following?
5: rs.absolute(0);
6: rs.relative(5);
7: rs.relative(-10);
8: rs.relative(5);
9: System.out.print(rs.getInt(1));
A. 4
B. 5
C. The code does not compile.
D. The code compiles but throws an exception at runtime.
|
30_ Suppose the blue database does not exist and we are using a JDBC 4.0 driver. Which is the
outcome of this code?
String url = "jdbc:derby:blue";
try (Connection conn = DriverManager.getConnection(url);
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("select count(*) from sky")) {
System.out.println(rs.getInt(1));
}
A. It runs successfully and prints the number of rows in the sky table.
B. It throws a ClassNotFoundException.
C. It throws a SQLException.
D. It does not compile.
|
31_ What is the most likely outcome of this code if the people table is empty?
6: Statement stmt = conn.createStatement();
7: ResultSet rs1 = stmt.executeQuery("select * from people");
8: ResultSet rs2 = stmt.executeQuery("select * from people");
9: System.out.println(rs1.next() + " " + rs2.next());
A. It prints false false.
B. It prints true false.
C. It does not terminate.
D. It throws a SQLException.

|
32_ How many rows are added to the colors table from running the following?
try (Connection conn = DriverManager.getConnection(url);
Statement stmt = conn.createStatement()) {
conn.setAutoCommit(false);
stmt.executeUpdate("insert into colors values ('red')");
stmt.executeUpdate("insert into colors values ('blue')");
conn.rollback();
conn.setAutoCommit(true);
stmt.executeUpdate("insert into colors values ('green')");
}
A. None
B. One
C. Two
D. Three
|
33_ Assuming the clowns database exists and contains one empty table named clowns, what is
the output of the following when run using a JDBC 4_0 driver?
import java.sql.*;
public class EmptyTable {
public static void main (String[] args) throws SQLException { // s1
String url = "jdbc:derby:clowns";
try (Connection conn = DriverManager.getConnection(url); // s2
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("select * from clowns")) {
if (rs.next())
System.out.println(rs.getString(1));
}
}
}
A. The code terminates successfully without any output.
B. The code does not compile due to line s1
C. The code does not compile due to line s2
D. None of the above
|
34_ Given the following code snippet and the table below, what is the output of the following
when using a driver that supports a scroll sensitive ResultSet?
try (Connection conn = DriverManager.getConnection(url);
Statement stmt = conn.createStatement(
ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY);

ResultSet rs = stmt.executeQuery(
"select * from people order by last_name asc")) {
rs.afterLast();
rs.next();
rs.next();
rs.previous();
rs.previous();
System.out.println(rs.getString(1));
}
first_name
character varying(255)
last_name
character varying(255)
Jeanne
Janeice
Elena
Scott
Boyarsky
DelVecchio
Felder
Selikoff
A. Janeice
B. Elena
C. Scott
D. The code throws a SQLException at runtime.
|
35_ Given the following code snippet and the table in question 34, what is the output of the
following
when using a driver that supports a scroll sensitive ResultSet?
try (Connection conn = DriverManager.getConnection(url);
Statement stmt = conn.createStatement(
ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY);
ResultSet rs = stmt.executeQuery(
"select * from people order by last_name asc")) {
rs.absolute(-1);
System.out.print(rs.getString(1));
System.out.print(" ");
rs.absolute(1);
System.out.print(rs.getString(1));
}
A. Jeanne Scott
B. Scott Jeanne
C. The code compiles, but the output is neither of these.
D. The code throws a SQLException at runtime.

|
36_ Given the following code snippet and the table in question 34, what is the output of the
following?
try (Connection conn = DriverManager.getConnection(url);
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(
"select * from people order by last_name asc")) {
rs.next();
rs.next();
System.out.print(rs.getString(1));
System.out.print(" ");
rs.absolute(1);
System.out.print(rs.getString(1));
}
A. Jeanne Scott
B. Scott Jeanne
C. The code compiles, but the output is neither of these.
D. The code throws a SQLException at runtime.
|
37_ Given that the people table has 10 rows, what is the result of the following when using a
driver that supports a scroll sensitive Resultset?
String sql = "select count(*) from people";
try (Connection conn = DriverManager.getConnection(url);
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(sql,
ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY)) {
rs.next();
rs.absolute(0); // q1
System.out.print(rs.getInt(1)); // q2
}
A. 10
B. The code does not compile.
C. Line q1 throws a SQLException.
D. Line q2 throws a SQLException.
|
38_ How many rows are added to the colors table from running the following?
try (Connection conn = DriverManager.getConnection(url);
Statement stmt = conn.createStatement()) {
conn.setAutoCommit(false);
stmt.executeUpdate("insert into colors values ('red')");
stmt.executeUpdate("insert into colors values ('blue')");

conn.rollback();
conn.setAutoCommit(true);
stmt.executeUpdate("insert into colors values ('green')");
conn.rollback();
}
A. None
B. One
C. Two
D. Three
|
39_ Suppose the ResultSet is scrollable and contains 10 rows. How many times does the following
print true?
16: System.out.println(rs.absolute(-2));
17: System.out.println(rs.relative(-1));
18: System.out.println(rs.beforeFirst());
19: System.out.println(rs.relative(5));
A. Two
B. Three
C. Four
D. None of the above
|
40_ What is the correct order to close database resources?
A. Connection then Statement then ResultSet
B. ResultSet then Statement then Connection
C. Statement then Connection then ResultSet
D. Statement then ResultSet then Connection


|
1_ Which is not a locale?
A. Cultural region
B. Geographical region
C. Political region
D. Time zone region
|
2_ When localizing an application, which type of data varies in presentation depending on
locale?
A. Currencies
B. Dates
C. Both
D. Neither
|
3_ How do you find out the locale of the running program?
A. Locale.get("default")
B. Locale.get(Locale.DEFAULT)
C. Locale.getDefault()
D. None of the above
|
4_ If your application has all town names in a single file named strings.properties, what is
the most specific process that has been implemented?
A. Internationalization
B. Localization
C. Specialization
D. Translation
|
5_ Which interfaces does Properties implement?
I. Hashtable
II. HashMap
III. Map
A. III
B. I and II
C. I and III
D. II and III
|
6_ Which filename extension can hold a String property value in a resource bundle?
A. .java
B. .properties
C. Both of the above
D. Neither of the above

|
7_ How long will the effects of calling Locale.setDefault() be active assuming no other
calls to that method are made?
A. Until the end of the method
B. Until the program exits
C. Until the next reboot of the computer
D. None of the above. It persists even past a reboot.
|
8_ Given this properties file used to load the Properties object props and this code snippet,
what is the output?
mystery=bag
type=paper
18: System.out.print(props.getProperty("mystery"));
19: System.out.print(" ");
20: System.out.print(props.getProperty("more"));
A. bag
B. bag null
C. bag ?
D. This code throws a runtime exception on line 20.
|
9_ Fill in the blanks to complete the following code for a Java resource bundle.
public class Flights_en extends {
protected Object[][] () {
return new Object[0][0];
}
}
A. JavaResourceBundle, getContents
B. JavaResourceBundle, getProperties
C. ListResourceBundle, getContents
D. ListResourceBundle, getProperties
|
10_ Which of the following shows a valid Locale format for the language Hindi and the
country
India?
A. hi_IN
B. HI_in
C. in_HI
D. IN_hi

|
11_ If the key purple is in all four of these files, which file will the following code use for the
resource bundle?
Locale.setDefault(new Locale("en", "US"));
ResourceBundle rb = ResourceBundle.getBundle("Colors");
rb.getString("purple");
A. Colors.class
B. Colors.properties
C. Colors_en_US.class
D. Colors_en_US.properties
|
12_ What is the output of the following?
package counter;
import java.util.*;
public class CountResource extends ListResourceBundle {
private int count = 0;
@Override
protected Object[][] getContents() {
return new Object[][] { { "count", count++ } };
}
public static void main(String[] args) {
ResourceBundle rb = ResourceBundle.getBundle("counter.CountResource");
System.out.println(rb.getObject("count") + " " + rb.getObject("count"));
}
}
A. 0 0
B. 0 1
C. The code does not compile.
D. The code compiles but throws an exception at runtime.
|
13_ Which of the following shows a valid Locale format?
A. en
B. US
C. US_en
D. None of the above

|
14_ Which filename extension can define a LocalDateTime property value in a resource
bundle?
A. .java
B. .properties
C. Both of the above
D. Neither of the above
|
15_ What happens if you run this code with no resource bundles available?
ResourceBundle rb = ResourceBundle.getBundle("ghost.None");
A. It creates a resource bundle with no key/value pairs.
B. It runs without issue because the resource bundle is only searched for when getting the
first key.
C. It throws a MissingResourceException.
D. None of the above
|
16_ What is the result of the following?
Map<String, String> map = new TreeMap<>();
map.put("tool", "hammer");
map.put("problem", "nail");
Properties props = new Properties(); // p1
map.forEach((k,v) -> props.put(k, v)); // p2
String t = props.get("tool"); // p3
String n = props.get("nail");
System.out.println(t + " " + n);
A. hammer nail
B. The code does not compile due to line p1
C. The code does not compile due to line p2
D. The code does not compile due to line p3
|
17_ Which filename extension can hold a LocalDateTime property key in a resource bundle?
A. .java
B. .properties
C. Both of the above
D. Neither of the above

|
18_ If the key purple is in all four of these files, which file will the following code use for the
resource bundle?
Locale.setDefault(new Locale("en", "US"));
ResourceBundle rb = ResourceBundle.getBundle("Colors");
rb.getString("purple");
A. Colors_en.class
B. Colors_en.properties
C. Colors_US.class
D. Colors_US.properties
|
19_ Fill in the blank so the code correctly compiles and creates a Locale.
Locale loc = Locale. ;
A. get("Italian")
B. get(Locale.ITALIAN)
C. getLocale("Italian")
D. None of the above
|
20_ What is the result of the following?
Map<Object, Object> map = new TreeMap<>();
map.put("tool", "hammer");
map.put("problem", "nail");
Properties props = new Properties(); // p1
map.forEach((k,v) -> props.put(k, v)); // p2
String t = props.getProperty("tool"); // p3
String n = props.getProperty("problem");
System.out.println(t + " " + n);
A. hammer nail
B. The code does not compile due to line p1
C. The code does not compile due to line p2
D. The code does not compile due to line p3
|
21_ What is the output of the following?
1: package keyboard;
2: import java.util.*;
3:
4: public class Type {
5: protected Object[][] getContents() {
6: return new Object[][] { { "keys", new ArrayList<String>() }};
7: }

8: public static void main(String[] args) {
9: ResourceBundle rb = ResourceBundle.getBundle("keyboard.Type");
10: List<String> keys = (List) rb.getObject("keys");
11: keys.add("q");
12: keys.add("w");
13: keys.add("e");
14: keys.add("r");
15: keys.add("t");
16: keys.add("y");
17: System.out.println(((List) rb.getObject("keys")).size());
18: }
19: }
A. 0
B. 6
C. The code does not compile.
D. The code compiles but throws an exception at runtime.
|
22_ How many lines does the following print out?
3: Locale.setDefault(Locale.KOREAN);
4: System.out.println(Locale.getDefault());
5: Locale.setDefault(new Locale("en", "AU"));
6: System.out.println(Locale.getDefault());
7: Locale.setDefault(new Locale("EN"));
8: System.out.println(Locale.getDefault());
A. None; it does not compile.
B. One followed by an exception
C. Two followed by an exception
D. All three
|
23_ Given this properties file used to load the Properties object props and this code snippet,
what is the output?
mystery=bag
type=paper
18: System.out.print(props.getProperty("mystery", "?"));
19: System.out.print(" ");
20: System.out.print(props.getProperty("more", "?"));
A. bag
B. bag null
C. bag ?
D. This code throws a runtime exception on line 20

|
24_ Given the following four properties files, what does this code print?
Cars_en.properties
engine=engine
horses=241
engine=moteur
country=US country=France
Cars_fr.properties
Cars_en_US.properties Cars_fr_FR.properties
Locale.setDefault(new Locale("en", "US"));
ResourceBundle rb = ResourceBundle.getBundle(
"Cars", new Locale("fr", "FR"));
System.out.println(rb.getString("country") + " "
+ rb.getString("engine"));
A. France engine
B. France moteur
C. France null
D. The code throws an exception at runtime.
|
25_ Given the four properties files in question 24, what does this code print?
Locale.setDefault(new Locale("en", "US"));
ResourceBundle rb = ResourceBundle.getBundle(
"Cars", new Locale("fr", "CA"));
System.out.println(rb.getString("engine") + " "
+ rb.getString("horses"));
A. engine 241
B. moteur 241
C. moteur null
D. The code throws an exception at runtime.
|
26_ Given the four properties files in question 24, what does this code print?
Locale.setDefault(new Locale("fr", "CA"));
ResourceBundle rb = ResourceBundle.getBundle(
"Cars", new Locale("en", "CA"));

System.out.println(rb.getString("engine") + " "
+ rb.getString("horses"));
A. engine 241
B. moteur 241
C. moteur null
D. The code throws an exception at runtime.
|
27_ Which statement about ListResourceBundle is true?
A. A disadvantage over properties files is that you cannot create the value at runtime.
B. Names-fr.java is a bad implementation class name.
C. Values of type Integer are not allowed.
D. None of the above
|
28_ If the key red is in all four of these files, which file will the following code use for the
resource bundle?
Locale loc = new Locale("zh", "CN");
Locale.setDefault(new Locale("en", "US"));
ResourceBundle rb = ResourceBundle.getBundle("Colors", loc);
rb.getString("red");
A. Colors_CN.properties
B. Colors_en.properties
C. Colors_US.properties
D. Colors_zh.properties
|
29_ What is the output of the following?
package counter;
import java.util.*;
public class PropertyCounter extends ListResourceBundle {
private int count = 0;
@Override
protected Object[][] getContents() {
return new Object[][] {{ "count", new PropertyCounter() }};
}
public int getCount() {
return count++;
}

public static void main(String[] args) {
ResourceBundle rb = ResourceBundle.getBundle("counter.PropertyCounter");
PropertyCounter obj = (PropertyCounter) rb.getObject("count");
System.out.println(obj.getCount() + " " + obj.getCount());
}
}
A. 0 0
B. 0 1
C. The code does not compile.
D. The code compiles but throws an exception at runtime.
|
30_ What is the output of the following?
1: package keyboard;
2: import java.util.*;
3:
4: public class Type extends ListResourceBundle {
5: protected Object[][] getContents() {
6: return new Object[][] { { "keys", new ArrayList<String>() }};
7: }
8: public static void main(String[] args) {
9: ResourceBundle rb = ResourceBundle.getBundle("Type");
10: List<String> keys = (List) rb.getObject("keys");
11: keys.add("q");
12: keys.add("w");
13: keys.add("e");
14: keys.add("r");
15: keys.add("t");
16: keys.add("y");
17: System.out.println(((List) rb.getObject("keys")).size());
18: }
19: }
A. 0
B. 6
C. The code does not compile.
D. The code compiles but throws an exception at runtime.

|
31_ Given the following snippets of resource bundles from when we compiled the application,
what is the result of the following?
Buggy.java
getContents:
return new Object[][]
{{ "wheels", "4" }};
getContents:
return
new Object[0][0];
Buggy_en.java
Buggy.properties
color=white
wheels=6
color=black
Buggy_en.properties
Locale.setDefault(new Locale("en", "US"));
ResourceBundle rb = ResourceBundle.getBundle("Buggy");
System.out.println(rb.getString("wheels"));
A. null
B. 4
C. 6
D. The code throws an exception at runtime.
|
32_ Given the snippets of resource bundles in question 31 from when we compiled the application,
what is the result of the following?
Locale.setDefault(new Locale("en"));
ResourceBundle rb = ResourceBundle.getBundle("Buggy");
System.out.println(rb.getString("color"));
A. null
B. black
C. white
D. The code throws an exception at runtime.
|
33_ Given the snippets of resource bundles in question 31 from when we compiled the
application,
what is the result of the following?
Locale.setDefault(new Locale("zh"));
ResourceBundle rb = ResourceBundle.getBundle("Buggy");
System.out.println(rb.getString("wheels"));
A. null
B. 4
C. 6
D. The code throws an exception at runtime.

|
34_ If the key red is in all three of these files, which file will the following code use for the
resource bundle?
Locale loc = new Locale("zh", "CN");
Locale.setDefault(new Locale("en", "US"));
ResourceBundle rb = ResourceBundle.getBundle("Colors", loc);
rb.getString("red");
A. Colors_en.properties
B. Colors.properties
C. Red_en.properties
D. None of the above. It will throw a MissingResourceException.
|
35_ Which can fill in the blank in this code?
Properties props = new Properties();
props. ("x");
A. get
B. getProperty
C. Both of the above
D. Neither of the above
|
36_ What is the output of the following?
1: package keyboard;
2: import java.util.*;
3:
4: public class Type extends ListResourceBundle {
5: protected Object[][] getContents() {
6: return new Object[][] { { "keys", new ArrayList<String>() }};
7: }
8: public static void main(String[] args) {
9: ResourceBundle rb = ResourceBundle.getBundle("keyboard.Type");
10: List<String> keys = (List) rb.getObject("keys");
11: keys.add("q");
12: keys.add("w");
13: keys.add("e");
14: keys.add("r");
15: keys.add("t");
16: keys.add("y");
17: System.out.println(((List) rb.getObject("keys")).size());
18: }
19: }

A. 0
B. 6
C. The code does not compile.
D. The code compiles but throws an exception at runtime.
|
37_ What is the result of the following?
Map<String, String> map = new TreeMap<>();
map.put("tool", "hammer");
map.put("problem", "nail");
Property props = new Property(); // p1
map.forEach((k,v) -> props.put(k, v)); // p2
String t = props.getProperty("tool"); // p3
String n = props.getProperty("nail");
System.out.println(t + " " + n);
A. hammer nail
B. The code does not compile due to line p1.
C. The code does not compile due to line p2.
D. The code does not compile due to line p3.
|
38_ What is the output of the following?
package counter;
import java.util.*;
public class CountResource extends ListResourceBundle {
private int count = 0;
@Override
protected Object[][] getContents() {
return new Object[][] { { "count", count++ } };
}
public static void main(String[] args) {
ResourceBundle rb = new ResourceBundle("counter.CountResource");
System.out.println(rb.getObject("count") + " " + rb.getObject("count"));
}
}
A. 0 0
B. 0 1
C. The code does not compile.
D. The code compiles but throws an exception at runtime.

|
39_ Given the following two properties files in the pod package, what does the following class
output?
pod.container.properties
name=generic
number=2
pod.container_en.properties
name=Docker
type=container
package pod;
import java.util.*;
public class WhatKind {
public static void main(String[] args) {
Locale.setDefault(new Locale("en"));
ResourceBundle rb = ResourceBundle.getBundle("pod.container");
String name = rb.getString("name");
String type = rb.getString("type");
System.out.println(name + " " + type); }
}
A. Docker container
B. generic container
C. generic null
D. None of the above
|
40_ If the key red is in all three of these files, which file will the following code use for the
resource bundle?
Locale loc = new Locale("zh", "CN");
Locale.setDefault(new Locale("en", "US"));
ResourceBundle rb = ResourceBundle.getBundle("Colors", loc);
rb.getString("red");
A. Colors_EN.properties
B. Colors_ZH.properties
C. Red_EN.properties
D. None of the above. It will throw a MissingResourceException.

RISPOSTE

1_ D. The toString() method is declared in the Object class. Therefore it is available to be
called in any Java class and is overridden in some. Java automatically calls the toString()
method when you print an object, making Option D correct. Option C is incorrect because
toString() is a method, not a variable.
|
2_ B. This code is not a singleton because it has a public constructor. Remember that a
public no-argument constructor is provided automatically if no constructor is coded. This
code is well encapsulated because the instance variable is private. It is not immutable since
there is a setter method. Therefore, Option B is correct.
|
3_ C. The singleton pattern ensures there will be no more than one instance of the object.
Depending on how it is implemented, it is possible for there to be zero instances. But it is
not possible to have more than one, making Option C correct. Option D means the variable
is shared across instances or even without an instance being created but does not limit the
number of the instances of the class itself.
|
4_ C. Both objects are instances of the class Laptop. This means the startup() method in the
Laptop class gets called both times thanks to polymorphism.
|
5_ D. We know that the variable o that equals() is called on isn’t null, since we can’t call
instance methods on a null reference. However, a null reference could be passed as a
method parameter. If a null is passed in, the method should return false since an object
and a null are not equal. Options A and B are incorrect because the first line of those
methods should return false rather than true. Option C is incorrect because the cast is
missing. The Object class does not have a text variable available. Option D shows a properly
implemented equals() method and is correct.
|
6_ A. Option A is correct because mutability means the state can change and immutability
means it cannot. In Option C, static means the state isn’t tied to an instance. In Option B,
rigidity is not a common programming term.
|
7_ B. The Hammer class is a subclass of the Tool class. Since the use() method in Hammer is
intended to override the one in Tool, there are certain rules. One is that the access modifier
must not be more specific. Therefore, trying to make it private is a problem. Option B is
correct and r2 is the only line with a compiler error in this code.
|
8_ D. The singleton pattern requires that only one instance of the class exist. Neither of these
classes meets that requirement since they have the default no-argument constructor available.
There should have been a private constructor in each class. Therefore, Option D is
correct. Remember that the exam doesn’t always include import statements to simplify the
code you need to read.
|
9_ B. While using null with instanceof compiles, it always returns false. The other two
instanceof calls show that instanceof can be used with both classes and interfaces. They
both return true, making Option B correct.
|
10_ D. The static keyword is used to create a class-level variable, making Option D correct.
Note that a singleton is where you limit a class so only one instance can be created. This
means there are not multiple instances to share a variable across.
|
11_ A. Option A is a requirement of a singleton class rather than an immutable one. The other
three options are requirements of an immutable class.
|
12_ C. If the variables are public, the class is not encapsulated because callers have direct
access to them. This rules out Options A and B. Having private methods doesn’t allow the
callers to use the data, making Option D an undesirable answer. Option C is correct and
the classic definition of encapsulation where the data is not exposed directly.
|
13_ A. While both objects are instances of Laptop, we are not calling methods in this example. Virtual
method invocation only works for methods, not instance variables. For instance variables,
Java actually looks at the type of the reference and calls the appropriate variable. This makes
each reference call a different class’s instance variable in this example, and Option A is correct.
|
14_ B. An immutable class must not allow the state to change. In the Flower class, the caller
has a reference to the List being passed in and can change the size or elements in it. Similarly,
any class with a reference to the object can get the List by calling get() and make
these changes. The Flower class is not immutable. The Plant class shows how to fix these
problems and is immutable. Option B is correct.
|
15_ C. An instance method can access both instance variables and static variables. Both
methods compile and Option C is correct.
|
16_ B. A static method can access static variables, but not instance variables. The
getNumRakes() method does not compile, so Option B is correct.
|
17_ A. You are allowed to use null with instanceof; it just prints false. The bus variable is
both a Vehicle and a Bus, so lines 18 and 19 print true. Then it gets interesting. We know
that bus is not an ArrayList or Collection. However, the compiler only knows that bus
is not an ArrayList because ArrayList is a concrete class. Line 20 does not compile. The
compiler can’t definitively state that bus is not a Collection. Some future program could
create a subclass of Bus that does implement Collection, so this line compiles. Therefore,
only line 20 fails to compile, and Option A is correct.
|
18_ B. Building and House are both properly declared inner classes. Any House object can
be stored in a Building reference, making the declarations for p and r compile. The
declaration for s is also correct. It so happens that bh is a House object, so the cast works.
The declaration of q is a problem though. While the cast itself is fine, a Building cannot
be stored in a House reference, which means the assignment fails to compile. Option B is
correct and is the only line with a compiler error in this code. Note that if the declaration of
q was removed, the declaration of p would produce a ClassCastException at runtime.
|
19_ D. If two instances of a class have the same hash code, they might or might not be equal.
The reverse is not true. If two objects are equal, they must have the same hash code in order
to comply with the contracts of these methods. However, in this case, the answer is none
of the above because the method can’t simply return true or false. Based on the rules of
equals(), if null is passed in, the result must be false. If an object identity is passed in,
the result must be true due to reflexivity. As a result, Option D is correct.
|
20_ D. This class is a good example of encapsulation. It has a private instance variable and is
accessed by a public method. No changes are needed to encapsulate it, and Option D is correct.
|
21_ B. The singleton pattern requires that only one instance of the class exist. The
ExamAnswers class is close. However, getExamAnswers() is not static, so you can’t retrieve
the instance. Option B is the answer because TestAnswers is a correct implementation. It has
a static variable representing the one instance and a static method to retrieve it.
|
22_ C. The static initializer is only run once. The static method is run twice since it is
called twice. Therefore, three lines are printed, and Option C is correct.
|
23_ C. Option A is allowed because the turnOn() method is public and can be called from
anywhere. Options B and D are allowed since the method is in the same class, which is
always allowed! Option C is not allowed because wash() is a package-private method in
another package. Option C is the correct answer.
|
24_ B. The display() method has protected access. This means it can be accessed by
instance methods in the same package and any subclasses. There are no subclasses in this
example, so we only need to count the classes in the same package. Option B is correct
because Flashlight and Phone are in the package.
|
25_ B. Line 15 calls the method on line 9 since it is a Watch object. That returns watch, making
Option A incorrect. Line 16 calls the method on line 3 since it is a SmartWatch object
and the method is properly overridden. That returns smart watch, so Option B is the
answer, and Option C is incorrect.
|
26_ A. Clearly a Bus is a Vehicle since the Bus class implements Vehicle. The Van class is also
a Vehicle since it extends Bus. This question also confirms you know that arrays can be
tested with instanceof, which they can. Therefore, Option A is correct.
|
27_ C. There is no instanceOf keyword, making Options B and D incorrect. There is an
instanceof keyword. If an object is the wrong type, the equals() method should return
false, making Option C the answer.
|
28_ D. The Hammer class is a subclass of the Tool class. Luckily, the use() method has a different
signature so it is not an override. This means it is fine that the access modifier is stricter,
and Option D is correct. Line r3 is a valid method unrelated to the superclass.
|
29_ B. Lazy instantiation is part of a possible implementation for the singleton pattern. It defers
creating the object until the first caller requests it. While this does save memory, it only
does so if the object is never requested. This does not save memory when actually creating
the object. Option B is correct.
|
30_ D. Notice how the code begins at line 30_ This means you have to infer the surrounding
code. Here it is reasonable to assume the classes are inner classes. Building and House are
defined correctly. Any House or Building reference can potentially be a House. The compiler
does not know which ones work and which don’t. This means all three casts compile.
|
31_ C. Encapsulation doesn’t allow callers access to the instance variables, which makes it
easier to change the code. The instance variables can be any type, which means they can be
mutable or immutable. There are not constraints on the implementation of methods. The
purpose of encapsulation is to lessen how tightly tied or coupled the classes are. Option C is
the opposite of this, making it the answer.
|
32_ A. An immutable class must not allow the state to change. The Flower class does this
correctly. While the class isn’t final, the getters are, so subclasses can’t change the value
returned. The Plant class lacks this protection, which makes it mutable. Option A is correct.
|
33_ D. A static initializer is not allowed inside of a method. It should go on the class level
rather than the method level. Therefore, the code does not compile, and Option D is correct.
|
34_ A. An object is required to have the same value for repeated calls to hashCode() if the value
has not changed. This makes III and IV incorrect. If two objects are equal, they are required
to have the same hash code. Since equality must be reflexive, it cannot return false if the
same object is passed, and I is incorrect. Since equals() must return false when null is
passed in, it cannot be true and II is incorrect. Therefore, Option A is the answer.
|
35_ D. By definition, you cannot change the value of an instance variable in an immutable
class. There are no setter methods, making Option A incorrect. While Option B would
allow you to set the value, the class would no longer be immutable. Option D is correct. If
you are an advanced developer, you might know that you can use reflection to change the
value. Don’t read into questions like this on the exam. Reflection isn’t on the exam, so you
can pretend it doesn’t exist.
|
36_ B. Option A is incorrect because the “is-a” principle is about inheritance. For example, a
String is an Object. Option C is incorrect because singletons require a static variable to
ensure there is only one instance. While it is common to have instance variables as well, this
is not required to implement the pattern. Option B is correct. For an object to be composed
of other objects, instance variables are required.
|
37_ B. The static initializer only runs once since statics are shared by all instances. The instance
initializer runs twice because we call the constructor twice. Therefore, Option B is correct.
|
38_ A. While there is a default keyword in Java, it is only allowed in interfaces or in switch
statements. It is not a visibility modifier. The author of this code probably intended for
the method to be package-private, which doesn’t use a visibility modifier. The line with
default doesn’t compile, so Option A is correct. If default was removed, the code would
all compile.
|
39_ A. The reference b points to a Building object, which cannot be stored in a House reference.
This means the assignment to p compiles but fails at runtime. The other two casts
would run without issue if the code got that far.
|
40_ C. The hashCode() method in the Object class does not have a parameter. Therefore, the
Sticker class provides an overloaded method rather than an overridden one. Since it is
not an overridden method, the contract for the Object class’ hashCode() method does not
apply, and any int value can be returned. Therefore, Option C is correct.
|
1_ B. The lambda expression s -> true is valid, making Options A, C, and D incorrect.
Parentheses () are not required on the left-hand side if there is only one variable. Brackets
{} are not required if the right-hand side is a single expression. Parameter data types are
only required if the data type for at least one parameter is specified, otherwise none are
required. The remaining choice, the arrow operator ->, is required for all lambda expressions,
making Option B the correct answer.
|
2_ D. The application contains a compilation error. The case statements incorrectly use the
enum name as well as the value, such as DaysOff.ValentinesDay. Since the type of the
enum is determined by the value of the variable in the switch statement, the enum name is
not allowed and throws a compilation error when used. For this reason, Option D is correct.
If the enum name DaysOff was removed, the application would output 12, since the
lack of any break statements causes multiple blocks to be reached, and Option C would
have been the correct answer.
|
3_ C. A functional interface must include exactly one abstract method, either by inheritance
or declared directly. It may also have any number, including zero, of default or static
methods. For this reason, both parts of Option D are incorrect. The first part of Option A
is incorrect because more than one abstract method disqualifies it as a functional interface.
The first part of Option B is incorrect because the method must be abstract; that is
to say, any method will not suffice. Finally, Option C is the correct answer. The first part
of the sentence defines what it means to be a functional interface. The second part refers to
the optional @FunctionalInterface annotation. It is considered a good practice to add this
annotation to any functional interfaces you define because the compiler will report a problem
if you define an invalid interface that does not have exactly one abstract method.
|
4_ C. While an anonymous inner class can extend another class or implement an interface, it cannot
be declared final or abstract since it has no class definition. For this reason, Option C is
correct. The other classes may be declared final or abstract since they have a class definition.
|
5_ B. Option A is incorrect because the lambda expression is missing a semicolon (;) at the
end of the return statement. Option C is incorrect because the local variable test is used
without being initialized. Option D is also incorrect. The parentheses are required on the
left-hand side of the lambda expression when there is more than one value or a data type is
specified. Option B is the correct answer and the only valid lambda expression.
|
6_ B. An enum cannot be marked abstract, nor can any of its values, but its methods can be
marked abstract, making Option B the correct answer. Note that if an enum contains an
abstract method, then every enum value must include an override of this abstract method.
|
7_ B. The code compiles without issue, so Option D is incorrect. The first print() statement
refers to value in the Deeper class, so 5 is printed. The second and third print() statements
actually refer to the same value in the Deep class, so 2 is printed twice. The prefix
Matrix. is unnecessary in the first of the two print() statements and does not change the
result. For these reasons, Option B is the correct answer.
|
8_ D. A local inner class can access final or effectively final local variables, making Option
D the correct answer. The second statement is invalid because access modifiers like private
cannot be applied to local variables.
|
9_ C. The type of the variable in the switch statement is the enum Currency, but the case statements
use int values. While the enum class hierarchy does support an ordinal() method,
which returns an int value, the enum values cannot be compared directly with int values. For
this reason, the code does not compile, since the case statement values are not compatible with
the variable type in the switch statement, making Option C the correct answer.
|
10_ C. A local variable is effectively final when it’s primitive value or object reference does not
change after it is initialized, making Option C the correct answer. Option D is incorrect. Any
change to the variable after it is initialized disqualifies it for being considered effectively final.
|
11_ D. Both the Drive and Hover interfaces define a default method getSpeed() with the
same signature. In fact, both getSpeed() methods return the same value of 5_ The class
Car implements both interfaces, which means it inherits both default methods. Since the
compiler does not know which one to choose, the code does not compile, and the answer is
Option D. Note that if the Car class had overridden the getSpeed() method, then the code
would have compiled without issue and printed 10 at runtime. In particular, the local class
Racecar defined in the main() method compiles without issue, making Option C incorrect.
|
12_ B. An interface can be extended by another interface and a class can be extended by another
class, making the second part of Options A, C, and D incorrect. Option B is correct because
an enum cannot be extended. Note that Option C is also incorrect for this reason.
|
13_ B. If the program is called with a single input WEST, then WEST would be printed at runtime.
If the program is called with no input, then the compass array would be of size zero, and an
ArrayIndexOutOfBoundsException would be thrown at runtime. Finally, if the program
is called with a string that does not match one of the values in Direction, then an
IllegalArgumentException would be thrown at runtime. The only result not possible is
south, since the enum value is in uppercase, making Option B the correct answer.
|
14_ B. Enumerated types support creating a set of reusable values whose values are fixed and
consistent across the entire application. For these reason, Options A, C, and D are incorrect.
Option B is the false statement because enum values are defined at compile time and
cannot be changed or added at runtime.
|
15_ D. The program contains three compilation problems. First off, the enum Color extends
the enum Light, but enums cannot extend other enums so the definition is invalid. Second,
the enum value list must end with a semicolon (;) if the enum definition contains anything
other than the enum values. Since it includes a constructor, a semicolon (;) is required after
GREEN. Finally, enum constructors must be private, meaning the protected constructor
for Color does not compile. For these three reasons, Option D is the correct answer.
|
16_ D. Both abstract classes and interfaces can include static methods, so Options A and
C are incorrect. A static nested class can include static methods, but it is the only type
of inner class in which this is allowed. Local inner classes, anonymous inner classes, and
member inner classes do not support static methods. For these reasons, Option D is correct,
and Option B is incorrect.
|
17_ B. A functional interface must contain exactly one abstract method. The Bend interface
contains two abstract methods, pump() and bend(), since it extends Pump and inherits
pump(). For this reason, the Bend method is not a valid functional interface and therefore
cannot be used as a lambda expression, making Option B the correct answer. The rest
of the code compiles without issue. Note that the usage of an instance variable to call a
static method, r.apply() in the main() method, is permitted but discouraged.
|
18_ C. Applying the @Override annotation is optional and not required to override a method or
implement an interface method, making Options A and B incorrect. While partially helpful as
a form of documentation, it is not the best reason to apply the annotation, making Option D
incorrect. The best reason is that the compiler will actually fail to compile if the method that
the @Override annotation is being applied to is not actually overriding an inherited method.
This behavior helps correct typos or changes in superclasses or interfaces that could break the
class or lead to unexpected behavior. For this reason, Option C is the best choice.
|
19_ C. The Bottle class includes a static nested class Ship that must be instantiated in a static
manner. Line w2 uses an instance of Bottle to instantiate the Ship. While this would be
allowed if Ship was a member inner class, since it is a static nested class, line w2 does not
compile, and Option C is the correct answer. Note that if Ship was changed to be a member
inner class, the code would still not compile since a member inner class cannot include
static members and enums are inherently static. Therefore, the correct change would be to
fix the declaration on line w2.
|
20_ A. Option A is the invalid lambda expression because the type is specified for the variable
j, but not the variable k. The rest of the options are valid lambda expressions. To be a valid
lambda expression, the type must be specified for all of the variables, as in Option C, or
none of them, as in Options B and D.
|
21_ D. This application declares an anonymous inner class that implements the Edible interface.
Interface methods are public, whereas the override in the anonymous inner class uses
package-private access. Since this reduces the visibility of the method, the declaration of
eat() on line 8 does not compile. Next, the declaration of the apple object must end with
a semicolon (;) on line 11, and it does not. For these two reasons, the code does not compile,
and Option D is the correct answer. Note that if these two issues were corrected, with
the public modifier and missing semi-colon (;), then the correct answer would be Option
A because the code does not actually call the eat() method; it just declares it.
|
22_ A. The code compiles without issue and prints 15, making Option A correct and Option D
incorrect. The main() method defines a local class Oak that correctly extends Tree, a static
nested class, making Option B incorrect. Finally, the method getWater() is permitted to
read the variable water, defined in the main() method, since it is effectively final, having a
value of 15 when it is defined. For this reason, Option C is also incorrect.
|
23_ C. Interfaces allow Java to support multiple inheritance because a class may implement any
number of interfaces. On the other hand, an anonymous inner class may implement at most
one interface, since it does not have a class definition to implement any others. For these
reasons, Option C is the correct answer.
|
24_ A. The code does not compile because the declaration of isDanger() in the class
SeriousDanger is an invalid method override. An overridden method may not throw a
broader checked exception than it inherits. Since Exception is a superclass of Problem,
thrown by the inherited method in the Danger class, the override of this checked exception
is invalid. For this reason, line m1 does not compile, and Option A is the correct answer.
The rest of the lines of code compile without issue.
|
25_ B. Options A, C, and D are true statements about interfaces and abstract classes. Option B
is the correct answer because neither abstract classes nor interfaces can be marked final.
For Option D, methods and variables can both be marked private in abstract classes in
some cases. The “some cases” refers to the fact that the private modifier cannot be applied
to abstract methods, since a method cannot be marked both final and abstract. Since
abstract classes can contain concrete methods, which can take the private access modifier,
the statement is true.
|
26_ A. The code compiles without issue, so Option C is incorrect. Enum ordinal values are
indexed starting with zero, so 0 is printed first. The second line compiles and runs without
issue, with flurry being converted to FLURRY, using the toUpperCase() method. Since
there is a matching enum named FLURRY, that value is printed next. For these reasons,
Option A is the correct answer.
|
27_ D. Java was updated to include default interface methods in order to support backward
compatibility of interfaces. By adding a default method to an existing interface, we can
create a new version of the interface, which can be used without breaking the functionality
of existing classes that implement an older version of the interface. For this reason, Option
D is the correct answer. Options A and C are not applicable to default interface methods,
whereas Option B could be achieved by using static interface methods.
|
28_ C. The Penguin class includes a member inner class Chick. Member inner classes cannot
include static methods or variables. Since the variable volume is marked static, the member
inner class Chick does not compile, making Option C the correct answer. Note that the variable
volume referenced in the chick() method is one defined in the Penguin outer class. If the
static modifier was removed from the volume variable in the Chick class, then the rest of the
code would compile and run without issue, printing Honk(1)! at runtime.
|
29_ D. Member inner classes require an instance of the surrounding class to be instantiated.
Option A is incorrect since we are told that the instantiation request is from a static
method. Note that this call would be valid from a non-static method in Dinosaur. Option
B is incorrect because it lacks the new keyword. Option C is incorrect. Pterodactyl is a
member inner class, not a static nested class. Option D is correct and uses the instance dino
to create a new Pterodactyl object.
|
30_ C. First off, both CanBurrow and HasHardShell are functional interfaces since
they contain exactly one abstract method, although only the latter uses the optional
@FunctionalInterface annotation. The declarations of these two interfaces, along with
the abstract class Tortoise, compile without issue, making Options A and B incorrect.
The code does not compile, though, so Option D is incorrect. The class DesertTortoise
inherits two abstract methods, one from the interface CanBurrow and the other from the
abstract parent class Tortoise. Since the class only implements one of them and the class
is concrete, the class declaration of DesertTortoise fails to compile on line k3, making
Option C the correct answer.
|
31_ B. First off, the two interface definitions contain identical methods, with the public
modifiers assumed in all interfaces methods. For the first statement, the write()
method is marked default in both interfaces, which means a class can only implement
both interfaces if the class overrides the default method with its own implementation
of the method. Since the Twins method does override write(), the method compiles
without issue, making the first statement incorrect. Next, the publish() method is
marked static in both interfaces and the Twins class. While having a static method
in all three is allowed, marking a static method with the @Override annotation is not
because only member methods may be overridden. For this reason, the second statement
is correct. Finally, the think() method is assumed to be abstract in both interfaces
since it doesn’t have a static or default modifier and does not define a body. The
think() method is then correctly overridden with a concrete implementation in the
Twins class, making the third statement incorrect. Since only the second statement was
true, Option B is the correct answer.
|
32_ D. An enum and static inner class can define static methods, making Option D the correct
answer. Options A, B, and C are incorrect because the other types of inner classes cannot
define static methods. Note that interfaces and abstract classes can define static methods.
|
33_ C. First off, Option A does not compile since the variables p and q are reversed, making the
return type of the method and usage of operators invalid. The first argument p is a String
and q is an int, but the lambda expression reverses them, and the code does not compile.
Option B also does not compile. The variable d is declared twice, first in the lambda
argument list and then in the body of the lambda expression. The second declaration in
the body of the lambda expression causes the compiler to generate a duplicate local variable
message. Note that other than it being used twice, the expression is valid; the ternary
operator is functionally equivalent to the learn() method in the BiologyMaterial class.
Option C is the correct answer since it compiles and handles the input in the same way as
the learn() method in the BiologyMaterial class.
|
34_ C. The code does not compile since it contains two compilation errors, making Option
A incorrect. First, the enum list is not terminated with a semicolon (;). A semicolon (;)
is required anytime an enum includes anything beyond just the list of values, such as a
constructor or method. Second, the access modifier of TRUE’s implementation of getNick-
Name() is package-private, but the abstract method signature has a protected modifier.
Since package-private is a more restrictive access than protected, the override is invalid
and the code does not compile. For these two reasons, Option C is the correct answer. Note
that the @Override annotation is optional in the method signature, therefore FALSE’s version
of getNickName() compiles without issue. Also, note that the Proposition constructor
does not include a private access modifier, but the constructor compiles without issue.
Enum constructors are assumed to be private if no access modifier is specified, unlike
regular classes where package-private is assumed if no access modifier is specified.
|
35_ A. The code compiles and runs without issue, printing 8 at runtime, making Option A correct
and Option D incorrect. The AddNumbers interface is a valid functional interface. While
it includes both static and default methods, it only includes one abstract method, the
precise requirement for it to be considered a functional interface, making Option B incorrect.
Finally, Option C is incorrect because the lambda expression is valid and used correctly.
|
36_ A. While this code included a large number of final modifiers, none of them prevent
the code from compiling when a valid expression is placed in the blank, making Option
D incorrect. Option B is incorrect since it returns the size variable defined in the Insert
member inner class, not the Bottle class, printing 25 at runtime. Option C is incorrect
because the expression is invalid and does not compile when inserted into the blank.
Finally, Option A is the correct answer because it compiles, properly references the variable
size in the Bottle class, and prints 14 at runtime.
|
37_ C. The main() method attempts to define an anonymous inner class instance but fails to
provide the class or interface name, or use the new keyword. The right-hand side of the
assignment to the seaTurtle variable should start with new CanSwim(). For this reason,
Option C is the correct answer. If the code was corrected with the proper declaration, it
would output 7, and Option B would be the correct answer.
|
38_ D. The code does not compile, so Options A and B are incorrect. The declarations of the
local inner classes Robot and Transformer compile without issue. The anonymous inner
class that extends Transformer compiles without issue, since the public variable name is
inherited, making Option C incorrect. The only compilation problem in this class is the
last line of the main() method. The variable name is defined inside the local inner class and
not accessible outside class declaration without a reference to the local inner class. Due to
scope, this last line of the main() method does not compile, making Option D the correct
answer. Note that the first part of the print() statement in the main() method, if the code
compiled, would print GiantRobot.
|
39_ B. The Dancer class compiles without issue, making Option A incorrect. The SwingDancer
class, though, does not compile because getPartner() is an invalid method override. In particular,
Leader and Follower are not covariant since Follower is not a subclass of Leader.
Therefore, line u2 does not compile, making Option B correct and Option D incorrect. Note
that the abstract method getPartner(int) is not implemented in SwingDancer, but this is
valid because SwingDancer is an abstract class and is not required to implement all of the
inherited abstract methods.
|
40_ C. The code does not compile, so Options A and B are incorrect. The problem here is that
the DEFAULT_VALUE is an instance variable, not a static variable; therefore, the static
nested class GetSet cannot access it without a reference to the class. For this reason, the
declaration of the static nested class GetSet does not compile, and Option C is the correct
answer. The rest of the code compiles without issue. Note that if the DEFAULT_VALUE
variable was modified to be static, then the code would compile without issue, and
Option B would be the correct answer.
|
1_ C. When declaring a class that uses generics, you must specify a name for the formal type
parameter. Java uses the standard rules for naming a variable or class. A question mark is
not allowed in a variable name, making I incorrect. While it is common practice to use a
single uppercase letter for the type parameter, this is not required. It certainly isn’t a good
idea to use existing class names like the News class being declared here or the Object class
built into java. However, this is allowed, and Option C is correct.
|
2_ B. Option A is incorrect because the filter() method is available on Stream, but not
List. Option C is incorrect because the replace() method is available on List, but not
Stream. Option D is tricky because there is a sort() method on List and a sorted()
method on Stream. These are different method names though, so Option D is incorrect.
Option B is the answer because both interfaces have a forEach() method.
|
3_ A. Notice how there is unnecessary information in this description. The fact that patrons
select books by name is irrelevant. The checkout line is a perfect example of a doubleended
queue. We need easy access to one end of the queue for patrons to add themselves
to the queue. We also need easy access to the other end of the queue for patrons to get off
the queue when it is their turn. The book lookup by ISBN is a lookup by key. We need
a map for this. A HashMap is probably better here, but it isn’t a choice. So the answer is
Option A, which does include both a double-ended queue and a map.
|
4_ B. Java talks about the collections framework, but the Map interface does not actually
implement the Collection interface. TreeMap has different methods than ArrayDeque and
TreeSet. It cannot fill in the blank, so Option B is correct.
|
5_ B. Options C and D are incorrect because the method signature is incorrect. Unlike the
equals() method, the method in Comparator takes the type being compared as the parameters
when using generics. Option A is a valid Comparator. However, it sorts in ascending
order by length. Option B is correct. If s1 is three characters and s2 is one character, it
returns -2. The negative value says that s1 should sort first, which is correct, because we
want the longest String first.
|
6_ D. TreeMap and TreeSet keep track of sort order when you insert elements. TreeMap
sorts the keys and TreeSet sorts the objects in the set. This makes Option D correct. Note
that you have the option of having JellyBean implement Comparable, or you can pass a
Comparator to the constructor of TreeMap or TreeSet.
|
7_ C. Option A is incorrect because a pipeline still runs if the source doesn’t generate any items
and the rest of the pipeline is correct. Granted some of the operations have nothing to do, but
control still passes to the terminal operation. Option B is incorrect because intermediate operations
are optional. Option C is the answer. The terminal operation triggers the pipeline to run.
|
8_ B. The Iterator interface uses the hasNext() and next() methods to iterate. Since there is
not a hasMore() method, it should be changed to hasNext(), making Option B the answer.
With respect to Option A, the missing generic type gives a warning, but the code still runs. For
Option C, iterators can run as many times as you want, as can the forEach() method on list.
|
9_ A. First the code creates an ArrayList of three elements. Then the list is transformed into
a TreeSet. Since sets are not allowed to have duplicates, the set only has two elements.
Remember that a TreeSet is sorted, which means that the first element in the TreeSet is 3.
Therefore, Option A is correct.
|
10_ C. The word reduction is used with streams for a terminal operation, so Options A and B
are incorrect. Option D describes a valid terminal operation like anyMatch(), but is not a
reduction. Option C is correct because a reduction has to look at each element in the stream
in order to determine the result.
|
11_ A. The offer() method adds an element to the back of the queue. After line 7 completes,
the queue contains 18 and 5 in that order. The push() method adds an element to the front
of the queue. How rude! The element 13 pushes past everyone on the line. After line 8 completes,
the queue now contains 13, 18, and 5, in that order. Then we get the first two
elements from the front, which are 13 and 18, making Option A correct.
|
12_ D. The Magazine class doesn’t implement Comparable<Magazine>. It happens to
implement the compareTo() method properly, but it is missing actually writing
implements Comparable. Since TreeSet doesn’t look to see if the object can be compared
until runtime, this code throws a ClassCastException when TreeSet calls add(), so
Option D is correct.
|
13_ C. Line 8 does not compile. String::new is a constructor reference. A constructor or
method reference is equivalent to a lambda. It participates in deferred execution. When it is
executed later, it returns a String. It does not return a String on line 8_ It actually returns
a Supplier<String>, which cannot be stored in list. Since the code does not compile,
Option C is correct.
|
14_ B. This code adds two elements to a list. It then gets a stream and iterates through the list,
printing two lines. The last line does the same thing again. Since a fresh stream is created,
we are allowed to iterate through it, and Option B is correct.
|
15_ D. The Comic interface declares a formal type parameter. This means that a class implementing
it needs to specify this type. The code on line 21 compiles because the lambda
reference supplies the necessary context making Option A incorrect. Option B declares a
generic class. While this doesn’t tell us the type is Snoopy, it punts the problem to the
caller of the class. The declaration of c2 on line 22 compiles because it supplies the type,
making Option B incorrect. The code on line 23 compiles because the SnoopyClass itself
supplies the type making Option C incorrect. Option D has a problem. SnoopyClass and
SnoopyComic appear similar. However, SnoopyComic refers to C. This type parameter
exists in the interface. It isn’t available in the class because the class has said it is using
Snoopy as the type. Since the SnoopyComic class itself doesn’t compile, the line with c4
can’t instantiate it, and Option D is the answer.
|
16_ A. In streams, the filter() method filters out any values that do not match. This means the
only value to make it to the terminal operator count() is Chicago, and Option A is correct.
|
17_ C. When implementing Comparable, you implement the compareTo() method. Since this is
an instance method, it already has a reference to itself and only needs the item it is comparing.
Only one parameter is specified, and Option C is correct. By contrast, the Comparator
interface uses the compare() method and the method takes two parameters.
|
18_ C. The source and any intermediate operations are chained and eventually passed to the
terminal operation. The terminal operation is where a non-stream result is generated, making
Option C correct.
|
19_ A. A constructor reference uses the new keyword where a method name would normally go
in a method reference. It can implicitly take zero or one parameters just like a method reference.
In this case, we have one parameter, which gets passed to the constructor. Option A is
correct.
|
20_ D. A custom sort order is specified using a Comparator to sort in descending order. However,
this Comparator is not passed when searching. When a different sort order is used for
searching and sorting, the result is undefined. Therefore, Option D is correct.
|
21_ D. Java only allows you to operate on a stream once. The final line of code throws an
IllegalStateException because the stream has already been used up. Option D is the
correct answer.
|
22_ D. The Wash class takes a formal type parameter named T. Option C shows the best way to
call it. This option declares a generic reference type that specifies the type is String. It also
uses the diamond syntax to avoid redundantly specifying the type on the right-hand side of
the assignment. Options A and B show that you can omit the generic type in the reference
and still have the code compile. You do get a compiler warning scolding you for having a
raw type. But compiler warnings do not prevent compilation. With the raw type, the compiler
treats T as if it is of type Object. That is OK in this example because the only method
we call is toString() implicitly when printing the value. Since toString() is defined on
the Object class, we are safe, and Options A and B work. Since all three can fill in the
blank, Option D is the answer.
|
23_ D. The missing generic type gives a warning, but the code still runs, so Option A is incorrect.
The Iterator interface uses hasNext() and next() methods to iterate, so Option
B is incorrect. Option C applies to calling the same stream twice. One of our calls is to an
Iterator anyway, so Option C is incorrect. This code is in fact correct, making the answer
Option D.
|
24_ B. This is a static method reference. It uses :: to separate the class name and method
name. Option B is correct.
|
25_ B. A source and the terminal operation are required parts of a stream pipeline and must
occur exactly once. The intermediate operation is optional. It can appear zero or more
times. Since more than once falls within zero or more, Option B is correct.
|
26_ B. ArrayList allows null elements, making Option B correct. TreeSet does not allow
nulls because they need to compare the values. ArrayDeque uses null for a special meaning,
so it doesn’t allow it in the data structure either.
|
27_ D. Option A is the only one of the three options to compile. However, it results in no lines
being output since none of the three strings are empty. Options B and C do not even compile
because a method reference cannot have an operator next to it. Therefore, Option D is correct.
|
28_ A. Unfortunately you do have to memorize two facts about sort order. First, numbers sort
before letters. Second, uppercase sorts before lowercase. Since TreeMap orders by key, the
first key is 3 and the last is three, making Option A correct.
|
29_ C. The ? is an unbounded wildcard. It is used in variable references but is not allowed in
declarations. In a static method, the type parameter specified inside the <> is used in the
rest of the variable declaration. Since it needs an actual name, Options A and B are incorrect.
We need to specify a type constraint so we can call the add() method. Regardless of
whether the type is a class or interface, Java uses the extends keyword for generics. Therefore,
Option D is incorrect, and Option C is the answer.
|
30_ B. On a stream, the filter() method only keeps values matching the lambda. The
removeIf() does the reverse on a Collection and keeps the elements that do not match.
In this case, that is Austin and Boston so Option B is correct.
|
31_ D. The code correctly creates an ArrayDeque with three elements. The stream pipeline does
compile. However, there is no terminal operation, which means the stream is never evaluated
and the output is something like java.util.stream.ReferencePipeline$2@404b9385.
This is definitely not one of the listed choices, so Option D is correct.
|
32_ C. The forEach() method that takes one parameter is defined on the Collection interface.
However, a map is not a Collection. There is a version of forEach() defined on
the Map interface, but it uses two parameters. Since two parameters can’t be used with a
method reference, Option C is the answer.
|
33_ C. This code is almost correct. Calling two different streams is allowed. The code attempts
to use a method reference when calling the forEach() method. However, it does not use
the right syntax for a method reference. A double colon needs to be used. The code would
need to be changed to System.out::println to work and print two lines for each call.
Since it does not compile, Option C is correct.
|
34_ B. This code shows a proper implementation of Comparable. It has the correct method
signature. It compares the magazine names in alphabetical order. Remember that uppercase
letters sort before lowercase letters. Since Newsweek is uppercase, Option B is correct.
|
35_ C. The filter() method requires a boolean returned from the lambda or method reference.
The getColor() method returns a String and is not compatible. This causes the
code to not compile and Option C to be correct.
|
36_ A. Option A is correct as the source and terminal operation are mandatory parts of a
stream pipeline. Option B is incorrect because a Stream must return non-primitives.
Specialized interfaces like IntStream are needed to return primitives. Option C is incorrect
because Stream has methods such as of() and iterate() that return a Stream. Option D
is incorrect because infinite streams are possible.
|
37_ B. The stream pipeline is correct and filters all values out that are 10 characters or smaller.
Only San Francisco is long enough, so c is 1. The stream() call creates a new object, so
stream operations do not affect the original list. Since the original list is still 3 elements,
Option B is correct.
|
38_ B. Options A and C are incorrect because a generic type cannot be assigned to another
direct type unless you are using upper or lower bounds in that statement. Now, we just
have to decide whether a lower or upper bound is correct for the T formal type parameter
in Wash. The clue is that the method calls size(). This method is available on Collection
and all classes that extend/implement it. Therefore, Option B is correct.
|
39_ C. A Comparator takes two parameters, so Options A and B are incorrect. Option D
doesn’t compile. When using brackets, a return keyword and semicolon are required.
Option C is a correct implementation.
|
40_ B. Option D is incorrect because there is a charAt() instance method. While Option C is
correct that the method takes in an int parameter, autoboxing would take care of conversion
for us if there were no other problems. So Option C is not the answer. Option A is not
true because there are constructor and instance method references. Option B is the answer.
With method references, only one item can be supplied at runtime. Here, we need either a
String instance with no parameters in the method or a static method with a single parameter.
The charAt() method is an instance method with a single parameter so does not meet
this requirement.
|
1_ C. The Supplier functional interface does not take any inputs, while the Consumer functional
interface does not return any data. This behavior extends to the primitive versions of
the functional interfaces, making Option C the correct answer. Option A is incorrect because
IntConsumer takes a value, while LongSupplier returns a value. Options B and D are incorrect
because Function and UnaryOperator both take an input and produce a value.
|
2_ A. The LongSupplier interface does not take any input, making Option D incorrect. It
also uses the method name getAsLong(). The rest of the functional interfaces all take a
long value but vary on the name of the abstract method they use. LongFunction contains
apply() and LongPredicate contains test(), making Options B and C, respectively,
incorrect. That leaves us with LongConsumer, which contains accept(), making Option A
the correct answer.
|
3_ A. The code compiles without issue, so Options C and D are incorrect. The value for distance
is 2, which based on the lambda for the Predicate will result in a true expression,
and Saved will be printed, making Option A correct.
|
4_ C. Both are functional interfaces in the java.util.function package, making Option A
true. The major difference between the two is that Supplier<Double> takes the generic
type Double, while the other does not take any generic type and instead uses the primitive
double. For this reason, Options B and D are true statements. For Supplier<Double>
in Option B, remember that the returned double value can be implicitly cast to Double.
Option C is the correct answer. Lambdas for Supplier<Double> can return a null value
since Double is an object type, while lambdas for DoubleSupplier cannot; they can only
return primitive double values.
|
5_ B. The lambda (s,p) -> s+p takes two arguments and returns a value. For this reason,
Option A is incorrect because BiConsumer does not return any values. Option D is also
incorrect, since Function only takes one argument and returns a value. This leaves us with
Options B and C, which both use BiFunction, which takes two generic arguments and
returns a generic value. Option C is incorrect because the datatype of the unboxed sum s+q
is int and int cannot be autoboxed or implicitly cast to Double. Option B is correct. The
sum s+p is of type double, and double can be autoboxed to Double.
|
6_ C. To begin with, ToDoubleBiFunction<T,U> takes two generic inputs and returns a
double value. Option A is compatible because it takes an Integer and Double and returns
a Double value that can be implicitly unboxed to double. Option B is compatible because
long can be implicitly cast to double. While we don’t know the data types for the input
arguments, we know that some values, such as using Integer for both, will work. Option
C cannot be assigned and is the correct answer because the variable v is of type Object and
Object does not have a length() method. Finally, Option D is compatible. The variable y
could be declared double in the generic argument to the functional interface, making y/z a
double return value.
|
7_ C. The BiPredicate interface takes two generic arguments and returns a boolean value.
Next, DoubleUnaryOperator takes a double argument and returns a double value. Last,
ToLongFunction takes a generic argument and returns a long value. That leaves Option
C, which is the correct answer. While there is an ObjDoubleConsumer functional interface,
which takes a generic argument and a double value and does not return any data, there is
no such thing as ObjectDoubleConsumer. Remember that Object is abbreviated to Obj in
all functional interfaces in java.util.function.
|
8_ C. The code does not compile, so Options A and D are incorrect. The IntUnaryOperator
functional interface is not generic, so the argument IntUnaryOperator<Integer> in the
takeTicket() does not compile, making Option C the correct answer. The lambda expression
compiles without issue, making Option B incorrect. If the generic argument <Integer>
was dropped from the argument declaration, the class would compile without issue and
output 51 at runtime, making Option A the correct answer.
|
9_ A. Option A is the correct answer because BiPredicate takes two generic types and
returns a primitive boolean value. Option B is incorrect, since CharSupplier does not
exist in java.util.function. Option C is also incorrect, since LongFunction takes a
primitive long value and returns a generic type. Remember, Java only includes primitive
functional interfaces that operate on double, int, or long. Finally, Option D is incorrect.
UnaryOperator takes a generic type and returns a generic value.
|
10_ D. First off, the forEach() method requires a Consumer instance. Option C can be immediately
discarded because Supplier<Double> does not inherit Consumer. For this same reason,
Option B is also incorrect. DoubleConsumer does not inherit from Consumer. In this
manner, primitive functional interfaces cannot be used in the forEach() method. Option
A seems correct, since forEach() does take a Consumer instance, but it is missing a generic
argument. Without the generic argument, the lambda expression does not compile because
the expression p<5 cannot be applied to an Object. The correct functional interface is
Consumer<Double>, and since that is not available, Option D is the correct answer.
|
11_ C. BiFunction<Double,Double,Double> and BinaryOperator<Double> both take
two Double input arguments and return a Double value, making them equivalent to one
another. On the other hand, DoubleFunction<Double> takes a single double value and
returns a Double value. For this reason, it is different from the other two, making Option C
correct and Option D incorrect.
|
12_ B. BinaryOperator<Long> takes two Long arguments and returns a Long value. For this
reason, Option A, which takes one argument, and Option D, which takes two Integer
values that do not inherit from Long, are both incorrect. Option C is incorrect because the
local variable c is re-declared inside the lambda expression, causing the expression to fail
to compile. The correct answer is Option B because intValue() can be called on a Long
object. The result can then be cast to long, which is autoboxed to Long.
|
13_ C. The program does not compile, so Option A is incorrect. The Supplier functional
interface normally takes a generic argument, although generic types are not strictly required
since they are removed by the compiler. Therefore, line d1 compiles while triggering a compiler
warning, and Options B and D are incorrect. On the other hand, line d2 does cause a
compiler error, because the lambda expression does not return a value. Therefore, it is not
compatible with Supplier, making Option C the correct answer.
|
14_ A. The input type of a unary function must be compatible with the return type. By compatible,
we mean identical or able to be implicitly cast. For this reason, Option A is the correct
answer. Option B is incorrect since all of the UnaryOperator functional interfaces, generic
or primitive, take exactly one value. Option C is incorrect because the primitive functional
interfaces do not take a generic argument. Finally, Option D is incorrect. For example, the
generic UnaryOperator<T> returns an Object that matches the generic type.
|
15_ C. Remember that all Supplier interfaces take zero parameters. For this reason, the third
value in the table is 0, making Options A and B incorrect. Next, DoubleConsumer and
IntFunction each take one value, double and int, respectively. On the other hand,
ObjDoubleConsumer takes two values, a generic value and a double, and returns void. For
this reason, Option C is correct, and Option D is incorrect.
|
16_ D. All Consumer functional interfaces have a void return type. For this reason, the
first and last values in the table are both void, making Options A and B incorrect.
IntFunction takes an int and returns a generic value, while LongSupplier does not
take any values and returns a long value. For this reason, Option C is incorrect, and
Option D is correct.
|
17_ B. The removeIf() method requires a Predicate since it operates on a boolean result,
making Option A incorrect. The forEach() method takes a Consumer and does not return
any data, making Option B correct, and Options C and D incorrect.
|
18_ C. The code does not compile, so Option A is incorrect. The lambda expression
compiles without issue, making Option B incorrect. The task variable is of type
UnaryOperator<Doll>, with the abstract method apply(). There is no accept()
method defined on that interface, therefore the code does not compile, and Option C
is the correct answer. If the code was corrected to use the apply() method, the rest of
it would compile without issue. At runtime, it would then produce an infinite loop. On
each iteration of the loop, a new Doll instance would be created with 5, since the postdecrement
(--) operator returns the original value of the variable, and that would make
Option D the correct answer.
|
19_ C. To begin with, Consumer uses accept(), making Option A incorrect. Next, Function
and UnaryOperator use apply(), making Options B and D, respectively, incorrect. Finally,
Supplier uses get(), making Option C the correct answer.
|
20_ D. First off, Options A and B are incorrect because the second functions for both
return a double or Double value, respectively. Neither of these values can be sent to a
UnaryOperator<Integer> without an explicit cast. Next, Option C is incorrect. The first
functional interface Function<Double,Integer> takes only one input, but the diagram
shows two inputs for the first functional interface. That leaves us with Option D. The
first functional interface BiFunction<Integer,Double,Integer> takes an int, which
can be implicitly autoboxed to Integer, and a Double and returns an Integer. The next
functional interface, BinaryOperator<Integer>, takes two Integer values and returns
an Integer value. Finally, this Integer value can be implicitly unboxed and sent to
IntUnaryOperator, returning an int. Since these behaviors match our diagram, Option D
is the correct answer.
|
21_ D. Options A, B, and C are true statements about functional interfaces. A lambda may
be compatible with multiple functional interfaces, but it must be assigned to a functional
interface when it is declared or passed as a method argument. Also, a method can be created
with the return type that matches a functional interface, allowing a lambda expression
to be returned. Option D is the correct answer. Deferred execution means the lambda
expression is not evaluated until runtime, but it is compiled. Compiler errors in the lambda
expression will prevent the code from compiling.
|
22_ B. Option A is incorrect because the String "3" is not compatible with the return type
int required for IntSupplier. Option B is the correct answer. Although this will result in
a divide by zero issue at runtime, the lambda is valid and compatible with IntSupplier.
Option C is incorrect because the lambda expression is invalid. The return statement is only
allowed inside a set of brackets {}. Finally, Option D is incorrect. The method reference is
used for Supplier, not Consumer, since it takes a value and does not return anything.
|
23_ C. The lambda expression is invalid because the input argument is of type Boss, and Boss
does not define an equalsIgnoreCase() method, making Option C the correct answer. If
the lambda was corrected to use s.getName() instead of s, the code would compile and
run without issue, printing [JENNY, GRACE] at runtime and making Option A the correct
answer.
|
24_ D. First of all, Consumer<Object> takes a single Object argument and does not return
any data. The classes ArrayList and String do not contain constructors that take an
Object, so neither of the first two statements are correct. The third statement does support
an Object variable, since the System.out.println(Object) method exists. For these reasons,
Option D is the correct answer.
|
25_ B. The java.util.function package does not include any functional interfaces that
operate on the primitive float, making Option A incorrect. Remember, Java only includes
primitive functional interfaces that operate on double, int, or long. Option B is correct
because it is a valid functional interface. Option C is incorrect because there is no
UnaryIntOperator functional interface. Note that there is one called IntUnaryOperator.
Option D is incorrect. The java.util.function package does not include any tri- operators,
although many are easy to write.
|
26_ D. A lambda expression can match multiple functional interfaces. It matches
DoubleUnaryOperator, which takes a double value and returns a double value. Note that
the data type of s+1 is double because one of the operands, in this case s, is double. It also
matches Function<String,String> since the (+) operator can be used for String concatenation.
Finally, it matches IntToLongFunction since the int value s+1can be implicitly
cast to long. On the other hand, the lambda expression is not compatible with UnaryOperator
without a generic type. When UnaryOperator is used without a generic argument, the
type is assumed to be Object. Since the (+) operator is not defined on Object, the code
does not compile due to the lambda expression body, making Option D the correct answer.
Note that if the lambda expression did not rely on the (+) operator, such as s -> s, then
UnaryOperator would be allowed by the compiler, even without a generic type.
|
27_ B. The BiFunction interface takes two different generic values and returns a generic value,
taking a total of three generic arguments. Next, ToDoubleFunction takes exactly one
generic value and returns a double value, requiring one generic argument. The
ToIntBiFunction interface takes two generic values and returns an int value, for a total
of two generic arguments. For these reasons, Options A, C, and D are incorrect. The
correct answer is Option B. DoubleFunction takes a double value and returns a generic
result, taking exactly one generic argument, not two.
|
28_ D. While lambda expressions can use primitive types as arguments, the functional interface
in this class uses the wrapper classes, which are not compatible. For this reason, Option A is
incorrect. Option B is also incorrect, since the number of arguments and return type does not
match the functional interface. Furthermore, the method reference System.out::print on
the right-hand side of the lambda expression is invalid here, since it returns a method reference,
not a double value. Option C is incorrect because 2*w is of type double, which cannot
be returned as an Integer without an explicit cast. Option D is the correct answer. It takes
exactly two arguments because the return value int can be implicitly autoboxed to Integer.
|
29_ A. BooleanSupplier is the only functional interface that does not involve double, int,
or long, making Option A the correct answer. The rest of the functional interfaces are not
found in java.util.function. Java does not have built-in support for primitive functional
interfaces that include char, float, or short.
|
30_ D. The code does not compile because the lambda expression p -> p*100 is not compatible
with the DoubleToIntFunction functional interface. The input to the functional interface
is double, meaning p*100 is also double. The functional interface requires a return
value of int, and since double cannot be implicitly cast to int, the code does not compile,
making Option D the correct answer. If the correct cast was applied to make (p*100) an
int, then the rest of the class would compile and 250 would be printed at runtime, making
Option B correct.
|
31_ B. The ToDoubleFunction interface takes a generic value, not a double value, making
Option D incorrect. It also uses the method name accept(). The rest of the functional
interfaces all take a double value. DoubleConsumer contains the accept() method, making
Option A incorrect. DoublePredicate contains the test() method, making Option B
the correct answer. Finally, DoubleUnaryOperator contains the applyAsDouble() method,
making Option C incorrect.
|
32_ D. To start with, line 5 does not compile because Function takes two generic arguments,
not one. Second, the assignment statement on line 7 does not end with a semicolon (;), so
it also does not compile. Finally, the forEach() method on line 10 requires a Consumer,
not a Function, so this line does not compile. For these three reasons, Option D is the
correct answer.
|
33_ D. The DoubleToLongFunction interface takes a double argument and returns a long
value. Option A is compatible since the int value 1 can be implicitly cast to long, and 2L
is already a long. Option B is also compatible, since the double value 10.0*e is explicitly
cast to int then implicitly cast to long. Next, Option C is compatible because an explicit
cast of the double to a long value is used. Option D cannot be assigned and is the correct
answer. Although the Double class does have a longValue() method, the left-hand side
of the lambda expression must use the primitive double, not the wrapper Double. This
lambda expression violates the signature of the functional interface, since it allows Double
values to be sent to the interface, including those that could be null.
|
34_ C. The DoublePredicate interface takes a double value and returns a boolean value.
LongUnaryOperator takes a long value and returns a long value. ToIntBiFunction takes
two generic values and returns an int value. The only choice that is not an existing functional
interface is ShortSupplier. Recall that Java only includes primitive functional interfaces
that operate on double, int, or long. For this reason, Option C is the correct answer.
|
35_ A. The method reference System.out::println takes a single input and does not return
any data. Consumer<Sheep> is compatible with this behavior, making Option A the correct
answer and Option D incorrect. Option B is incorrect because void cannot be used as
a generic argument. Option C is incorrect since System.out::println() does not return
any data and UnaryOperator requires a return value.
|
36_ C. The code does not compile, making Options A and B incorrect. The local variable
MAX_LENGTH is neither final nor effectively final, meaning it cannot be used inside the lambda
expression. The MAX_LENGTH variable starts off with an initial value of 2, but then is modified
with the increment assignment (+=) operator to a value of 5, disqualifying its ability to be considered
effectively final by the compiler. Since the lambda does not compile, Option C is the correct
answer. If the code was rewritten so that the MAX_LENGTH variable was marked final and
assigned a value of 5 from the start, then it would output 2, and Option A would be correct.
|
37_ B. To begin with, all of the functional interfaces in the list of choices take two values.
The difference is in the name of the method they use. BiConsumer uses accept(),
making Option A incorrect. Option B is correct because BiFunction includes the
apply() method. Option C is incorrect, since BiPredicate uses the test() method.
DoubleBinaryOperator is almost correct but the name of the method is applyAsDouble(),
not apply(), making Option D incorrect. For the exam, you should be aware of which
primitive functional interfaces use a different method name than the generic ones.
|
38_ B. To start with, IntFunction<Integer> takes an int value and returns an Integer. The
first statement uses Integer instead of int as the input argument and is therefore not compatible.
The second statement is compatible, since the return type null can be used as an
Integer return type. The last statement is also valid. An int can be autoboxed to Integer.
For these reasons, Option B is the correct answer.
|
39_ C. The primitive Supplier functional interfaces, such as BooleanSupplier and
LongSupplier, do not have a get() method. Instead, they have methods such as
getAsBoolean() and getAsLong(), respectively. For this reason, the first line of the
checkInventory() method does not compile, making Option C the correct answer. If
the method call was changed to getAsBoolean(), then the rest of the code would compile
without issue, print Plenty! at runtime, and Option A would be the correct answer.
|
40_ B. Java only supports a single return data type or void. Therefore, it is not possible to
define a functional interface that returns two data types, making Option A incorrect.
Although Java does not include built-in support for primitive functional interfaces that
include float, char, or short, there is nothing to prevent a developer from creating them
in their own project, making Option B the true statement and the correct answer. Option C
is incorrect because a functional interface that takes no values and returns void is possible.
In fact, Runnable is one such example. Option D is also incorrect, since IntFunction<R>
takes a primitive argument as input and a generic argument for the return type.
|
1_ D. Option A is incorrect because it doesn’t print out one line. The peek() method is an
intermediate operation. Since there is no terminal operation, the stream pipeline is not
executed, so the peek() method is never executed. Options B and C are incorrect because
they correctly output one line using a method reference and lambda, respectively, and don’t
use any bad practices. Option D is the answer. It does output one line. However, it is bad
practice to have a peek() method that has side effects like modifying a variable.
|
2_ A. This code generates an infinite stream of integers: 1, 2, 3, 4, 5, 6, 7, etc. The Predicate
checks if the element is greater than 5. With anyMatch(), the stream pipeline ends once element
6 is hit and the code prints true. For both the allMatch() and noneMatch() operators,
they see that the first element in the stream does not match and the code prints false.
Therefore, Option A is correct.
|
3_ B. Only the average() method returns an OptionalDouble. This reflects that it doesn’t
make sense to calculate an average when you don’t have any numbers. By contrast, counting
without any numbers gives the long number 0 and summing gives the double number 0.0.
Since only one method matches the return type, Option B is correct.
|
4_ C. The map() method can fill in the blank. The lambda converts a String to an int and
Java uses autoboxing to turn that into an Integer. The mapToInt() method can also fill
in the blank and Java doesn’t even need to autobox. There isn’t a mapToObject() in the
stream API. Note there is a similarly named mapToObj() method on IntStream. Since both
map() and mapToInt() work here, Option C is correct.
|
5_ D. The average() method returns an OptionalDouble. This interface has a getAsDouble()
method rather than a get() method, so the code does compile. However, the stream is
empty, so the optional is also empty. When trying to get the value, the code throws a
NoSuchElementException, making Option D correct.
|
6_ D. Option A is incorrect because anyMatch() returns a boolean. Option B is incorrect
because filter() is an intermediate operation, not a terminal operation, and therefore
returns a Stream. Both of these methods do take a Predicate as a parameter. While
findAny() does return an Optional, it doesn’t take any parameters. Therefore, Option C
is incorrect, and Option D is the answer.
|
7_ B. This code builds a list with two elements. It then uses that list as a source for the stream,
sorts the stream as it goes by, and grabs the first sorted element. This does not change the
original list. The first element in the sorted stream is 1.2, but the first element of list
remains as 5.4. This makes Option B correct.
|
8_ B. Primitive streams, like LongStream, declare an average() method, while summary
statistics classes, like LongSummaryStatistics, declare a getAverage() method, making
Options C and D incorrect. The average() method returns an OptionalDouble object,
which declares a getAsDouble() method rather than a get() method. Therefore, Option A
is incorrect, and Option B is correct.
|
9_ B. Since the result of the collect() is not stored in a variable or used in any way, all the
code needs to do is compile. There is no Collectors.toArrayList() method. If you want
to specify an ArrayList, you can call Collectors.toCollection(ArrayList::new).
The Collectors.toList() method does in fact exist and compile. While there is a
Collectors.toMap() method, it requires two parameters to specify the key and value
functions, respectively. Since only one can compile, Option B is correct.
|
10_ C. As tempting as it is, you can’t actually convert a Map into a Stream directly, which
means you can’t call the map() method on it either. However, you can build a Stream out of
the keys or values or key/value pairs. Since this code doesn’t compile, Option C is correct.
|
11_ D. I is incorrect because isPresent() returns false for an empty Optional. II is incorrect
because of() throws a NullPointerException if you try to pass a null reference.
III doesn’t throw an exception as the ofNullable() is designed to allow a null reference.
However, it returns false because no value is present. Since none of the choices are correct,
Option D is the answer.
|
12_ A. This code does compile. Remember that imports are implied, including the static
import for Collectors. The collector tries to use the number of characters in each stream
element as the key in a map. This works fine for the first two elements, speak and bark,
because they are of length 5 and 4, respectively. When it gets to meow, it sees another key
of 4_ The merge function says to use the first one, so it chooses bark for the value. Similarly,
growl is 5 characters, but the first value of speak is used. There are only two distinct
lengths, so Option A is correct.
|
13_ C. For the primitive stream that contains the int primitives, the interface names are incorrect.
They should be IntStream and IntSummaryStatistics, making Option C correct. If
this was fixed, Option B would be the answer.
|
14_ B. This code does compile. As an intermediate operation, you are allowed to call peek()
many times in a stream pipeline. You can even call it multiple times in a row. While it is
common to write System.out::println directly as a parameter to peek(), nothing prevents
you from creating a Consumer variable. Since the forEach() method also takes a
Consumer, we can reuse it. The three peek() intermediate operations and one forEach()
operation total four lines of output. The map() operation could be omitted since it simply
passes the input through.
|
15_ B. Character objects are allowed in a Stream, so line z1 compiles, making Option C
incorrect. Line z2 also compiles since findAny() returns an Optional and ifPresent() is
declared on Optional. Therefore, Option D is also incorrect. Now let’s look at the Stream.
The source has three elements. The intermediate operation sorts the elements and then we
request one from findAny(). The findAny() method is not guaranteed to return a specific
element. Since we are not using parallelization, it is highly likely that the code will print a.
However, you need to know this is not guaranteed, making Option B the answer.
|
16_ A. The sorted() method takes an optional Comparator as the parameter, which takes two
String parameters and returns an int. Option A is correct because the lambda implements
this interface. Option B is incorrect because the method reference doesn’t take any parameters,
nor does it return an int.
|
17_ D. The Optional class has an isPresent() method that doesn’t take any parameters. It
returns a boolean and is commonly used in if statements. There is also an ifPresent()
method that takes a Consumer parameter and runs it only if the Optional is non-empty.
The methods isNotNull() and forEach()are not declared in Optional. Therefore, Option
D is correct.
|
18_ C. The first intermediate operation, limit(1), turns the infinite stream into a stream with
one element: true. The partitioningBy() method returns a map with two keys, true
and false, regardless of whether any elements actually match. If there are no matches, the
value is an empty list, making Option C correct.
|
19_ B. The flatMap() method is used to turn a stream of streams into a one-dimensional
stream. This means it gets rid of the empty list and flattens the other two. Option A is
incorrect because this is the output you’d get using the regular map() method. Option B is
correct because it flattens the elements. Notice how it doesn’t matter that all three elements
are different types of Collection implementations.
|
20_ D. The sorted() method allows an optional Comparator to be passed as a reference.
However, Comparator.reverseOrder() does not implement the Comparator interface. It
takes zero parameters instead of the required two. Since it cannot be used as a method reference,
the code does not compile, and Option D is correct.
|
21_ D. Option A is incorrect because the findAny() might not return 1. The result could
be any of the three numbers. Option B is incorrect because there is no first() method
available as a terminal operation. Option C is tempting because there is a min() method.
However, since we are working with a Stream, this method requires a Comparator as a
parameter. Therefore, Option D is the answer.
|
22_ C. List doesn’t have a filter() method, so Option A is incorrect. Stream does have
filter() and map() methods. However, Stream doesn’t have an ifPresent() method.
This makes IV incorrect, so Options B and D are incorrect. Both Collection and String
have an isEmpty() method, so either can be used with the Optional, making Option C the
answer.
|
23_ D. This code generates an infinite stream of the number 1. The Predicate checks if the
element is greater than 5. This will never be true. With allMatch(), the stream pipeline
ends after checking the first element. It doesn’t match, so the code prints false. Both
anyMatch() and noneMatch() keep checking and don’t find any matches. However, they
don’t know if a future stream element will be different, so the code executes infinitely until
the process is terminated. Therefore, Option D is correct.
|
24_ D. Both Collectors.groupingBy() and Collectors.partitioningBy() are useful for
turning a stream into a Map. The other two methods do not exist. However, when using a
condition, you should use partitioningBy() as it automatically groups using a Boolean
key. Therefore, Option D is correct.
|
25_ B. Option A is incorrect because we are working with primitives rather than objects.
Option C compiles but outputs the stream references rather than the contents. Option B is
correct because it flattens the int primitives into one stream.
|
26_ D. The summary statistics classes provide getters in order to access the data. The
getAverage() method returns a double and not an OptionalDouble. Option D is the only
option to compile.
|
27_ D. Option A doesn’t compile because the get() method on Optional doesn’t take any
parameters. Options B and C do compile, but both print Cupcake since the Optional is not
empty. Therefore, Option D is correct.
|
28_ C. The first line generates an infinite stream. The stream pipeline has a filter that lets all
these elements through. Since sorted() requires all the elements be available to sort, it
never completes, making Option C correct.
|
29_ A. The mapToDouble() method compiles. However, it converts 9 into 9.0 rather than the
single digit 9. The mapToInt() method does not compile because a long cannot be converted
into an int without casting. The mapToLong() method is not available on LongStream so it
does not compile. It is available on DoubleStream, IntStream, and Stream implementations.
Since none of the options outputs the single digit 9, Option A is correct.
|
30_ A. The filter() method either passes along a given element or doesn’t, making Option D
incorrect. The flatMap() method doesn’t pass along any elements for empty streams. For
non-empty streams, it flattens the elements, allowing it to return zero or more elements.
This makes Option B incorrect. Finally, the map() method applies a one-to-one function for
each element. It has to return exactly one element, so Option A is the correct answer.
|
31_ D. First, we sort the stream. Option B is incorrect because findFirst() is guaranteed to
return the first element. However, the findFirst() method returns an Optional. Therefore,
the output of this code is Optional[a] rather than the letter a, making Option D correct.
|
32_ C. There is not a stream pipeline method called sort(). There is one called sorted().
Since the code does not compile, Option C is correct. If this was fixed, Option A would be
correct since the Comparator sorts in ascending order.
|
33_ B. This code compiles. It creates a stream of Ballot objects. Then it creates a map with the
contestant’s name as the key and the sum of the scores as the value. For Mario, this is 10 +
9, or 19, so Option B is correct.
|
34_ D. Both anyMatch() and allMatch() take a Predicate as a parameter. This code does
not compile because the parameter is missing.
|
35_ D. The flatMap() method works with streams rather than collections. The code does not
compile because the x is not a stream, making Option D correct. If this was fixed, Option B
would be the answer.
|
36_ C. The groupingBy() collector always returns a Map (or a specific implementation
class of Map), so III can’t be right. The other two are definitely possible. To get I, you
can group using a Function that returns an Integer such as s.collect(Collectors
.groupingBy(String::length)). To get II, you need to group using a Function
that returns a Boolean and specify the type, such as s.collect(Collectors
.groupingBy(String::isEmpty, Collectors.toSet())). Notice that autoboxing is
used for both. Therefore, Option C is correct.
|
37_ D. There is no built-in method to map a value to a boolean primitive. Therefore, Options B
and C don’t even compile, so they are incorrect. Option A does compile as it maps a Runner
to a Boolean. However, it doesn’t actually filter() the stream to eliminate any values,
so the output is not the same. It prints 3 instead of 1. None of these are correct, making
Option D the answer.
|
38_ A. Option A is the answer because there is a getCount() method that returns a long
rather than a method named getCountAsLong(). Option B is incorrect because there is in
fact a getMax() method. Option C is incorrect because toString() is declared on Object,
which means it is inherited by all classes.
|
39_ C. The main() method has warnings, but it does compile, making Option D incorrect. The
warnings are both about not declaring the generic type for Optional. Option A does not
compile because the orElse() method expects an Exception as the alternate value passed
as a parameter. IllegalArgumentException::new is a Supplier instead. Options B and C
both compile as both methods expect a Supplier as the parameter. However, orElseGet()
simply returns the exception from the method rather than throwing it. Option C actually
throws the exception the Supplier created and is the correct answer.
|
40_ B. Option A happens to output the same result for both pairs. It outputs a blank line in
withFlatMap() because empty streams are removed and in withoutFlatMap() because
the filter() method removes the empty list. Option B outputs different results. The
withFlatMap() method outputs lastall queued up since it flattens the streams. By contrast,
the withoutFlatMap() method outputs [last, all queued up] since it leaves the
structure intact. Since the output is different. Option B produces different results so it is the
answer.
|
1_ D. If no exception is thrown, then the catch block will not be executed. The try block is
always visited first, followed by the finally block, which is guaranteed to execute regardless
of whether an exception is thrown. For these reasons, Option D is the correct answer,
with the statements in the correct order.
|
2_ C. Unlike a try-with-resources statement, in which the catch and finally blocks are
optional, a try statement requires a catch or finally block to be used, or both. For this
reason, Option C is the correct answer.
|
3_ D. The code does not compile because the throw keyword is incorrectly used in the toss()
method declaration. The keyword throws should have been used instead. For this reason,
Option D is the correct answer. Since LostBallException inherits Throwable and the main()
method handles Throwable, LostBallException is handled by the main() method, making
Option B incorrect. Option C is also incorrect because ArrayStoreException is an unchecked
exception that extends RuntimeException and is not required to be handled or declared.
Finally, if throws was used instead of throw, the entire application would compile without
issue and print Caught!, making Option A the correct answer.
|
4_ A. The only symbol permitted to separate exception types in a multi-catch statement is a
single pipe character (|). For this reason, Option A is correct.
|
5_ D. In Java, assert is a keyword, meaning it cannot be used as a variable, class, or method
name. For this reason, line 5 does not compile. Line 6 also does not compile because the
assert statement is not a method and does not support parentheses around both expressions.
Because neither of these lines compile, Option D is the correct answer.
|
6_ C. First off, Error is an unchecked exception. It is recommended that Error not be
caught by most application processes, making Option A incorrect. IllegalStateException
inherits RuntimeException, both of which are unchecked, making Options B and D,
respectively, incorrect. Option C is correct because ParseException must be handled or
declared.
|
7_ D. The Exception class contains multiple constructors, including one that takes
Throwable, one that takes String, and a no-argument constructor. The first
WhaleSharkException constructor compiles, using the Exception constructor that takes a
String. The second WhaleSharkException constructor also compiles. The two statements,
super() and new Exception(), actually call the same constructor in the Exception class,
one after another. The last WhaleSharkException compiles with the compiler inserting
the default no-argument constructor super(), because it exists in the Exception class. For
these reasons, all of the constructors compile, and Option D is the correct answer.
|
8_ B. The UnsupportedOperationException class is an unchecked exception, which means
it inherits from RuntimeException. While Error also is an unchecked exception, the diagram
indicates that the class does not inherit from Error. There is only one class between
Throwable and RuntimeException in the diagram, and since we know RuntimeException
inherits Exception, the other missing class must be Exception. For these reasons, Option
B is the correct answer.
|
9_ C. The code does not compile because the variable b is used twice in the main() method,
both in the method declaration and in the catch block, making Option C the correct
answer. If a different variable name was used in one of the locations, the program would
print one line, complete, making Option A the correct answer. Note that while an exception
is created inside the turnOn() method, it is not thrown.
|
10_ D. First off, unless assertions are enabled at runtime, no assertion statement guarantees an
assertion will be thrown at runtime, making Option D the correct answer. Next, Option
A does not compile because the assert statement is not a method and does not take arguments
in parentheses. It’s also invalid because it requires a boolean expression for the
first expression, not a numeric one. An additional value can be specified, but it requires a
colon separator (:). Option B would be the correct answer and trigger an error if assertions
are enabled, since 0==1 evaluates to false. Option C is incorrect. Even if assertions were
enabled, it would not trigger an error since 0==0 evaluates to true.
|
11_ C. The class does not compile because in line r2, brackets {} are used instead of parentheses
() in the try-with-resources statement, making Option C the correct answer. If this line
was fixed to use parentheses (), then the rest of the class would compile without issue and
print This just in! at runtime, making Option A the correct answer.
|
12_ C. When both a try block and close() method throw exceptions, the one in the try
block is the primary, while the one in the close() method is suppressed. For this reason,
Option A is a true statement. Option B is also a true statement, since a catch block is not
required when using a try-with-resources statement. Option C is the correct answer, since
resources are closed in reverse order in which they are created, not the other way around.
Option D is a true statement because multiple resources can be declared within a single set
of parentheses, each separated by a semicolon (;).
|
13_ A. The program compiles without issue, so Option D is incorrect. The narrower
SpellingException and NullPointerException, which inherit from Exception, are
correctly presented in the first catch block, with the broader Exception being in the second
catch block. The if-then statement evaluates to true, and a new SpellingException
instance is created, but it is not thrown because it is missing the throw keyword. For this
reason, the try block ends without any of the catch blocks being executed. The finally
block is then called, making it the only section of code in the program that prints a line of
text. For this reason, Option A is the correct answer.
|
14_ C. First off, the try block is capable of throwing two checked exceptions,
MissingMoneyException and MissingFoodException. The catch block uses the
Exception class to handle this, since both have Exception as a supertype. It then rethrows
the Exception. For this reason, Exception would be appropriate in the blank, making the
first statement correct. The compiler is also smart enough to know that there are only two
possible subclasses of Exception that can actually be thrown in the main() method, so
declaring MissingMoneyException and MissingFoodException together also allows the
code to compile, making the third statement correct. The second statement, only inserting
MissingMoneyException, would not allow the code to compile because the main() method
could throw a checked MissingFoodException that was not handled. For these reasons,
Option C is the correct answer.
|
15_ C. First off, Closeable extends AutoCloseable, making Option A incorrect. The difference
between the two is that the close() method in AutoCloseable throws Exception,
while the close() method in Closeable throws IOException, making Option D incorrect.
Since IOException is a subclass of Exception, both close() methods can throw an
IOException, making Option B incorrect. On the other hand, Exception is not a subclass
of IOException. For this reason, the close() method in a class that implements
Closeable cannot throw an instance of the Exception class, because it is an invalid
override using a broader exception type, making Option C the correct answer.
|
16_ B. Option A does not compile because a multi-catch expression uses a single variable, not
two variables. Option C does not compile because it is not possible to throw this checked
IOException in the try block. Option D does not compile because multi-catch blocks cannot
contain two exceptions in which one is a subclass of the other. If it did, one of the two
exceptions would be redundant. Option B is the correct answer and the only expression that
allows the class to compile. While both exceptions in the multi-catch block inherit from
Exception, neither is a subclass of the other.
|
17_ C. First off, the order of exceptions in a multi-catch does not matter, only that they not
be subclasses of one another, making Options A and B incorrect. Option C is the correct
answer because a multi-catch variable is effectively final. Java forbids reassigning of multicatch
variables since it is unclear what the precise reference type is. Option D is incorrect
because a multi-catch with a single exception type is just a regular catch block. A regular
catch variable is not required to be effectively final and can be reassigned within the catch
block.
|
18_ D. The code does not compile, so Option A is incorrect. The first compilation error is that
Shelf does not implement AutoCloseable, meaning a try-with-resources statement cannot
be used. Even though Shelf does implement Closing, an interface that uses the same
abstract method signature as AutoCloseable, the JVM requires AutoCloseable be
implemented to use try-with-resources. The second compilation problem is that throws is
used instead of throw inside the try block. Remember that throws is only used in method
signatures. The third compilation issue is that the order of exceptions in the two catch
blocks are reversed. Since Exception will catch all IllegalArgumentException instances,
the second catch block is unreachable. The final compilation error is that the shelf variable
is used in the finally block, which is out of scope. Remember that the scope of trywith-
resources variables ends when the try statement is complete. For these four reasons,
Option D is the correct answer.
|
19_ A. Option A is the correct answer. Any catch or finally blocks used with a try-withresources
statement are executed after the declared resources have been closed, not before.
Options B and C are true statements, since Closeable extends AutoCloseable and the
requirement for try-with-resources is that they must be of type AutoCloseable. Finally,
Option D is a true statement and one of the primary motivations for using try-withresources
statements.
|
20_ D. The optional second parameter of an assert statement, when used, must return a value.
The second assert statement uses System.out.print() as its second parameter, which
has a return type of void. For this reason, the code does not compile, making Option D the
correct answer. Other than this one line, the rest of the class compiles without issue.
|
21_ D. Only one of the classes, MissingResourceException, inherits from the unchecked
RuntimeException class, making Option D the correct answer. In fact, IOException and
SQLException extend the checked Exception class directly. The NotSerializableException
is also checked, since it is a subclass of IOException via ObjectStreamException.
|
22_ D. The code does not compile, making Options A and B incorrect. The declaration of
weatherTracker uses an anonymous inner class that correctly overrides the close()
method. Remember that overridden methods cannot throw any new or broader checked
exceptions than the inherited method. Alternatively, they can avoid throwing inherited
checked exceptions or declare new unchecked exceptions, such as RuntimeException.
The compilation error is in the catch block of the main() method, where the
weatherTracker variable is out of scope. In try-with-resources statements, the
resources are only accessible in the try block. For this reason, Option D is the correct
answer.
|
23_ A. Asserts can be enabled by using the command-line options -ea or -enableassertions
and disabled by using -da or -disableassertions. Passing -di does not enable or disable
assertions, making Option A the correct answer.
|
24_ A. The application compiles without issue and prints Hello, making Option A the correct
answer. The ReadSign and MakeSign classes are both correctly implemented, with both
overridden versions of close() dropping the checked exception. The try-with-resources
statement is also correctly implemented for two resources and does not cause any compilation
errors or runtime exceptions. Note that the semicolon (;) after the second resource
declaration is optional.
|
25_ B. The code compiles, so Option D is incorrect. The order of evaluation for a try-withresources
statement is that the resources are closed before any associated catch or
finally blocks are executed. For this reason, 2 is printed first, followed by 1. The
ArithmeticException is then caught and 3 is printed. The last value printed is 4, since the
finally block runs at the end. For these reasons, Option B is the correct answer.
|
26_ B. First off, Option A is an incorrect statement because the AutoCloseable interface does
not define a default implementation of close(). Next, the close() method should be
idempotent, which means it is able to be run multiple times without triggering any side
effects. For this reason, Option B is correct. After being run once, future calls to close()
should not change any data. Option C is incorrect because the close() method is fully
capable of throwing exceptions. In fact, the signature of the method in AutoCloseable
throws a checked Exception, although classes that override it may choose to drop the
checked exception. Option D is incorrect because the return type of close() is void, which
means no return value can be returned.
|
27_ D. The play() method compiles without issue, rethrowing a wrapped exception in
the catch block. While the main() method does declare RuntimeException, it does
not declare or catch the Exception thrown by the calls to play(). Even though the
play() method does not appear to actually throw an instance of Exception, because it
is declared, the main() method must catch or declare it. Since the checked exception is
not handled, the main() method does not compile, and Option D is the correct answer.
If the main() method was changed to declare the appropriate checked exception, then
the rest of the code would compile, and exactly one exception would be printed, making
Option A the correct answer.
|
28_ B. Assertions are often used to check method post conditions, test control flow invariants,
and validate class invariants, making Options A, C, and D true statements. Option B is the
correct answer. An assertion should never modify any data because it may be disabled at
runtime, leading to unintended side effects.
|
29_ B. A multi-catch block cannot contain two exceptions in which one is a subclass of the
other, since it is a redundant expression. Since CarCrash is a subclass of RuntimeException
and RuntimeException is a subclass of Exception, line w2 contains a compilation error,
making Option B the correct answer. The rest of the lines of code do not contain any compilation
errors.
|
30_ B. First off, a class must inherit from RuntimeException or Error to be considered an
unchecked exception. Dopey and Grumpy both are subclasses of Exception, but not
RuntimeException, making them both checked exceptions. Since IOException is a
checked exception, the subclass Happy is also a checked exception. Sleepy extends
IllegalStateException, which is an unchecked exception that extends
RuntimeException. Finally, Sneezy extends Throwable, which does not inherit
RuntimeException or Error, making it a checked exception. Therefore, there are a total of
four checked exceptions and one unchecked exception within the classes listed here. Since
there are no compilation errors in any of the class declarations, Option B is the correct
answer, with the first and third statement being true.
|
31_ D. The close() method in each of the resources throws an Exception, which must be
handled or declared in the main() method. The catch block supports TimeException,
but it is too narrow to catch Exception. Since there are no other catch blocks present and
the main() method does not declare Exception, the try-with-resources statement does not
compile, and Option D is the correct answer. If the catch block was modified to handle
Exception instead of TimeException, the code would compile without issue and print
3215 at runtime, closing the resources in the reverse order in which they were declared and
making Option B the correct answer.
|
32_ A. The try-catch block already catches Exception, so the correct answer would be the one
that is not a subclass of Exception. In this case, Error extends Throwable and is the only
choice that allows the code to compile. Because IllegalStateException and RingException
both inherit from Exception, Options B and C, respectively, are incorrect. Finally, Option D is
incorrect because there is an answer choice that allows the code to compile.
|
33_ B. Option A does not compile because the assignment (age=2) has a value of int, not
boolean, which is required for an assert statement. Option B compiles without issue and
is the correct answer. Even though Error and 10 are different data types, String and int
respectively, the second assert parameter only needs to be a value, so both are allowed.
Option C does not compile because the usage of the lambda expression does not match a
functional interface. Option D is incorrect because a return statement is not allowed in the
second expression of an assert statement.
|
34_ D. The MissedCallException is a checked exception since it extends Exception and does not
inherit RuntimeException. For this reason, the first catch block fails to compile, since the compiler
detects that it is not possible to throw this checked exception inside the try block, making
Option D the correct answer. Note that if MissedCallException was changed to extend the
checked RuntimeException, then the code would compile and the RuntimeException from
the finally block would replace the ArrayIndexOutOfBoundsException from the try block in
the message reported to the caller, making Option C the correct answer.
|
35_ D. The catch variable d is of type BearException that cannot be assigned an instance of the
superclass RuntimeException without an explicit cast. For this reason, the first catch block
does not compile in tellStory(). The second catch block also does not compile, albeit for
a slightly different reason. A catch variable in a multi-catch block must be effectively final
because the precise type is not known until runtime. Therefore, the compiler does not allow
the variable e to be reassigned. For these two reasons, Option D is the correct answer. Note
that the first catch block does allow the catch variable d to be reassigned, it just must be to a
class that inherits BearException or is an instance of BearException.
|
36_ D. The play() method declares two checked exceptions, OutOfTuneException and
FileNotFoundException, which are handled in the main() method’s catch block using
the Exception type. The catch block then rethrows the Exception. The compiler is smart
enough to know that only two possible checked exceptions can be thrown here, but they
both must be handled or declared. Since the main() method only declares one of the two
checked exceptions, FileNotFoundException is not handled, and the code does not compile.
For this reason, Option D is the correct answer. Note that the main() could have also
handled or declared Exception, since both checked exceptions inherit it. If the main()
method had declared Exception, then Song finished! would have been printed followed
by a stack trace, making Option C the correct answer.
|
37_ C. The code compiles without issue, making Option D incorrect. Option A is incorrect
because assertions are not enabled by default in Java. Therefore, the code will run without
throwing any exceptions. Option B is also incorrect because the command enables assertions
everywhere but disables them for the Falcon class. Option C is the correct answer,
with the command disabling assertions everywhere except in the Falcon class, causing an
AssertionError to be thrown at runtime.
|
38_ C. The Closeable interface defines a close() method that throws IOException. The
overridden implementation of MyDatabase, which implements Closeable, declares a
SQLException. This is a new checked exception not found in the inherited method signature.
Therefore, the method override is invalid and the close() method in MyDatabase
does not compile, making Option C the correct answer.
|
39_ D. The code does not compile because the close() method throws an Exception that is
not handled or declared in the main() method, making Option D the correct answer. When
a try-with-resources statement is used with a close() method that throws a checked exception,
it must be handled by the method or caught within the try-with-resources statement.
|
40_ B. The code compiles without issue, making Option C incorrect. In the climb() method,
two exceptions are thrown. One is thrown by the close() method and the other by the
try block. The exception thrown in the try block is considered the primary exception and
reported to the caller on line e1, while the exception thrown by the close() method is suppressed.
For this reason, java.lang.RuntimeException is thrown to the main() method,
and Option B is the correct answer.
|
1_ C. The date and time classes added in Java 8 are in the java.time package, making
Option C correct. The older date classes are in the java.util package.
|
2_ A. The Duration class is used to reflect an amount of time using small units like minutes.
Since it just uses units of time, it does not involve time zones. The LocalTime class contains
units of hours, minutes, seconds, and fractional seconds. The LocalDateTime class
contains all the data in a LocalTime and adds on a year, month, and date. Neither of these
classes uses time zones. There is a ZonedDateTime class when you need to use time zones.
Since none of the three classes listed includes a time zone, Option A is correct.
|
3_ A. A Period is measured in days, weeks, months, or years. A Duration is measured in
smaller units like minutes or seconds. Only Duration has a getSeconds() method, making
Option A correct.
|
4_ D. To compare times in different time zones, you can subtract the time zone from the time
to convert to GMT. This makes it 02:00 in Berlin because we subtract 1 from 3. Similarly,
it is 02:00 in Helsinki due to subtracting 2 from 4. Finally, it is 04:00 in Warsaw because
we subtracted 1 from 5. We have a tie because it is the same time in Berlin and Helsinki, so
Option D is correct.
|
5_ B. On a normal night, adding three hours to 1 a.m. makes it 4 a.m. However, this date
begins daylight savings time. This means we add an extra hour to skip the 2 a.m. hour. This
makes later contain 05:00 instead of 04:00. Therefore, the code prints 5, and Option B is
correct.
|
6_ C. LocalDate allows passing the month as an int or Month enum parameter. However,
Month.MARCH is an enum. It cannot be assigned to an int variable, so the declaration of
month does not compile, and Option C is correct.
|
7_ C. Both LocalDate and DateTimeFormatter have a format() method. This makes II
incorrect. While it is tricky, you do need to know that the format() method can be called
on either object. Since I and III are correct, Option C is the answer.
|
8_ C. Converting to GMT by subtracting the time zone offset, it is 17:00 for the Phoenix time
since 10 minus negative 7 is 17. In GMT, the Vancouver time is 16:00 due to subtracting
negative 8 from 8. Remember that subtracting a negative number is the same as adding.
Therefore, the Vancouver time is an hour earlier than the Phoenix time, and Option C is
correct.
|
9_ C. While there is no 2 a.m. on the clock that night, Java adjusts the time to 3 a.m. automatically
and changes the time zone. It does not throw an exception, so Option D is incorrect.
Option B is a valid expression, since any value after the time adjustment is just a
normal time on the clock. Since both A and B are valid expressions, Option C is the correct
answer.
|
10_ B. Line 12 creates a Period representing a year, six months, and three days. Adding this to
waffleDay gives us the year 2018, the month of September, and a day of 28. This new date
is stored in later on line 13 and represents September 28, 2018. Line 14 has no effect as
the return value is ignored. Line 17 checks that you know that isBefore() returns false
if the value is an exact match. Since thisOne is an exact match but thatOne is a whole day
before, the output is false true, making Option B correct.
|
11_ D. Duration is supposed to be used with objects that contain times. While it has an
ofDays() method, this is a convenience method to represent a large number of seconds.
This means that calling Duration.ofDays(1) is fine. However, this code throws an
UnsupportedTemporalTypeException when you try to pass it the minus() method on
LocalDate, making Option D correct. Note that the question asks about a possible result
rather than the definitive result because the format of dates varies by region.
|
12_ C. The DateTimeFormatter is created with ofLocalizedDate(). It knows how to format
date fields but not time fields. Line 18 is fine because a LocalDate clearly has date fields.
Line 19 is also fine. Since a LocalDateTime has both date and time fields, the formatter just
looks at the date fields. Line 20 is a problem. A LocalTime object does not have any date
fields so the formatter throws an UnsupportedTemporalTypeException, making Option C
the answer.
|
13_ D. This question is tricky. It appears to be about daylight savings time. However, the result
of z.plusHours(1) is never stored in a variable or used. Since ZonedDateTime is
immutable, the time remains at 01:00. The code prints out 1, making none of these correct
and Option D the answer.
|
14_ D. For dates, a lowercase m means minute while an uppercase M means month. This eliminates
Options A and C. A lowercase h means hour. Therefore, Option B is incorrect, and
Option D is the answer.
|
15_ D. There are three overloads for LocalTime.of(). Options A, B, and C are all valid overloads.
Option D is not because Java only allows passing one fractional second parameter.
Java does support nanoseconds, but not the further granularity of picoseconds.
|
16_ C. The LocalDate class represents a date using year, month, and day fields. There is a
getYear() method to get the year. The Period class holds units of years, months, and days.
It has a getYears() method. There is not a date/time class called ZonedDate. There is a class
called ZonedDateTime, which does have a getYear() method. Since only LocalDate and
Period have a method to get the year, Option C is correct.
|
17_ A. Duration is used for units of time a day and smaller, making Option B a true statement.
Period is used for units of time a day and larger, making Option C a true statement.
While both represent the same length of time, they output different values when calling
toString(). The Duration object outputs PT24H, and the Period object outputs P1D. This
shows that Duration is providing the ofDays() method as a convenience instead of requiring
the programmer to type 24 hours. Option A is the answer.
|
18_ B. The first thing to notice is that this is a LocalTime object. Since there is no date component,
Options C and D are incorrect. Four parameters are passed to this LocalTime
method. The first three are the hour, minute, and second. The fourth is nanoseconds,
which are fractions of a second. While you aren’t expected to do calculations with nanoseconds,
you should know that a fraction of a second is at the end of the output. Option A is
incorrect because .4 is 40 percent of a second. That’s far larger than 4 nanoseconds. Therefore,
Option B is correct.
|
19_ B. LocalDate starts counting months from one, so month 2 is February. This rules out
Options A and C. The pattern specifies that the date should appear before the month, making
Option B correct.
|
20_ A. The ChronoUnit enum contains values for various measures of time including HOURS, so
Option A is correct.
|
21_ B. Adding three hours to 13:00 makes it 16:00. While this date happens to be the start of
daylight savings time, the change occurs at 2 a.m. This code uses 13:00, which is 1 p.m.
Since the calculation does not cross 2 a.m., the fact that it is the date that starts daylight
savings time is irrelevant. Option B is correct because the hour is 16 and the time is 16:00.
|
22_ B. This code correctly subtracts a day from montyPythonDay. It then outputs a
LocalDateTime value. Option A is incorrect because it omits the time. Option B is correct
because it represents one day earlier than the original date and includes a time in the
output.
|
23_ D. There is a DateTimeFormatter class, but not a DateFormatter class. The
DateTimeFormatter class is used for formatting dates, times, or both. Since the provided
code does not compile, nothing can fill in the blank to make the code print 2017-01-15,
and Option D is the answer.
|
24_ B. There are many overloads for LocalDateTime.of(). Option A is a valid overload
because it uses date and time objects. Options C and D are also valid overloads, showing
you can pass the month as an int or Month enum. Option B is the answer. Java doesn’t
allow combining a LocalDate object with time fields directly.
|
25_ C. In the first time change of the year, clocks “spring ahead” and skip the 02:00–03:00
hour entirely. This means 1:59 is followed by 03:00 on March 12, 2017. By contrast, July
4 is a normal day and 1:59 is followed by 02:00. In the second time change of the year,
clocks “fall back” and repeat an hour, so 1:59 is followed by 01:00. Granted, you can’t tell
whether this is the first or second 1:59 from the image. If this information is relevant to a
question’s context, the question will specify this fact. In this case, 03:00, 02:00, 02:00 is
not a choice. Option C is the answer.
|
26_ D. February has 28 or 29 days, depending on the year. There is never a February 31. Java
throws a DateTimeException when you try to create an invalid date, making Option D
correct.
|
27_ A. This one is tricky. In order to determine GMT, you need to subtract the time zone offset
from the hour. In this case, the time zone offset is negative 10. Since subtracting a negative
number is like adding a positive number, this means we are adding 16 and 10. That gives us
26_ However, there are only 24 hours in a day. We’ve crossed a time zone boundary, so we
can remove a whole 24-hour day. Subtracting 24 from 26 gives us 2. This means it is 02:00 in
GMT, and Option A is correct. It’s also a day later in GMT, but the question didn’t ask that.
|
28_ D. An Instant represents a specific moment in time using GMT. Since there are no time
zones included, Options A and C are incorrect. This code correctly adds one day to the
instant, making Option D correct.
|
29_ D. Make sure to pay attention to date types. This code attempts to add a month to a
LocalTime value. There is no plusMonths() method on LocalTime, so Option D is correct.
|
30_ D. The format of the pattern is incorrect. You can’t just put literal text in there. Most
of the characters of Holiday: are not defined formatting symbols. The code throws an
IllegalArgumentException, so Option D is correct.
|
31_ A. To compare times in different time zones, you can subtract the time zone from the time.
This makes it 09:00 in Bangkok because we subtract 7 from 16. Similarly, it is 14:00 in
Dubai due to subtracting 4 from 18. Finally, it is 12:00 in Kuala Lumpur because we subtracted
8 from 20. Notice how we used a 24-hour clock to make comparing times easier.
The earliest time is in Bangkok, so Option A is correct.
|
32_ C. Line 12 creates a Period representing three days. Period objects do not chain, so only
the last method call, which is to ofDays(3), is used in determining the value. Adding three
days sets later to March 28, 2017. Line 14 has no effect as the return value is ignored.
March 28, 2017, is before both thisOne and thatOne, so Option C is correct.
|
33_ B. The TemporalUnit interface does not define a DAYS constant, making II and IV incorrect.
The until() and between() methods have the same behavior. They determine how
many units of time are between two dates. One takes both dates as parameter and the other
is an instance method on the date. Since I and III are equivalent, Option B is the answer.
Note that while we don’t have date times in this question, the until() and between()
methods work the same way for them.
|
34_ A. The DateTimeFormatter class is used to format all of these objects. The method will
throw an exception if called with a LocalDate since the formatter only knows about time
fields. However, it will still compile, making Option A correct.
|
35_ B. This code begins by correctly creating four objects. It then adds a month to
date. Since Java 8 date/time classes are immutable, this does not affect the value of
iceCreamDay. Therefore, iceCreamDay remains in July. Since months count from one,
Option B is correct.
|
36_ A. Java 8 date and time classes are immutable. They use a static factory method to get
the object reference rather than a constructor. This makes Options B and D incorrect. Further,
there is not a ZonedDate class. There is a ZonedDateTime class. As a result, Option C
is incorrect, and Option A is the answer.
|
37_ B. The first line of code correctly creates a LocalDate object representing March 3, 2017.
The second line adds two days to it, making it March 5. It then subtracts a day, making it
March 4_ Finally, it subtracts yet another day ending at March 3. The outcome of all this is
that we have two dates that have the same value, and Option B is correct.
|
38_ C. An Instant represents a specific moment in time using GMT. Since LocalDateTime
does not have a time zone, it cannot be converted to a specific moment in time. Therefore,
the toInstant() call does not compile, and Option C is correct.
|
39_ A. While it is traditional to include the year when outputting a date, it is not required. This
code correctly prints the month followed by a decimal point. After the decimal point, it
prints the day of the month followed by the hours and minutes. Happy Pi Day!
|
40_ C. Normally, adding an hour would result in 02:00 in the same time zone offset of –05:00.
Since the hour is repeated, it is 01:00 again. However, the time zone offset changes instead.
Therefore, Option C is correct.
|
1_ B. Writer is an abstract class, making Option B the correct answer. Note that
InputStream, OutputStream, and Reader are also abstract classes.
|
2_ D. File uses mkdir() and mkdirs() to create a directory, not createDirectory(),
making Option A incorrect. Note there is a createDirectory() method in the NIO.2
Files class. The getLength() method also does not exist, as the correct method is called
length(). Next, there is a listFiles() method used to read the contents of a directory,
but there is no listFile() method. That leaves us with renameTo(), which does exist and
is used to rename file system paths.
|
3_ C. The skip() method just reads a single byte and discards the value. The read() method
can be used for a similar purpose, making Option C the correct answer. Option A is incorrect
because there is no jump() method defined in InputStream. Options B and D are
incorrect because they cannot be used to skip data, only to mark a location and return to it
later, respectively.
|
4_ D. Serializable is a marker or tagging interface, which means it does not contain any
methods and is used to provide information about an object at runtime. Therefore, Option
D is the correct answer because the interface does not define any abstract methods.
|
5_ C. Given a valid instance of Console, reader() returns an instance of Reader, while
writer() returns an instance of PrintWriter. Reader and PrintWriter was not an
answer choice though, making Option C the next best choice since PrintWriter inherits
Writer. Options A and B are incorrect because PrintReader is not defined in the java
.io library. Option D is incorrect because the type of the instance returned by reader() is
Reader, which does not inherit StringReader.
|
6_ D. BufferedWriter is a wrapper class that requires an instance of Writer to operate on.
In the Smoke class, a FileOutputStream is passed, which does not inherit Writer, causing
the class not to compile, and making Option D the correct answer. If FileWriter was used
instead of FileOutputStream, the code would compile without issue and print 13, making
Option B the correct answer.
|
7_ A. The File class is used to read both files and directories within a file system, making
Option A the correct answer. The other three classes do not exist. Note there is an NIO.2
interface, java.nio.file.Path, used to read both file and path information.
|
8_ C. FileOutputStream and FileReader are both low-level streams that operate directly on
files, making Options A and B incorrect. ObjectInputStream is a high-level stream that
can only wrap an existing InputStream. For this reason, Option C is the correct answer.
PrintWriter can operate on other streams, but it can also operate on files. Since the question
asks which class can only wrap low-level streams, Option D is incorrect.
|
9_ D. The code compiles, so Option C is incorrect. The FileInputStream does not support
marks, though, leading to an IOException at runtime when the reset() method is called.
For this reason, Option D is the correct answer. Be suspicious of any code samples that call
the mark() or reset() method without first calling markSupported().
|
10_ C. The absolute path is the full path from the root directory to the file, while the relative
path is the path from the current working directory to the file. For this reason, Option C is
the correct answer.
|
11_ D. The difference between the two methods is that writeSecret1() does not take any
steps to ensure the close() method is called after the resource is allocated. On the other
hand, writeSecret2() uses a try-with-resources block, which automatically tries to
close the resource after it is used. Without a try-with-resources statement or an equivalent
finally block, any exception thrown by the write() method would cause the
resource not to be closed in the writeSecret1() method, possibly leading to a resource
leak. For this reason, Option D is the correct answer. Option A is incorrect since they
are not equivalent to each other. Finally, Options B and C are incorrect because both
compile without issue.
|
12_ A. The constructor for Console is private. Therefore, attempting to call new Console()
outside the class results in a compilation error, making Option A the correct answer.
The correct way to obtain a Console instance is to call System.console(). Even if
the correct way of obtaining a Console had been used, and the Console was
available at runtime, stuff is null in the printItinerary() method. Referencing
stuff.activities results in a NullPointerException, which would make Option B
the correct answer.
|
13_ A. While you might not be familiar with FilterOutputStream, the diagram shows that
the two classes must inherit from OutputStream. Options B and C can be eliminated as
choices since PrintOutputStream and Stream are not the name of any java.io classes.
Option D can also be eliminated because OutputStream is already in the diagram, and you
cannot have a circular class dependency. That leaves us with the correct answer, Option
A, with BufferedOutputStream and PrintStream both extending FilterOutputStream.
Note that ByteArrayOutputStream and FileOutputStream referenced in Options C and
D, respectively, do not extend FilterOutputStream, although knowing this fact was not
required to solve the problem.
|
14_ D. The Cereal class does not implement the Serializable interface; therefore, attempting
to write the instance to disk, or calling readObject() using ObjectInputStream,
will result in a NotSerializableException at runtime. For this reason, Option D is the
correct answer. If the class did implement Serializable, then the value of name would
be CornLoops, since none of the constructor, initializers, or setters methods are used on
deserialization, making Option B the correct answer.
|
15_ B. An OutputStream is used to write bytes, while a Writer is used to write character data.
Both can write character data, the OutputStream just needs the data converted to bytes
first. For this reason, Option A is incorrect. Option B is the correct answer, with Writer
containing numerous methods for writing character or String data. Both interfaces contain
a flush() method, making Option C incorrect. Finally, because both can be used with
a byte array, Option D is incorrect.
|
16_ C. First off, the code compiles without issue. The first method call to mkdirs() creates two
directories, /templates and /templates/proofs. The next mkdir() call is unnecessary,
since /templates/proofs already exists. That said, calling it on an existing directory is
harmless and does not cause an exception to be thrown at runtime. Next, a file draft.doc
is created in the /templates directory. The final two lines attempt to remove the newly
created directories. The first call to delete() is successful because /templates/proofs is
an empty directory. On the other hand, the second call to delete() fails to delete the
directory /templates because it is non-empty, containing the file draft.doc. Neither of
these calls trigger an exception at runtime, though, with delete() just returning a
boolean value indicating whether the call was successful. Therefore, our program ends
without throwing any exceptions, and Option C is the correct answer.
|
17_ D. To answer the question, you need to identify three of the four ways to call the systemindependent
file name separator. For example, the file name separator is often a forwardslash
(/) in Linux-based systems and a backward-slash (\) in Windows-based systems.
Option A is valid because it is the fully qualified name of the property. Option B is also
valid because File.separator and File.separatorChar are equivalent. While accessing
a static variable using an instance is discouraged, as shown in Option B, it is allowed.
Option C is valid and a common way to read the character using the System class. Finally,
Option D is the correct answer and one call that cannot be used to get the system-dependent
name separator character. Note that System.getProperty("path.separator") is
used to separate sets of paths, not names within a single path.
|
18_ D. The first compilation error is that the FileReader constructor call is missing the new
keyword. The second compilation error is that the music variable is marked final, but
then modified in the while loop. The third compilation problem is that the readMusic()
method fails to declare or handle an IOException. Even though the IOException thrown
by readLine() is caught, the one thrown by the implicit call to close() via the try-withresources
block is not caught. Due to these three compilation errors, Option D is the correct
answer.
|
19_ C. Both of the methods do exist, making Option D incorrect. Both methods take the
same arguments and do the exact same thing, making Option C the correct answer. The
printf() was added as a convenience method, since many other languages use printf()
to accomplish the same task as format().
|
20_ C. FileWriter and BufferedWriter can be used in conjunction to write large amounts of
text data to a file in an efficient manner, making Option C the correct answer. While you
can write text data using FileOutputStream and BufferedOutputStream, they are primarily
used for binary data. Since there is a better choice available, Option A is incorrect.
Option B is incorrect since FileOutputWriter and FileBufferedWriter are not classes
that exist within the java.io API. Option D is incorrect since ObjectOutputStream is a
high-level binary stream. Also, while it can write String data, it writes it in a binary format,
not a text format.
|
21_ D. The code compiles and runs without issue, so Options A and B are incorrect. The problem
with the implementation is that checking if ios.readObject() is null is not the recommended
way of iterating over an entire file. For example, the file could have been written
with writeObject(null) in-between two non-null records. In this case, the reading of the
file would stop on this null value, before the end of the file has been reached. For this reason,
Option D is the correct answer. Note that the valid way to iterate over all elements of a
file using ObjectInputStream is to continue to call readObject() until an EOFException
is thrown.
|
22_ D. BufferedInputStream is the complement of BufferedOutputStream. Likewise,
BufferedReader and FileReader are the complements of BufferedWriter and
FileWriter, respectively. On the other hand, PrintWriter does not have an accompanying
PrintReader class within the java.io API, making Option D the correct answer.
Remember that this is also true of PrintStream, as there is no PrintInputStream class.
|
23_ C. The File getParent() method returns a String, not a File object. For this reason,
the code does not compile on the last line since there is no getParent() method defined
in the String class, and Option C is correct. If the first method call on the last line was
changed to getParentFile(), then the code would compile and run without issue, outputting
/ - null and making Option B the correct answer. The File class does not require
the location to exist within the file system in order to perform some operations, like
getParent(), on the path.
|
24_ D. All three statements about the program are correct. If System.console() is available,
then the program will ask the user a question and then print the response if one is entered.
On the other hand, if System.console() is not available, then the program will exit with a
NullPointerException. It is strongly recommended to always check whether or not
System.console() is null after requesting it. Finally, the user may choose not to respond
to the program’s request for input, resulting in the program hanging indefinitely and making
the last statement true.
|
25_ C. The code contains two compilation errors. First, the File list() method returns a list
of String values, not File values, so the call to deleteTree() with a String value does
not compile. Either the call would have to be changed to f.listFiles() or the lambda
expression body would have to be updated to deleteTree(new File(s)) for the code to
work properly. Next, there is no deleteDirectory() method in the File class. Directories
are deleted with the same delete() method used for files, once they have been emptied.
With those two sets of corrections, the method would compile and be capable of deleting a
directory tree. Notice we continually used the phrase “capable of deleting a directory tree.”
While the corrected code is able to delete a directory tree, it may fail in some cases, such as
if the file system is read-only.
|
26_ C. System.err, System.in, and System.out are each valid streams defined in the System
class. System.info is not, making Option C the correct answer.
|
27_ D. The code compiles without issue, making Options B and C incorrect. The BufferedWriter
uses the existing FileWriter object as the low-level stream to write the file to disk. By using
the try-with-resources block, though, the BufferedWriter calls close() before executing
any associated catch or finally blocks. Since closing a high-level stream automatically closes
the associated low-level stream, the w object is already closed by the time the finally block is
executed. For this reason, the flush() command triggers an IOException at runtime, making
Option D the correct answer. Note that the call to w.close(), if that line was reached, does
not trigger an exception, because calling close() on already closed streams is innocuous.
|
28_ B. The Console class contains a reader() method that returns a Reader object. The
Reader class defines a read() method, but not a readLine() method. For this reason,
Option B is the correct answer. Recall that a BufferedReader is required to call the
readLine() method. Options A, C, and D are valid ways to read input from the user.
|
29_ C. The code compiles without issue, since InputStream and OutputStream both support
reading/writing byte arrays, making Option A incorrect. Option D is also incorrect. While
it is often recommended that an I/O array be a power of 2 for performance reasons, it is not
required, making Option D incorrect. This leaves us with Options B and C. The key here
is the write() method used does not take a length value, available in the chirps variable,
when writing the file. The method will always write the entire data array, even when only
a handful of bytes were read into the data array, which may occur during the last iteration
of the loop. The result is that files whose bytes are a multiple of 123 will be written correctly,
while all other files will be written with extra data appended to the end of the file.
For this reason, Option C is the correct answer. If the write(data) call was replaced with
write(data,0,chirps), which does take the number of bytes read into consideration, then
all files would copy correctly, making Option B the correct answer.
|
30_ C. The class name has three components that tell you what it would do if it was a java.io
stream. First, Buffered tells you it can be used to handle large data sets efficiently. Next,
File tells you it is involved in reading or writing files. Finally, Reader tells you it is used to
read character data. Therefore, the class would be useful for reading large files of character
data from disk efficiently, making Option C the correct answer. Option A is incorrect
because it refers to a small file over a network. Options B and D are incorrect because both
involve binary data.
|
31_ A. The code compiles and runs without issue. The first two values of the
ByteArrayInputStream are read. Next, the markSupported() value is tested. Since -1 is not
one of the possible answers, we assume that ByteArrayInputStream does support marks. Two
values are read and three are skipped, but then reset() is called, putting the stream back in the
state before mark() was called. In other words, everything between mark() and reset() can
be ignored. The last value read is 3, making Option A the correct answer.
|
32_ C. Line 5 creates a File object, but that does not create a file in the file system unless
cake.createNewFile() is called. Line 6 also does not necessarily create a file, although
the call to flush() will on line 7. Note that this class does not properly close the file
resource, potentially leading to a resource leak. Line 8 creates a new File object, which is
used to create a new directory using the mkdirs() method. Recall from your studies that
mkdirs() is similar to mkdir(), except that it creates any missing directories in the path.
Since directories can have periods (.) in their name, such as a directory called info.txt,
this code compiles and runs without issue. Since two file system objects, a file and a directory,
are created, Option C is the correct answer.
|
33_ B. Since the file is stored on disk, FileInputStream is an appropriate choice. Next,
because the data is quite large, a BufferedInputStream would help improve access.
Finally, since the data is a set of Java values, ObjectInputStream would allow various
different formats to be read. The only one that does not help in this process is
BufferedReader, Option B. BufferedReader should be used with text-based Reader
streams, not binary InputStream objects.
|
34_ B. The flush() method is defined on classes that inherit Writer and OutputStream,
not Reader and InputStream. For this reason, the r.flush() in both methods does
not compile, making Option B the correct answer and Option C incorrect. The methods
are not equivalent even if they did compile, since getNameSafely() ensures the
resource is closed properly by using a try-with-resources statement, making Option A
incorrect for two reasons. Finally, Option D would be correct if the calls to flush()
were removed.
|
35_ A. First off, the class compiles without issue. Although there are built-in methods to print
a String and read a line of input, the developer has chosen not to use them for most of the
application. The application first prints Pass, one character at a time. The flush() method
does not throw an exception at runtime. In fact, it helps make sure the message is presented
to the user. Next, the user enters badxbad and presses Enter. The stream stops reading on
the x, so the value stored in the StringBuilder is bad. Finally, this value is printed to the
user, using the format() method along with Result: as a prefix. For these reasons, Option
A is the correct answer.
|
36_ B. The readPassword() returns a char array for security reasons. If the data was stored as
a String, it would enter the shared JVM string pool, potentially allowing a malicious user
to access it, especially if there is a memory dump. By using a char array, the data can be
immediately cleared after it is written and removed from memory. For this reason, Option B
is the correct answer. The rest of the statements are not true.
|
37_ A. The BufferedInputStream constructor in the readBook() method requires an
InputStream as input. Since FileReader does not inherit InputStream, the readBook()
method does not compile, and Option A is the correct answer. If FileReader was changed
to FileInputStream, then the code would compile without issue. Since read() is called
twice per loop iteration, the program would print every other byte, making Option C
correct. Remember that InputStream read() returns -1 when the end of the stream is
met. Alternatively, we use EOFException with ObjectInputStream readObject() to
determine when the end of the file has been reached.
|
38_ B. Generally speaking, classes should be marked with the Serializable interface if they
contain data that we might want to save and retrieve later. Options A, C, and D describe
the type of data that we would want to store over a long period of time. Option B, though,
defines a class that manages transient or short-lived data. Application processes change
quite frequently, and trying to reconstruct a process is often considered a bad idea. For
these reasons, Option B is the best answer.
|
39_ D. The receiveText() method compiles and runs without issue. The method correctly
checks that the mark() method is supported before attempting to use it. Based on the
implementation with reset(), the pointer is in the same location before/after the if-then
statement. On the other hand, the sendText() method does not compile. The skip()
method is defined on InputStream and Reader, not OutputStream and Writer, making
Option D the correct answer. If this line was removed, the rest of the code would compile
and run without issue, printing You up? at runtime and making Option A the correct
answer.
|
40_ B. The class compiles and runs without issue, so Option D is incorrect. The class defines
three variables, only one of which is serializable. The first variable, chambers, is serializable,
with the value 2 being written to disk and then read from disk. Note that constructors
and instance initializers are not executed when a class is deserialized. The next variable,
size, is transient. It is discarded when it is written to disk, so it has the default object
value of null when read from disk. Finally, the variable color is static, which means
it is shared by all instances of the class. Even though the value was RED when the instance
was serialized, this value was not written to disk, since it was not part of the instance. The
constructor call new Value() between the two try-with-resources blocks sets this value to
BLUE, which is the value printed later in the application. For these reasons, the class prints
2,null,BLUE, making Option B the correct answer.
|
1_ C. A symbolic link is a file that contains a reference to another file or directory within the
file system, making Options A and B incorrect. Further, there is no such thing as an irregular
file. Option C is the correct answer because a regular file is not a directory and contains
content, unlike a symbolic link or resource. Option D is also incorrect because all symbolic
links are stored as files, not directories, even when their target is a directory.
|
2_ C. The NIO.2 Path interface contains the methods getRoot() and toRealPath(). On
the other hand, the method isDirectory() is found in the NIO.2 Files class, while the
method listFiles() is found in the java.io.File class. For these reasons, Option C is
the correct answer.
|
3_ A. The code does not compile because there is no NIO.2 class File that contains an
isHidden() method, making Option A the correct answer. There is a java.io.File class, but
that does not contain an isHidden() method either. The correct call is Files.isHidden().
Remember to check File vs. Files as well as Path vs. Paths on the real exam. If the correct
method call was used, the program would print Found!, and Option C would be the correct
answer.
|
4_ D. A breadth-first traversal is when all elements of the same level, or distance from the
starting path, are visited before moving on to the next level. On the other hand, a depthfirst
traversal is when each element’s entire path, from start to finish, is visited before moving
onto another path on the same level. Both walk() and find() use depth-first traversals,
so Option D is the correct answer.
|
5_ A. Reading an attribute interface is accomplished in a single trip to the underlying file
system. On the other hand, reading multiple file attributes using individual Files methods
requires a round-trip to the file system for each method call. For these reasons, Option
A is the correct answer. Option B is incorrect because nothing guarantees it will perform
faster, especially if the Files method is only being used to read a single attribute. For multiple
calls, it is expected to be faster, but the statement uses the word guarantees, which is
incorrect. Option C is also incorrect because both have built-in support for symbolic links.
Finally, Option D is incorrect because this discussion has nothing to do with memory leaks.
|
6_ B. First off, the class compiles without issue. It is not without problems, though. The
Files.isSameFile() method call on line j1 first checks if the Path values are equivalent in
terms of equals(). One is absolute and the other is relative, so this test will fail. The
isSameFile() method then moves on to verify that the two Path values reference the same file
system object. Since we know the directory does not exist, the call to isSameFile() on line j1
will produce a NoSuchFileException at runtime, making Option B the correct answer.
|
7_ B. A cycle is caused when a path contains a symbolic link that references the path itself, or
a parent of the parent, triggering an infinitely deep traversal. That said, Files.walk() does
not follow symbolic links by default. For this reason, the cycle is never activated, and the code
would print a number at runtime, making Option B the correct answer. If the FOLLOW_LINKS
enum value was used in the call to Files.walk(), then it would trigger a cycle resulting in a
FileSystemLoopException at runtime, and Option A would be the correct answer.
|
8_ B. The methods length() and getLength() do not exist in the Files class, making
Options A and C incorrect. Recall that the java.io.File method retrieves the size of a
file on disk. The NIO.2 Files class includes the Files.size() method to accomplish this
same function. For this reason, Option B is the correct answer.
|
9_ D. The code compiles without issue, making Option C incorrect. Even though tricks
would be dropped in the normalized path /bag/of/disappear.txt, there is no
normalize() call, so path.subpath(2,3) returns tricks on line 5. On line 6,
the call to getName() throws an IllegalArgumentException at runtime. Since
getName() is zero-indexed and contains only one element, the call on line 6 throws an
IllegalArgumentException, making Option D the correct answer. If getName(0) had
been used instead of getName(1), then the program would run without issue and print
/home/tricks, and Option A would have been the correct answer.
|
10_ A. The NIO.2 Files class contains the method isSameFile(). The methods length()
and mkdir() are found in java.io.File, with the NIO.2 equivalent versions being
Files.size() and Files.createDirectory(), respectively. In addition, the relativize()
method is found in NIO.2 Path, not Files. Since only isSameFile() is found in NIO.2
Files, Option A is the correct answer.
|
11_ B. First off, the code compiles without issue, so Option D is incorrect. The enum value
REPLACE_EXISTING does not use a type, although this compiles correctly if a static
import of StandardCopyOption is used. The AtomicMoveNotSupportedException in
Option A is only possible when the ATOMIC_MOVE option is passed to the move() method.
Similarly, the FileAlreadyExistsException in Option C is only possible when the
REPLACE_EXISTING option is not passed to the move() method. That leaves us with the
correct answer of Option B. A DirectoryNotEmptyException can occur regardless of the
options passed to the Files.move() method.
|
12_ D. The Path method getFileName() returns a Path instance, not a String. For this reason,
the code does not compile, regardless of which line of code is inserted into the blank,
making Option D the correct answer. Statements I and III are two valid ways to create a
Path instance. If the method was updated to use Path as the return type, then Option B
would be the correct answer. Statement II would cause the method to not compile, because
Path is an interface and requires a class to be instantiated.
|
13_ A. The code compiles without issue, but that’s about it. The class may throw an exception
at runtime, since we have not said whether or not the source file exists nor whether the
target file already exists, is a directory, or is write-protected. For these reason, Option B is
incorrect. Option C is also incorrect because the implementation is a flawed copy method.
On a regular file, the code will copy the contents but the line breaks would be missing in
the target file. In order to correctly copy the original file, a line break would have to be
written after each time temp is written. Since it is the only correct statement, Option A is
the correct answer.
|
14_ C. First off, there is no Files.readLines() method, making Options B and D immediately
incorrect. The Files.readAllLines() method returns a List<String>, while the
Files.lines() method returns a Stream<String>. For this reason, Option C is the correct
answer, and Option A is incorrect.
|
15_ A. The program compiles and runs without issue, making Options C and D incorrect.
Like String instances, Path instances are immutable. For this reason, the resolve()
operation on line 7 has no impact on the lessTraveled variable. Since one Path ends with
/spot.txt and the other does not, they are not equivalent in terms of equals(), making
Option A the correct answer. If lines 6 and 7 were combined, such that the result of the
resolve() operation was stored in the lessTraveled variable, then normalize() would
reduce lessTraveled to a Path value that is equivalent to oftenTraveled, making Option
B the correct answer.
|
16_ C. Options A, B, and D are each advantages of using NIO.2. As you may remember, using
an attribute view to read multiple attributes at once is more efficient than a single attribute
call since it involves fewer round trips to the file system. Option C is the correct answer.
Neither API provides a single method to delete a directory tree.
|
17_ C. The Files.delete() method has a return type of void, not boolean, resulting in
a compilation error and making Option C the correct answer. There is another method,
Files.deleteIfExists(), which returns true if the file is able to be deleted. If it was used
here instead, the file would compile and print a list of true values, making Option A the
correct answer. As stated in the description, the directory tree is fully accessible, so none of
the Files.deleteIfExists() would return false.
|
18_ D. First off, DosFileAttributes and PosixFileAttributes extend
BasicFileAttributes, which means they are compatible with the readAttributes()
method signature. Second, they produce instances that inherit the interface
BasicFileAttributes, which means they can be assigned to a variable b of type
BasicFileAttributes without an explicit cast. For this reason, all three interfaces
are permitted, and Option D is the correct answer.
|
19_ D. The relativize() method requires that both path values be absolute or relative. Based
on the details provided, p1 is a relative path, while p2 is an absolute path. For this reason,
the code snippet produces an exception at runtime, making Option D the correct answer.
If the first path was modified to be absolute by dropping the leading dot (.) in the path
expression, then the output would match the values in Option A.
|
20_ C. First off, p2 is an absolute path, which means that p1.resolve(p2) just returns p2. For
this reason, Option B is incorrect. Since p1 is a relative path, it is appended onto p2, making
Option C correct and Option A incorrect.
|
21_ B. The code does not compile because Files.list() returns a Stream<Path>, not a
List<Path>, making Option B the correct answer. Note that java.io.File does include
a list() method that returns an array of String values and a listFiles() method that
returns an array of File values, but neither is applicable here.
|
22_ C. For this problem, remember that the path symbols can be applied to simplify the path
before needing to apply any symbolic links in the file system. The paths in Options A and
B can both be reduced from /objC/bin/../backwards/../forward/Sort.java and
/objC/bin/../forward/./Sort.java, respectively, to /objC/forward/Sort.java just
using the path symbols. Because of the symbolic link, this references the same file as
/java/Sort.java. For these reasons, Options A and B match our target path.
Option C can be reduced from /objC/bin/../java/./forward/Sort.java to
/objC/java/forward/Sort.java, which does not match the desired path for the file. The
symbolic link is not followed since it exists in the /objC directory, not in the /objC/java
directory. This causes a stack trace to be printed at runtime since the path does
not exist, making Option C the correct answer. Option D can be reduced from
/objC/bin/../../java/Sort.java to /java/Sort.java, which matches the target path
without using the symbolic link.
|
23_ B. We need to empty the /objC directory before we can delete it. First, the Heap.exe file
would have to be deleted before the bin directory could be removed, for a total of two
calls to Files.delete(). Next, the Heap.m file is easily deleted with a single call to
Files.delete(). Calling Files.delete() on the symbolic link forward deletes the link
itself and leaves the target of the symbolic link intact. With a total of four calls, Option B is
the correct answer. Option A is incorrect because Java requires directories to be empty before
they can be deleted. Option C is also incorrect. It might make sense if Files.delete()
traversed symbolic links on a delete, but since this is not the case, it is an incorrect answer.
Option D is incorrect because there is no Files.deleteSymbolicLink() method defined in
the Java NIO.2 API.
|
24_ C. Since System.out is a PrintStream that inherits OutputStream and implements
Closeable, line y1 compiles without issue. On the other hand, the Files.copy()
does not compile because there is no overloaded version of Files.copy() that takes an
OutputStream as the first parameter. For this reason, Option C is the correct answer. If
the order of the arguments in the Files.copy() call was switched, then the code would
compile and print the contents of the file at runtime, making Option D the correct answer.
|
25_ B. To begin with, the BasicFileAttributeView class contains methods to read and write
file data, while the BasicFileAttributes class only contains methods to read file data.
The advantage of using a BasicFileAttributeView is to also modify file data, so Option
D is incorrect. Next, The BasicFileAttributeView does not include a method to modify
the hidden attribute. Instead, a DosFileAttributeView is required, making Option A
incorrect. Option B is the correct answer because BasicFileAttributeView includes a
setTimes() method to modify the file date values. Finally, Option C is incorrect because
both read file information in a single round-trip.
|
26_ A. Trick question! The code does not compile, therefore no Path values are printed, and
Option A is the correct answer. The key here is that toRealPath() interacts with the file
system and therefore throws a checked IOException. Since this checked exception is not
handled inside the lambda expression, the class does not compile. If the lambda expression
was fixed to handle the IOException, then the expected number of Path values printed
would be six, and Option C would be the correct answer. A maxDepth value of 1 causes the
walk() method to visit two total levels, the original /flower and the files it contains.
|
27_ D. The first statement returns a null value, since the path .. does not have a parent. That
said, it does not throw an exception at runtime, since it is not operated upon. The second
and third statements both return paths representing the root (/) at runtime. Remember
that calling getRoot() on a root path returns the root path. The fourth statement throws a
NullPointerException at runtime since getRoot() on a relative path returns null, with
the call to getParent() triggering the exception. Since the fourth statement is the only one
to produce a NullPointerException at runtime, Option D is the correct answer.
|
28_ C. The code compiles without issue, so Options A and B are incorrect. While many of the
Files methods do throw IOException, most of the Path methods do not throw a checked
exception. The lack of indent of the return statement on line 6 is intentional and does not
prevent the class from compiling. If the input argument p is null or not an absolute path,
then the if-then clause is skipped, and it is returned to the caller unchanged. Alternatively,
if the input argument is an absolute path, then calling toAbsolutePath() has no effect. In
both cases, the return value of the method matches the input argument, making Option C
the correct answer.
|
29_ D. Option A is incorrect because both methods take exactly one Path parameter, along
with an optional vararg of FileAttribute values. Option B is also incorrect because both
methods will throw a FileAlreadyExistsException if the target exists and is a file.
Option C is incorrect since both methods declare a checked IOException. The correct
answer is Option D. The method createDirectory() creates a single directory, while
createDirectories() may create many directories along the path value.
|
30_ C. The toAbsolutePath() combines the current working directory and relative path to
form a /hail/../jungle/.././rain.. path. The normalize() method removes the path
symbols and leaves a /rain.. value. Note that the last double period (..) is not removed
because it is part of a path name and not interpreted as a path symbol. The result is then
appended with snow.txt and we are left with /rain../snow.txt, making Option C the
correct answer.
|
31_ A. The program compiles and runs without issue, so Options C and D are incorrect. The process
breaks apart the inputted path value and then attempts to reconstitute it. There is only
one problem. The method call getName(0) does not include the root element. This results in
the repaired variable having a value of tissue/heart/chambers.txt, which is not equivalent
to the original path. The program prints false, and Option A is the correct answer.
|
32_ B. Unlike Files.delete(), the Files.deleteIfExists() method does not throw an
exception if the path does not exist, making Option B the correct answer. Options A, C,
and D describe situations in which the Java process encounters a path in a state that cannot
be deleted. In each of these situations, an exception would be thrown at runtime.
|
33_ D. The code does not compile because Path is an interface and does not contain a get()
method. Since the first line contains a compilation error, Option D is the correct answer. If
the code was corrected to use Paths.get(), then the output would be true false true,
and Option B would be the correct answer. The normalized path of both is /desert/sand.
doc, which means they would be equivalent, in terms of equals(), and point to the same
path in the file system. On the other hand, the non-normalized values are not equivalent, in
terms of equals(), since the objects represent distinct path values.
|
34_ C. First off, the Files.getFileAttributeView() method requires a reference to a subclass
of FileAttributeView, such as BasicFileAttributeView.class. The parameter must also
be compatible with the reference assignment to vw. For these two reasons, this line of code
does not compile. Next, BasicFileAttributeView does not contain a creationTime()
method, so vw.creationTime() results in a compilation error. For the exam, remember that
view classes do contain access to attributes, but only through the readAttributes method,
such as vw.readAttributes().creationTime(). Since these are the only two lines that contain
compilation errors, Option C is the correct answer. Note that we purposely omitted all
import statements in this question, since this may happen on the real exam.
|
35_ B. The program compiles and runs without issue, making Options C and D incorrect.
The first variable, halleysComet, is created with normalize() being applied right away,
leading to a value of stars/m1.meteor. The second variable, lexellsComet, starts with a
value of ./stars/../solar/. The subpath() call reduces it to its first two components,
./stars. The resolve() method then appends m1.meteor, resulting in a value of
./stars/m1.meteor. Finally, normalize() further reduces the value to stars/m1.meteor.
Since this matches our first Path, the program prints Same!, and Option B is the correct answer.
|
36_ D. Both stream statements compile without issue, making Options A and B incorrect. The
two statements are equivalent to one another and print the same values at runtime. For this
reason, Option C is incorrect, and Option D is correct. There are some subtle differences in
the implementation besides one using walk() with a filter() and the other using find().
The walk() call does not include a depth limit, but since Integer.MAX_VALUE is the default
value, the two calls are equivalent. Furthermore, the walk() statement prints a stream of
absolute paths stored as String values, while the find() statement prints a stream of Path
values. If the input p was a relative path, then these two calls would have very different
results, but since we are told p is an absolute path, the application of toAbsolutePath()
does not change the results.
|
37_ A. The code does not compile because Files.lines() and Files.readAllLines() throw a
checked IOException, which must be handled or declared. For the exam, remember that other
than a handful of test methods, like Files.exists(), most methods in the NIO.2 Files
class that operate on file system records declare an IOException. Now, if the exceptions were
properly handled or declared within the class, then jonReads() would likely take more time
to run. Like all streams, Files.lines() loads the contents of the file in a lazy manner, meaning
the time it takes for jenniferReads() to run is constant regardless of the file size. Note
the stream isn’t actually traversed since there is no terminal operation. Alternatively,
Files.readAllLines() reads the entire contents of the file before returning a list of String
values. The larger the file, the longer it takes jonReads() to execute. Since the original question
says the file is significantly large, then if the compilation problems were corrected,
jonReads() would likely take longer to run, and Option C would be the correct answer.
|
38_ C. The first copy() method call on line q1 compiles without issue because it matches the
signature of a copy() method in Files. It also does not throw an exception because the
REPLACE_EXISTING option is used and we are told the file is fully accessible within the file
system. On the other hand, the second copy() method on line q2 does not compile. There
is a version of Files.copy() that takes an InputStream, followed by a Path and a list of
copy options. Because BufferedReader does not inherit InputStream, though, there is no
matching copy() method and the code does not compile. For this reason, Option C is the
correct answer.
|
39_ C. The Files.isSameFile() throws a checked IOException. Even though accessing the
file system can be skipped in some cases, such as if the Path instances are equivalent in
terms of equals(), the method still declares IOException since it may access the file system
to determine if the two Path instances refer to the same file. For this reason, Option C
is the correct answer. The rest of the methods listed do not throw any checked exceptions,
even though they do access the file system, instead returning false if the file does not exist.
|
40_ B. The program compiles and runs without issue, making Options C and D incorrect.
The program uses Files.list() to iterate over all files within a single directory. For
each file, it then iterates over the lines of the file and counts the sum. For this reason,
Option B is the correct answer. If the count() method had used Files.walk() instead of
Files.lines(), then the class would still compile and run, and Option A would be the
correct answer. Note that we had to wrap Files.lines() in a try-catch block because
using this method directly within a lambda expression without a try-catch block leads to
a compilation error.
|
1_ A. The ExecutorService interface defines the two submit() methods shown in Options
C and D. Because ExecutorService extends Executor, it inherits the execute(Runnable)
method presented in Option B. That leaves us with the correct answer, Option A, because
ExecutorService does not define nor inherit an overloaded method execute() that takes
a Callable parameter.
|
2_ B. The class compiles and runs without throwing an exception, making the first statement
true. The class defines two values that are incremented by multiple threads in parallel. The
first IntStream statement uses an atomic class to update a variable. Since updating an
atomic numeric instance is thread-safe by design, the first number printed is always 10, and
the second statement is true. The second IntStream statement uses an int with the preincrement
operator (++), which is not thread-safe. It is possible two threads could update
and set the same value at the same time, a form of race condition, resulting in a value less
than 5_ For this reason, the third statement is not true. Since only the first two statements
are true, Option B is the correct answer.
|
3_ C. Option A is incorrect, although it would be correct if Executors was replaced with
ExecutorService in the sentence. While an instance of ExecutorService can be obtained
from the Executors class, there is no method in the Executors class that performs a task
directly. Option B is also incorrect, but it would be correct if start() was replaced with
run() in the sentence. It is recommended that you override the run() method, not the
start() method, to execute a task using a custom Thread class. Option C is correct, and
one of the most common ways to define an asynchronous task. Finally, Option D is incorrect
because Options A and B are incorrect.
|
4_ D. Trick question! ExecutorService does not contain any of these methods. In order
to obtain an instance of a thread executor, you need to use the Executors factory class.
For this reason, Option D is the correct answer. If the question had instead asked which
Executors method to use, then the correct answer would be Option C. Options A and B
do not allow concurrent processes and should not be used with a CyclicBarrier expecting
to reach a limit of five concurrent threads. Option C, on the other hand, will create
threads as needed and is appropriate for use with a CyclicBarrier.
|
5_ C. CopyOnWriteArrayList makes a copy of the array every time it is modified, preserving
the original list of values the iterator is using, even as the array is modified. For this reason,
the for loop using copy1 does not throw an exception at runtime. On the other hand,
the for loops using copy2 and copy3 both throw ConcurrentModificationException
at runtime since neither allows modification while they are being iterated upon. Finally,
the ConcurrentLinkedQueue used in copy4 completes without throwing an exception at
runtime. For the exam, remember that the Concurrent classes order read/write access such
that access to the class is consistent across all threads and processes, while the synchronized
classes do not. Because exactly two of the for statements produce exceptions at runtime,
Option C is the correct answer.
|
6_ C. Resource starvation is when a single active thread is perpetually unable to gain access
to a shared resource. Livelock is a special case of resource starvation, in which two or more
active threads are unable to gain access to shared resources, repeating the process over and
over again. For these reasons, Option C is the correct answer. Deadlock and livelock are
similar, although in a deadlock situation the threads are stuck waiting, rather than being
active or performing any work. Finally, a race condition is an undesirable result when two
tasks that should be completed sequentially are completed at the same time.
|
7_ B. The class does not compile because the Future.get() on line 8 throws a checked
InterruptedException and ExecutionException, neither of which is handled nor
declared by the submitReports() method. If the submitReports() and accompanying
main() methods were both updated to declare these exceptions, then the application
would print null at runtime, and Option A would be the correct answer. For the exam,
remember that Future can be used with Runnable lambda expressions that do not have a
return value but that the return value is always null when completed.
|
8_ A. Options B and C are both proper ways to obtain instances of ExecutorService.
Remember that newSingleThreadExecutor() is equivalent to calling newFixedThreadPool()
with a value of 1. Option D is the correct way to request a single-threaded
ScheduledExecutorService instance. The correct answer is Option A. The method
newFixedScheduledThreadPool() does not exist in the Executors class, although there is
one called newScheduledThreadPool().
|
9_ A. The code compiles without issue but hangs indefinitely at runtime. The application
defines a thread executor with a single thread and 12 submitted tasks. Because only one
thread is available to work at a time, the first thread will wait endlessly on the call to
await(). Since the CyclicBarrier requires four threads to release it, the application
waits endlessly in a frozen condition. Since the barrier is never reached and the code
hangs, the application will never output Ready, making Option A the correct answer. If
newCachedThreadPool() had been used instead of newSingleThreadExecutor(), then the
barrier would be reached three times, and Option C would be the correct answer.
|
10_ D. First off, BlockingDeque is incorrect since it is an interface, not a class. Next,
ConcurrentLinkedDeque does support adding elements to both ends of an ordered data
structure but does not include methods for waiting a specified amount of time to do so,
referred to as blocking. ConcurentSkipListSet is also incorrect, since its elements are
sorted and not just ordered, and it does not contain any blocking methods. That leaves the
correct answer, Option D. A LinkedBlockingDeque includes blocking methods in which
elements can be added to the beginning or end of the queue, while waiting at most a specified
amount of time.
|
11_ A. The findAny() method can return any element of the stream, regardless of whether the
stream is serial or parallel. While on serial streams this is likely to be the first element in the
stream, on parallel streams the result is less certain. For this reason, Option A is the correct
answer. When applied to an ordered stream, the rest of the methods always produce the
same results on both serial and parallel streams. For this reason, these operations can be
costly on a parallel stream since it has to be forced into a serial process.
|
12_ D. The static method Array.asList() returns a List instance, which inherits the
Collection interface. While the Collection interface defines a stream() and
parallelStream() method, it does not contain a parallel() method. For this reason,
the second stream statement does not compile, and Option D is the correct answer. If
the code was corrected to use parallelStream(), then the arrays would be consistently
printed in the same order, and Option C would be the correct answer. Remember that the
forEachOrdered() method forces parallel streams to run in sequential order.
|
13_ D. To start with, the ForkJoinTask is the parent class of RecursiveAction and
RecursiveTask and does not contain a compute() method, neither abstract nor concrete,
making Options A and C automatically incorrect. The RecursiveTask class contains the
abstract compute() method that utilizes a generic return type, while the RecursiveAction
class contains the abstract compute() method that uses a void return type. For this reason,
Option D is the correct answer.
|
14_ B. An accumulator in a serial or parallel reduction must be associative and stateless. In
a parallel reduction, invalid accumulators tend to produce more visible errors, where the
result may be processed in an unexpected order. Option A is not associative, since (a-b)-c
is not the same as a-(b-c) for all values a, b, and c. For example, using values of 1, 2, and
3 results in two different values, -4 and 2. Option C is not stateless, since a class or instance
variable i is modified each time the accumulator runs. That leaves us with Option B, which
is the correct answer since it is both stateless and associative. Even though it ignores the
input parameters, it meets the qualifications for performing a reduction.
|
15_ B. The code does not compile because Callable must define a call() method, not a
run() method, so Option B is the correct answer. If the code was fixed to use the correct
method name, then it would complete without issue, printing Done! at runtime, and Option
A would be the correct answer.
|
16_ C. Part of synchronizing access to a variable is ensuring that read/write operations are
atomic, or happen without interruption. For example, an increment operation requires reading
a value and then immediately writing it. If any thread interrupts this process, then data
could be lost. In this regard, Option C shows proper synchronized access. Thread 2 reads a
value and then writes it without interruption. Thread 1 then reads the new value and writes
it. The rest of the answers are incorrect because one thread writes data to the variable inbetween
another thread reading and writing to the same variable. Because a thread is writing
data to a variable that has already been written to by another thread, it may set invalid
data. For example, two increment operations running at the same time could result in one
of the increment operations being lost.
|
17_ D. The code compiles and runs without issue. The two methods hare() and tortoise()
are nearly identical, with one calling invokeAll() and the other calling invokeAny(). The
key is to know that both methods operate synchronously, waiting for a result from one or
more tasks. Calling the invokeAll() method causes the current thread to wait until all
tasks are finished. Since each task is one second long and they are being executed in parallel,
the hare() method will take about one second to complete. The invokeAny() method
will cause the current thread to wait until at least one task is complete. Although the result
of the first finished thread is often returned, it is not guaranteed. Since each task takes one
second to complete, though, the shortest amount of time this method will return is after
one second. In this regard, the tortoise() method will also take about one second to
complete. Since both methods take about the same amount of time, either may finish first,
causing the output to vary at runtime and making Option D the correct answer. Note that
after this program prints the two strings, it does not terminate, since the ExecutorService
is not shut down.
|
18_ B. ConcurrentSkipListMap implements the SortedMap interface, in which the keys
are kept sorted, making Option B the correct answer. While the other answers define
ordered data structures, none are guaranteed to be sorted. Remember, if you see
SkipList as part of a concurrent class name, it means it is sorted in some way, such as
a sorted set or map.
|
19_ D. The synchronized block used in the getQuestion() method requires an object to
synchronize on. Without it, the code does not compile, and Option D is the correct answer.
What if the command was fixed to synchronize on the current object, such as using
synchronized(this)? Each task would obtain a lock for its respective object, then wait a
couple of seconds before requesting the lock for the other object. Since the locks are already
held, both wait indefinitely, resulting in a deadlock. In this scenario, Option A would be the
correct answer since a deadlock is the most likely result. We say most likely because even
with corrected code, a deadlock is not guaranteed. It is possible, albeit very unlikely, for the
JVM to wait five seconds before starting the second task, allowing enough time for the first
task to finish and avoiding the deadlock completely.
|
20_ B. The ScheduledExecutorService does not include a scheduleAtFixedDelay()
method, so Option A is incorrect. The scheduleAtFixedRate() method creates a new
task for the associated action at a set time interval, even if previous tasks for the same
action are still active. In this manner, it is possible multiple threads working on the same
action could be executing at the same time, making Option B the correct answer. On
the other hand, scheduleWithFixedDelay() waits until each task is completed before
scheduling the next task, guaranteeing at most one thread working on the action is
active in the thread pool.
|
21_ D. The application compiles, so Option B is incorrect. The stroke variable is threadsafe
in the sense that no write is lost since all writes are wrapped in a synchronized
method, making Option C incorrect. Even though the method is thread-safe, the value
of stroke is read while the threads may still be executing. The result is it may
output 0, 1000, or anything in-between, making Option D the correct answer. If the
ExecutorService method awaitTermination() is called before the value of stroke is
printed and enough time elapses, then the result would be 1000, and Option A would be
the correct answer.
|
22_ B. A race condition is an undesirable result when two tasks that should be completed
sequentially are completed at the same time. The result is often corruption of data in some
way. If two threads are both modifying the same int variable and there is no synchronization,
then a race condition can occur with one of the writes being lost. For this reason,
Option B is the correct answer. Option A is the description of resource starvation. Options
C and D are describing livelock and deadlock, respectively.
|
23_ A. The code compiles, so Option C is incorrect. The application attempts to count the elements
of the sheep array, recursively. For example, the first two elements are totaled by
one thread and added to the sum of the remainder of the elements in the array, which is
calculated by another thread. Unfortunately, the class contains a bug. The count value is
not marked static and not shared by all of the CountSheep subtasks. The value of count
printed in the main() menu comes from the first CountSheep instance, which does not
modify the count variable. The application prints 0, and Option A is the correct answer. If
count was marked static, then the application would sum the elements correctly, printing
10, and Option B would be the correct answer.
|
24_ D. First off, certain stream operations, such as limit() or skip(), force a parallel
stream to behave it a serial manner, so Option A is incorrect. Option B is also incorrect.
Although some operations could take less time to execute, there is no guarantee any operation
will actually be faster. For example, the JVM may only allocate a single thread to
a parallel stream. In other words, parallel streams may improve performance but do not
guarantee it. Option C is incorrect because parallel stream operations are not synchronized.
It is up to the developer to provide synchronization or use a concurrent collection
if required. Finally, Option D is the correct answer. The BaseStream interface, which all
streams inherit, includes a parallel() method. Of course, the results of an operation
may change in the presence of a parallel stream, such as when a stateful lambda expression
is used, but they all can be made parallel.
|
25_ A. The code compiles and runs without issue. The JVM will fall back to a single-threaded
process if all of the conditions for performing the parallel reduction are not met. The
stream used in the main() method is not parallel, but the groupingbyConcurrent()
method can still be applied without throwing an exception at runtime. Although performance
will suffer from not using a parallel stream, the application will still process
the results correctly. Since the process groups the data by year, Option A is the correct
answer.
|
26_ A. The code compiles and runs without issue. The three-argument reduce() method
returns a generic type, while the one-argument reduce() method returns an Optional.
The concat1() method is passed an identity "a", which it applies to each element, resulting
in the reduction to aCataHat. The lambda expression in the concat2() method reverses the
order of its inputs, leading to a value of HatCat. Therefore, Option A is the correct answer.
|
27_ A. The code compiles without issue, so Options B and C are incorrect. The f1 declaration
uses the version of submit() in ExecutorService, which takes a Runnable and returns
a Future<?>. The call f1.get() waits until the task is finished and always returns null,
since Runnable expressions have a void return type. The f2 declaration uses an overloaded
version of submit(), which takes a Callable expression and returns a generic Future
object. Since the double value can be autoboxed to a Double object, the line compiles
without issue with f2.get() returning 3.14159. For these reasons, Option A is the correct
answer. Option D is incorrect because no exception is expected to be thrown at runtime.
|
28_ C. The class compiles without issue, making Options A and D incorrect. The class attempts
to create a synchronized version of a List<Integer>. The size() and addValue() help
synchronize the read/write operations. Unfortunately, the getValue() method is not
synchronized so the class is not thread-safe, and Option C is the correct answer. It is possible
that one thread could add to the data object while another thread is reading from
the object, leading to an unexpected result. Note that the synchronization of the size()
method is valid, but since ThreadSafeList.class is a shared object, this will synchronize
all instances of the class to the same object. This could result in a substantial performance
cost if enough threads are creating ThreadSafeList objects.
|
29_ D. The post-decrement operator (––) decrements a value but returns the original value. It
is equivalent to the atomic getAndDecrement() method. The pre-increment operator (++)
increments a value and then returns the new value. It is equivalent to the incrementAndGet()
atomic operation. For these reasons, Option D is the correct answer.
|
30_ B. When a CyclicBarrier goes over its limit, the barrier count is reset to zero. The application
defines a CyclicBarrier with a barrier limit of 5 threads. The application then
submits 12 tasks to a cached executor service. In this scenario, a cached thread executor
will use between 5 and 12 threads, reusing existing threads as they become available. In
this manner, there is no worry about running out of available threads. The barrier will then
trigger twice, printing five 1s for each of the sets of threads, for a total of ten 1s. For this
reason, Option B is the correct answer. The application then hangs indefinitely, as discussed
in the next question.
|
31_ D. The application does not terminate successfully nor produce an exception at runtime,
making Options A and B incorrect. It hangs at runtime because the CyclicBarrier limit is
five, while the number of tasks submitted and awaiting activation is 12. This means that 2
of the tasks will be left over, stuck in a deadlocked state waiting for the barrier limit to be
reached but with no more tasks available to trigger it. For this reason, Option D is the correct
answer. If the number of tasks was a multiple of the barrier limit, such as 10 instead of 12,
then the application will still hang because the ExecutorService is never shut down. The
isShutdown() in the application finally block does not trigger a shutdown. Remember that
it is important to shut down an ExecutorService after you are finished with it, else it can
prevent a program from terminating. In this case, Option C would be the correct answer.
|
32_ C. The code does not compile because the blocking methods offerLast() and pollFirst()
each throw a checked InterruptedException that are not handled by the lambda expressions,
so Option C is the correct answer. If the lambda expressions were wrapped with
try-catch blocks, then the process would first add all items to the queue, then remove them
all of them, resulting in an output of 0. In this case, Option A would be the correct answer.
Even though the tasks are completed in parallel, each stream does not terminate until all
tasks are done. Note that 10 seconds is more than enough time under normal circumstances
to add/remove elements from the queue.
|
33_ A. First of all, the for loops using copy1 and copy4 both throw
ConcurrentModificationException at runtime since neither allows modification while they
are being iterated upon. Next, CopyOnWriteArrayList makes a copy of the array every time
it is modified, preserving the original list of values the iterator is using, even as the array is
modified. For this reason, the for loop using copy2 completes without throwing an exception
or creating an infinite loop. Finally, the ConcurrentLinkedDeque used in copy3 completes
without producing an exception or infinite loop. The Concurrent collections order read/write
access such that access to the class is consistent across all threads and processes, even iterators.
Because the values are inserted at the head of the queue using push() and the underlying data
structure is ordered, the new values will not be iterated upon and the loop finishes. Since none
of the for statements produce an infinite loop at runtime, Option A is the correct answer. If
push() had been used instead of offer() in the third loop, with new values being inserted at
the tail of the queue instead of at the head, then the for loop would have entered an infinite
loop, and Option B would be the correct answer.
|
34_ B. Options A, C, and D are the precise requirements for Java to perform a concurrent
reduction using the collect() method, which takes a Collector argument. Recall
from your studies that a Collector is considered concurrent and unordered if it has the
Collector.Characteristics enum values CONCURRENT and UNORDERED, respectively.
Option B is the correct answer because elements of a stream are not required to implement
Comparable in order to perform a parallel reduction.
|
35_ D. The class compiles and runs without issue, making Options A and B incorrect. The
purpose of the fork/join framework is to use parallel processing to complete subtasks across
multiple threads concurrently. Unfortunately, calling the compute() method inside of an
existing compute() does not spawn a new thread. The result is that this task is completed
using a single thread, despite a pool of threads being available. For this reason, Option D is
the correct answer. In order to properly implement the fork/join framework, the compute()
method would need to be rewritten. The f1.compute() call should be replaced with
f1.fork() to spawn a separate task, followed by f2.compute() to process the data on the
current thread, and ending in f1.join() to retrieve the results of the first task completed
while f2.compute() was being processed. If the code was rewritten as described, then
Option C would be the correct answer.
|
36_ D. The shutdown() method prevents new tasks from being added but allows existing
tasks to finish. In addition to preventing new tasks from being added, the shutdownNow()
method also attempts to stop all running tasks. Neither of these methods guarantee any
task will be stopped, making Option D the correct answer. Option C is incorrect because
there is no halt() method in ExecutorService.
|
37_ B. First off, the class uses a synchronized list, which is thread-safe and allows modification
from multiple threads, making Option D incorrect. The process generates a list of numbers
from 1 to 5 and sends them into a parallel stream where the map() is applied, possibly out
of order. This results in elements being written to db in a random order. The stream then
applies the forEachOrdered() method to its elements, which will force the parallel stream
into a single-threaded state. At runtime, line p1 will print the results in order every time
as 12345. On the other hand, since the elements were added to db in a random order, the
output of line p2 is random and cannot be predicted ahead of time. Since the results may
sometimes be the same, Option B is the correct answer. Part of the reason that the results
are indeterminate is that the question uses a stateful lambda expression, which based on
your studies should be avoided in practice!
|
38_ C. The program compiles and does not throw an exception at runtime, making Options
B and D incorrect. The class attempts to add and remove values from a single cookie
variable in a thread-safe manner but fails to do so because the methods deposit() and
withdrawal() synchronize on different objects. The instance method deposit() synchronizes
on the bank object, while the static method withdrawal() synchronizes on
the static Bank.class object. Even though method calls of the same type are protected,
calls across the two different methods are not. Since the compound assignment operators
(+=) and (-=) are not thread-safe, it is possible for one call to modify the value of cookies
while the other is already operating on it, resulting in a loss of information. For this reason,
the output cannot be predicted, and Option C is the correct answer. If the two sets
of calls were properly synchronized on the same object, then the cookies variable would
be protected from concurrent modifications, and Option A would be the correct answer.
|
39_ A. The code attempts to search for a matching element in an array recursively. While it
does not contain any compilation problems, it does contain an error. Despite creating
Thread instances, it is not a multi-threaded program. Calling run() on a Thread runs
the process as part of the current thread. To be a multi-threaded execution, it would need
to instead call the start() method. For this reason, the code completes synchronously,
waiting for each method call to return before moving on to the next and printing true
at the end of the execution, making Option A the correct answer. On the other hand, if
start() had been used, then the application would be multi-threaded but then the result
may not be ready by the time the println() method is called, resulting in a value that
cannot be predicted ahead of time. In this case, Option D would be the correct answer.
|
40_ C. Line 13 does not compile because the execute() method has a return type of void,
not Future. Line 15 does not compile because scheduleAtFixedRate() requires
four arguments that include an initial delay and period value. For these two reasons,
Option C is the correct answer.
|
1_ C. Connection is an interface for communicating with the database. Driver is tricky
because you don’t write code that references it directly. However, you are still required to
know it is a JDBC interface. DriverManager is used in JDBC code to get a Connection.
However, it is a concrete class rather than an interface. Since Connection and Driver are
JDBC interfaces, Option C is correct.
|
2_ D. Database-specific implementation classes are not in the java.sql package. The implementation
classes are in database drivers and have package names that are specific to the
database. Therefore, Option D is correct. The Driver interface is in the java.sql package.
Note that these classes may or may not exist. You are not required to know the names of
any database-specific classes, so the creators of the exam iare free to make up names.
|
3_ D. All JDBC URLs begin with the protocol jdbc followed by a colon as a delimiter. Option
D is the only one that does both of these, making it the answer.
|
4_ A. The Driver interface is responsible for getting a connection to the database, making
Option A the answer. The Connection interface is responsible for communication with the
database but not making the initial connection. The Statement interface knows how to run
the SQL query, and the ResultSet interface knows what was returned by a SELECT query.
|
5_ B. The requirement to include a java.sql.Driver file in the driver jar file was introduced
in JDBC 4.0. A 3.0 driver is allowed, but not required, to include this file. JDBC 3.0 also
requires a call to Class.forName(). As a result, Option B best fills in the blanks.
|
6_ C. Connection is an interface. Since interfaces do not have constructors, Option D is
incorrect. The Connection class doesn’t have a static method to get a Connection either,
making Option A incorrect. The Driver class is also an interface without static methods,
making Option B incorrect. Option C is the answer because DriverManager is the class
used in JDBC to get a Connection.
|
7_ B. The DriverManager.getConnection() method can be called with just a URL. It is also
overloaded to take the URL, username, and password, making Option B correct.
|
8_ D. CallableStatement and PreparedStatement are interfaces that extend the Statement
interface. You don’t need to know that for the exam. You do need to know that a database
driver is required to provide the concrete implementation class of Statement rather than
the JDK. This makes Option D correct. Note that while Derby is provided with Java, it is in
a separate jar from the “main” JDK.
|
9_ C. A JDBC URL has three components separated by colons. All three of these URLs meet
those criteria. For the data after the component, the database driver specifies the format.
Depending on the driver, this might include an IP address and port. Regardless, it needs
to include the database name or alias. I and II could both be valid formats because they
mention the database box. However, III only has an IP address and port. It does not have a
database name or alias. Therefore III is incorrect and Option C correct.
|
10_ C. The requirement to include a java.sql.Driver file in the driver jar was introduced
in JDBC 4.0. A call to Class.forName() was made optional with JDBC 4.0. As a result,
Option C best fills in the blanks.
|
11_ A. Scroll sensitive is a result set type parameter, and updatable is a concurrency mode. The
result set type parameter is passed to createStatement() before the concurrency mode. If
you request options that the database driver does not support, it downgrades to an option
it does support rather than throwing an exception. Statements I and III are correct, making
Option A the answer.
|
12_ B. JDBC 4.0 allows, but does not require, a call to the Class.forName() method. However,
since it is in the code, it needs to be correct. This method is expecting a fully qualified
class name of a database driver, not the JDBC URL. As a result, the Class.forName()
method throws a ClassNotFoundException, and Option B is the answer.
|
13_ B. There are two ResultSet concurrency modes: CONCUR_READ_ONLY and
CONCUR_UPDATABLE. All database drivers support read-only result sets, but not all support
updatable ones. Therefore, Option B is correct.
|
14_ D. This code is missing a call to rs.next(). As a result, rs.getInt(1) throws a
SQLException with the message Invalid cursor state – no current row. Therefore,
Option D is the answer.
|
15_ D. The execute() method is allowed to run any type of SQL statements. The
executeUpdate() method is allowed to run any type of the SQL statement that returns
a row count rather than a ResultSet. Both DELETE AND UPDATE SQL statements are
allowed to be run with either execute() or executeUpdate(). They are not allowed to be
run with executeQuery() because they do not return a ResultSet. Therefore, Option D is
the answer.
|
16_ C. Connection is an interface rather than a concrete class. Therefore, it does not
have a constructor and line s2 does not compile. As a result, Option C is the answer.
Option A would be the answer if the code new Connection() was changed to
DriverManager.getConnection().
|
17_ A. There are three ResultSet type options: TYPE_FORWARD_ONLY, TYPE_SCROLL_INSENSITIVE,
and TYPE_SCROLL_SENSITIVE. Only one of these is in the list, making Option A correct.
|
18_ B. Unlike arrays, JDBC uses one-based indexes. Since num_pages is in the second column,
the parameter needs to be 2, ruling out Options A and C. Further, there is not a method
named getInteger() on the ResultSet interface, ruling out Option D. Since the proper
method is getInt(), Option B is the answer.
|
19_ D. Option A does not compile because you have to pass a column index or column name to
the method. Options B and C compile. However, there are not columns named 0 or 1. Since
these column names don’t exist, the code would throw a SQLException at runtime. Option
D is correct as it uses the proper column name.
|
20_ B. The parameters to createStatement() are backward. However, they still compile
because both are of type int. This means the code to create the Statement does compile,
and Option A is incorrect. Next comes the code to create the ResultSet. While both
execute() and executeQuery() can run a SELECT SQL statement, they have different
return types. Only executeQuery() can be used in this example. The code does not compile
because the execute() method returns a boolean, and Option B is correct. If this was
fixed, Option D would be the answer because rs.next() is never called.
|
21_ D. Since this code opens Statement using a try-with-resources, Statement gets closed
automatically at the end of the block. Further, closing a Statement automatically closes a
ResultSet created by it, making Option D the answer. Remember that you should close
any resources you open in code you write.
|
22_ C. Option A is incorrect because Driver is an interface while DriverManager is a concrete
class. The inverse isn’t true either; DriverManager doesn’t implement Driver. Option B
is incorrect because the Connection implementation comes from the database driver jar.
Option C is correct. You can turn off auto-commit mode, but it defaults to on. Option D is
incorrect because you need to call rs.next() or an equivalent method to point to the first
row.
|
23_ C. The requirement to include a java.sql.Driver file in the META-INF directory was
introduced in JDBC 4.0. Older drivers are not required to provide it, making Option B
incorrect. A file named jdbc.driver has never been a requirement. Option A is incorrect
and is simply here to trick you. All drivers are required to implement the Connection interface,
making Option C the answer.
|
24_ D. First, rs.next() moves the cursor to point to the first row, which contains the number
10. Line q1 moves the cursor to immediately before the first row. This is the same as the
position it was in before calling rs.next() in the first place. It is a valid position but isn’t
a row of data. Line q2 tries to retrieve the data at this position and throws a SQLException
because there isn’t any data, making Option D the answer.
|
25_ B. This code shows how to properly update a ResultSet. Note that it calls updateRow()
so the changes get applied in the database. This allows the SELECT query to see the changes
and output 10. Option B is correct. Remember that unlike this code, you should always
close a ResultSet when you open it in real code.
|
26_ C. There is no ResultSet method named prev(). Therefore, the code doesn’t compile, and
Option C is correct. If prev() was changed to previous(), the answer would be Option B
because updateRow() is never called. Remember that unlike this code, you should always
close a ResultSet when you open it in real code.
|
27_ D. While the code turns off automatic committing, there is a commit() statement after the
first two inserts that explicitly commits those to the database. Then automatic commit is
turned back on and the third commit is made, making Option D the answer.
|
28_ A. The count(*) function in SQL always returns a number. In this case, it is the number
zero. This means line r1 executes successfully because it positions the cursor at that row.
Line r2 also executes successfully and prints 0, which is the value in the row. Since the code
runs successfully, Option A is the answer.
|
29_ B. The cursor starts out at position zero, right before the first row. Line 6 moves the cursor
to position five. Line 7 tries to move the cursor ten rows before that position which is row
negative five. Since you can’t move back before row zero, the cursor is at row zero instead.
Then line 8 moves the cursor forward five positions from row zero, leaving it at row five
and making Option B the answer.
|
30_ C. JDBC 4.0 allows, but does not require, a call to the Class.forName() method. Since
the database does not exist, DriverManager.getConnection() throws a SQLException,
and Option C is the answer.
|
31_ D. When running a query on a Statement, Java closes any already open ResultSet
objects. This means that rs1 is closed on line 8. Therefore, it throws a SQLException on
line 9 because we are trying to call next() on a closed ResultSet, and Option D is correct.
|
32_ B. The code turns off automatic committing, so the inserts for red and blue are not immediately
made. The rollback() statement actually prevents them from being committed.
Then automatic commit is turned back on and one insert is made, making Option B the
answer.
|
33_ A. This code correctly obtains a Connection and Statement. It then runs a query, getting
back a ResultSet without any rows. The rs.next() call returns false, so nothing is
printed, making Option A correct.
|
34_ B. Since the ResultSet type allows scrolling, the code does not throw a SQLException
at runtime. Immediately after getting the ResultSet, the cursor is positioned at the end
immediately after Scott’s row. The next two lines try to move forward one row. This has
no effect since the cursor is already at the end. Then previous() moves the cursor to point
to the last row, which is Scott’s row. The second previous() call moves the cursor up one
more row to point to Elena’s row, making Option B the answer.
|
35_ B. When passing a negative number to absolute(), Java counts from the end instead of
the beginning. The last row is Scott’s row, so the first print statement outputs Scott. When
passing a positive number to absolute(), Java counts from the beginning, so Jeanne is
output. Therefore, Option B is correct.
|
36_ D. When creating the Statement, the code doesn’t specify a result set type. This means it
defaults to TYPE_FORWARD_ONLY. The absolute() method can only be called on scrollable
result sets. The code throws a SQLException, making Option D the answer.
|
37_ B. This code does not compile because the ResultSet options need to be supplied when
creating the Statement object rather than when executing the query. Since the code does
not compile, Option B is correct.
|
38_ B. The code turns off automatic committing, so the inserts for red and blue are not immediately
made. The rollback() statement says to prevent any changes made from occurring.
This gets rid of red and blue. Then automatic commit is turned back on and the one insert
for green is made. The final rollback has no effect since the commit was automatically
made. Since there was one row added, Option B is the answer.
|
39_ D. Line 18 doesn’t compile because beforeFirst() has a void return type. Since the
code doesn’t compile, it doesn’t print true at all, and Option D is correct. If line 18 called
rs.beforeFirst() without trying to print the result, Option B would be the answer. All
the other statements are valid and return true.
|
40_ B. When manually closing database resources, they should be closed in the reverse order
from which they were opened. This means that the ResultSet object is closed before the
Statement object and the Statement object is closed before the Connection object. This
makes Option B the answer.
|
1_ D. Oracle defines a locale as a geographical, political, or cultural region. Time zones often
span multiple locales, so Option D is correct.
|
2_ C. Currencies vary in presentation by locale. For example, 9,000 and 9.000 both represent
nine thousand, depending on the locale. Similarly, for dates, 01-02-1991 and 02-01-1991
represent January 2, 1991, depending on the locale. This makes Option C the answer.
|
3_ C. The Locale object provides getDefault() and setDefault() methods for working
with the default locale, so Option C is correct. There is no get() method declared on
Locale.
|
4_ A. Internationalization means the program is designed so it can be adapted for multiple
languages. By extracting the town names, this is exactly what has happened here, making
Option A correct. Localization means the program actually supports multiple locales.
There’s no mention of multiple locales here, so Option B is incorrect. Similarly, there is no
mention of multiple languages, making Option D incorrect. Finally, specialization is not a
term relevant to properties, making Option C incorrect.
|
5_ A. The Properties class is a Map, making III correct. Hashtable and HashMap are concrete
classes rather than interfaces, so I and II are incorrect. While a Properties object is a
Hashtable, this is not an interface. Since only III is correct, Option A is the answer.
|
6_ C. Java supports properties file resource bundles and Java class resource bundles. Properties
file resource bundles contain String keys and String values. Java class resource
bundles contain String keys and any type of classes as values. Since both are valid, Option
C is correct.
|
7_ B. Calling Locale.setDefault() changes the default locale within the program. It does
not change any settings on the computer. The next time you run a Java program, it will
have the original default locale rather than the one you changed it to.
|
8_ B. Line 18 prints the value for the property with the key mystery, which is bag. Line 19
prints a space. Line 20 doesn’t find the key more so it prints null. Therefore, it prints
bag null, and Option B is correct.
|
9_ C. There is not a built-in class called JavaResourceBundle, making Options A and B
incorrect. The ListResourceBundle class is used to programmatically create a resource
bundle. It requires one method to be implemented named getContents(), making Option
D incorrect and Option C correct. This method returns a 2D array of key/value pairs.
|
10_ A. When both a language and country code are present, the language code comes first. The
language code is in all lowercase letters and the country code is in all uppercase.
|
11_ C. Java starts out by looking for a Java file with the most specific match, which is language
and country code. Since this is happening at runtime, it is looking for the corresponding file
with a .class extension. This matches Option C, making it the answer. If this file was not
found, Java would then look for a .properties file with the name, which is Option D. If
neither was found, it would continue dropping components of the name, eventually getting
to Options A and B in that order.
|
12_ A. This class correctly creates a Java class resource bundle. It extends ListResourceBundle
and creates a 2D array as the property contents. Since count is an int, it is autoboxed
into an Integer. In the main() method, it gets the resource bundle without a locale and
requests the count key. Since Integer is a Java Object, it calls getObject() to get the
value. The value is not incremented each time because the getContents() method is only
called once. Therefore, Option A is correct.
|
13_ A. A Locale can consist of a language only, making Option A correct. It cannot consist of
a country code without a language, so Option B is incorrect. Finally, if both a language and
country code are present, the language code is first, making Option C incorrect.
|
14_ A. Java supports properties file resource bundles and Java class resource bundles. Properties
file resource bundles require String values, making Option B incorrect. Java class
resource bundles allow any type of classes as values. Since the question asks about defining
values, it is the .java source code rather than the .class bytecode file, making Option A
the answer.
|
15_ C. At least one matching resource bundle must be available at the time of the call to
getBundle(). While the requested key determines which of the resource bundles is used, at
least one must exist simply to get the ResourceBundle reference, so Option C is the answer.
|
16_ D. The Properties class implements Map. While the get() method, inherited from the
superclass, is available, it returns an Object. Since Object cannot be cast to String, it does
not compile, and Option D is the answer.
|
17_ D. Java supports properties file resource bundles and Java class resource bundles. Both
require String as the key format, so Option D is the answer.
|
18_ A. Java starts out by looking for a Java file with the most specific match, which is language
and country code. Since there is no such matching file, it drops the country code
and looks for a match by language code. Java looks for bytecode files before properties
files. Therefore, Option A is the answer. If it wasn’t present, Option B would be the
next choice. Options C and D would never be considered, as a locale doesn’t just have a
country code.
|
19_ D. There is no get() method on Locale. You need to use a constructor or a predefined
Locale constant to obtain a Locale object. Therefore, Option D is the correct answer.
Option B is close in that Locale.ITALIAN does reference a Locale object. However, it
should not be passed to the nonexistent get() method.
|
20_ A. This code creates a Map with two elements. Then it copies both key/value pairs to a
Properties object. This works because a Properties object is also a Map and therefore
has a put() method that takes Object parameters. Finally, the code gets the String property
values of both keys and prints hammer nail. Therefore, Option A is correct.
|
21_ D. The code attempts to create a Java class resource bundle. However, the Type class does
not extend ListResourceBundle. It compiles, but throws an exception on line 9 because
no resource bundle is actually defined. Therefore, Option D is correct.
|
22_ D. This code compiles and runs without exception, making Option D the answer. Line 3
uses a predefined Locale constant. Line 5 passes a language and country code for English
in Australia. Line 7 incorrectly passes capital letters as a language code. However, Java
automatically converts it to lowercase without throwing an exception. The three lines
printed by the code are ko, en_US and en.
|
23_ C. Line 18 prints the value for the property with key mystery, which is bag. Line 19 prints
a space. Line 20 doesn’t find the key more so it uses the second parameter ? as the default
value. The code prints bag ?, so Option C is correct.
|
24_ B. The getBundle() method matches Cars_fr_FR.properties since that is the requested
locale. The country key is in that properties file directly, so France is used as the value.
The engine key is not, so Java looks higher up in the hierarchy and finds it in the languagespecific
Cars_fr.properties file and uses moteur as the value. Therefore, Option B is correct.
Note that the default locale isn’t used.
|
25_ D. The getBundle() method matches Cars_fr.properties. Since the requested locale of
French Canada is not available, it uses the language-specific locale of French. The engine
key is in that properties file directly, so moteur is retrieved as the value. However, we have
a problem getting the horses key. It is not in the hierarchy of Cars_fr.properties. It is
in the English properties file, but Java cannot look at the default locale if it found a match
with the requested locale. As a result, the code throws a MissingResourceException,
making Option D the answer.
|
26_ A. The getBundle() method matches Cars_en.properties. Since the requested locale of
English Canada is not available, it uses the language-specific locale of English. The engine
key is in that properties file directly, so engine is retrieved as the value. The horses key is
also in that properties file, so 241 is used as the value, and Option A is the answer.
|
27_ B. A ListResourceBundle is a Java class that provides key/value pairs. The values can
be any Java class type and can be created at runtime, making Options A and C false statements.
When you want to provide a language-specific resource bundle, an underscore and
the language code are added after the class name. Since Option B does not have an underscore,
it is a false statement. Since all three statements are false, Option D is the answer.
|
28_ D. Since a Locale is passed when requesting the ResourceBundle, that Locale is used first
when looking for bundles. Since there isn’t a bundle called Colors_zh_CN.properties, Java
goes on to check for the language. Option D provides a match on language. If this was
not found, Java would go on to the default locale, eventually matching Option B. Since
country is not used without language, Options A and C would not be considered as
options.
|
29_ B. This class correctly creates a Java class resource bundle. It extends
ListResourceBundle and creates a 2D array as the property contents. In the main()
method, it gets the resource bundle without a locale and requests the count key. Since this
is a Java Object, it calls getObject() to get the value and casts it to the correct type. Then
the getCount() method is called twice, incrementing each time, making Option B the correct
answer. Note that having a mutable object as a property is a bad practice.
|
30_ D. Line 10 is incorrect. It tries to get a bundle named Type. However, this code is in a
package and named keyboard.Type. Therefore, a MissingResourceException is thrown,
and Option D is correct.
|
31_ B. Since no locale is specified, the code tries to find a bundle matching the default
locale. While none of the resource bundles match English United States, two do match
the language English. The Java class one is used since it is present. Since the Java
resource bundle for English doesn’t have a key wheels, we go up to the parent resource
bundle. The default Java resource bundle does have the key wheels with the value 4, so
Option B is correct.
|
32_ D. Since no locale is specified, the code tries to find a bundle matching the default locale.
Two resource bundles match the language English. The Java class one is used since it is
present. However, it does not contain a key color, nor does its parent. Java does not
allow looking in a properties file resource bundle once it has matched a Java class resource
bundle. Therefore, it throws a MissingResourceBundleException, and Option D is the
answer.
|
33_ B. Since no locale is specified, the code tries to find a bundle matching the default locale.
None of the resource bundles match the language, so the default resource bundle is used.
The default Java resource bundle is used since it is present and has the key wheels with the
value 4_ Therefore, Option B is correct.
|
34_ A. Since a locale is passed when requesting the ResourceBundle, that locale is used first
when looking for bundles. Since there isn’t a bundle for that locale, Java checks for the
language zh. There still isn’t a match, so Java goes on to check for the default locale. Still
no match. Next Java checks the language of the default locale and finally finds a match in
Option A. If that match wasn’t found, Java would match on Option B, which is the default
bundle. Option C would never be checked since the base name is Red rather than the
requested Color.
|
35_ C. A Properties object implements Map. This makes the get() method available.
Properties also defined a getProperty() method. Therefore, both methods can fill in the
blank, and Option C is correct.
|
36_ B. This code compiles and runs without issue. It creates a default Java class resource bundle.
Lines 5 through 7 show it has one key and one ArrayList value. Line 9 gets a reference
to the resource bundle. Lines 10 through 16 retrieve the ArrayList and add six values to
it. Since this is a reference, line 17 gets the same object and prints the size of 6. Therefore,
Option B is correct.
|
37_ B. The class on line p1 should be Properties rather than Property. As written it is incorrect
and does not compile, making Option B the answer.
|
38_ C. ResourceBundle is an abstract class and uses a factory to obtain the right subclass.
Since a call to the constructor new ResourceBundle() does not compile, Option C is the
answer. If this was fixed, Option A would be the answer because getContents() is only
called once.
|
39_ A. This code sets the default locale to English and then tries to get a resource
bundle for container in the pod package. It finds the resource bundle
pod.container_en.properties as the most specific match. Both keys are found in this
file, so Option A is the answer.
|
40_ D. Option C is not a valid match for this resource bundle because the base name is Red
rather than the requested Colors. Options A and B are not valid matches because they
contain uppercase letters for the language code while Java requires lowercase. Since none
match, Option D is correct, and the code throws an exception at runtime.
