1. D. The toString() method is declared in the Object class. Therefore it is available to be
called in any Java class and is overridden in some. Java automatically calls the toString()
method when you print an object, making Option D correct. Option C is incorrect because
toString() is a method, not a variable.
|
2. B. This code is not a singleton because it has a public constructor. Remember that a
public no-argument constructor is provided automatically if no constructor is coded. This
code is well encapsulated because the instance variable is private. It is not immutable since
there is a setter method. Therefore, Option B is correct.
|
3. C. The singleton pattern ensures there will be no more than one instance of the object.
Depending on how it is implemented, it is possible for there to be zero instances. But it is
not possible to have more than one, making Option C correct. Option D means the variable
is shared across instances or even without an instance being created but does not limit the
number of the instances of the class itself.
|
4. C. Both objects are instances of the class Laptop. This means the startup() method in the
Laptop class gets called both times thanks to polymorphism.
|
5. D. We know that the variable o that equals() is called on isn’t null, since we can’t call
instance methods on a null reference. However, a null reference could be passed as a
method parameter. If a null is passed in, the method should return false since an object
and a null are not equal. Options A and B are incorrect because the first line of those
methods should return false rather than true. Option C is incorrect because the cast is
missing. The Object class does not have a text variable available. Option D shows a properly
implemented equals() method and is correct.
|
6. A. Option A is correct because mutability means the state can change and immutability
means it cannot. In Option C, static means the state isn’t tied to an instance. In Option B,
rigidity is not a common programming term.
|
7. B. The Hammer class is a subclass of the Tool class. Since the use() method in Hammer is
intended to override the one in Tool, there are certain rules. One is that the access modifier
must not be more specific. Therefore, trying to make it private is a problem. Option B is
correct and r2 is the only line with a compiler error in this code.
|
8. D. The singleton pattern requires that only one instance of the class exist. Neither of these
classes meets that requirement since they have the default no-argument constructor available.
There should have been a private constructor in each class. Therefore, Option D is
correct. Remember that the exam doesn’t always include import statements to simplify the
code you need to read.
|
9. B. While using null with instanceof compiles, it always returns false. The other two
instanceof calls show that instanceof can be used with both classes and interfaces. They
both return true, making Option B correct.
|
10. D. The static keyword is used to create a class-level variable, making Option D correct.
Note that a singleton is where you limit a class so only one instance can be created. This
means there are not multiple instances to share a variable across.
|
11. A. Option A is a requirement of a singleton class rather than an immutable one. The other
three options are requirements of an immutable class.
|
12. C. If the variables are public, the class is not encapsulated because callers have direct
access to them. This rules out Options A and B. Having private methods doesn’t allow the
callers to use the data, making Option D an undesirable answer. Option C is correct and
the classic definition of encapsulation where the data is not exposed directly.
|
13. A. While both objects are instances of Laptop, we are not calling methods in this example. Virtual
method invocation only works for methods, not instance variables. For instance variables,
Java actually looks at the type of the reference and calls the appropriate variable. This makes
each reference call a different class’s instance variable in this example, and Option A is correct.
|
14. B. An immutable class must not allow the state to change. In the Flower class, the caller
has a reference to the List being passed in and can change the size or elements in it. Similarly,
any class with a reference to the object can get the List by calling get() and make
these changes. The Flower class is not immutable. The Plant class shows how to fix these
problems and is immutable. Option B is correct.
|
15. C. An instance method can access both instance variables and static variables. Both
methods compile and Option C is correct.
|
16. B. A static method can access static variables, but not instance variables. The
getNumRakes() method does not compile, so Option B is correct.
|
17. A. You are allowed to use null with instanceof; it just prints false. The bus variable is
both a Vehicle and a Bus, so lines 18 and 19 print true. Then it gets interesting. We know
that bus is not an ArrayList or Collection. However, the compiler only knows that bus
is not an ArrayList because ArrayList is a concrete class. Line 20 does not compile. The
compiler can’t definitively state that bus is not a Collection. Some future program could
create a subclass of Bus that does implement Collection, so this line compiles. Therefore,
only line 20 fails to compile, and Option A is correct.
|
18. B. Building and House are both properly declared inner classes. Any House object can
be stored in a Building reference, making the declarations for p and r compile. The
declaration for s is also correct. It so happens that bh is a House object, so the cast works.
The declaration of q is a problem though. While the cast itself is fine, a Building cannot
be stored in a House reference, which means the assignment fails to compile. Option B is
correct and is the only line with a compiler error in this code. Note that if the declaration of
q was removed, the declaration of p would produce a ClassCastException at runtime.
|
19. D. If two instances of a class have the same hash code, they might or might not be equal.
The reverse is not true. If two objects are equal, they must have the same hash code in order
to comply with the contracts of these methods. However, in this case, the answer is none
of the above because the method can’t simply return true or false. Based on the rules of
equals(), if null is passed in, the result must be false. If an object identity is passed in,
the result must be true due to reflexivity. As a result, Option D is correct.
|
20. D. This class is a good example of encapsulation. It has a private instance variable and is
accessed by a public method. No changes are needed to encapsulate it, and Option D is correct.
|
21. B. The singleton pattern requires that only one instance of the class exist. The
ExamAnswers class is close. However, getExamAnswers() is not static, so you can’t retrieve
the instance. Option B is the answer because TestAnswers is a correct implementation. It has
a static variable representing the one instance and a static method to retrieve it.
|
22. C. The static initializer is only run once. The static method is run twice since it is
called twice. Therefore, three lines are printed, and Option C is correct.
|
23. C. Option A is allowed because the turnOn() method is public and can be called from
anywhere. Options B and D are allowed since the method is in the same class, which is
always allowed! Option C is not allowed because wash() is a package-private method in
another package. Option C is the correct answer.
|
24. B. The display() method has protected access. This means it can be accessed by
instance methods in the same package and any subclasses. There are no subclasses in this
example, so we only need to count the classes in the same package. Option B is correct
because Flashlight and Phone are in the package.
|
25. B. Line 15 calls the method on line 9 since it is a Watch object. That returns watch, making
Option A incorrect. Line 16 calls the method on line 3 since it is a SmartWatch object
and the method is properly overridden. That returns smart watch, so Option B is the
answer, and Option C is incorrect.
|
26. A. Clearly a Bus is a Vehicle since the Bus class implements Vehicle. The Van class is also
a Vehicle since it extends Bus. This question also confirms you know that arrays can be
tested with instanceof, which they can. Therefore, Option A is correct.
|
27. C. There is no instanceOf keyword, making Options B and D incorrect. There is an
instanceof keyword. If an object is the wrong type, the equals() method should return
false, making Option C the answer.
|
28. D. The Hammer class is a subclass of the Tool class. Luckily, the use() method has a different
signature so it is not an override. This means it is fine that the access modifier is stricter,
and Option D is correct. Line r3 is a valid method unrelated to the superclass.
|
29. B. Lazy instantiation is part of a possible implementation for the singleton pattern. It defers
creating the object until the first caller requests it. While this does save memory, it only
does so if the object is never requested. This does not save memory when actually creating
the object. Option B is correct.
|
30. D. Notice how the code begins at line 30. This means you have to infer the surrounding
code. Here it is reasonable to assume the classes are inner classes. Building and House are
defined correctly. Any House or Building reference can potentially be a House. The compiler
does not know which ones work and which don’t. This means all three casts compile.
|
31. C. Encapsulation doesn’t allow callers access to the instance variables, which makes it
easier to change the code. The instance variables can be any type, which means they can be
mutable or immutable. There are not constraints on the implementation of methods. The
purpose of encapsulation is to lessen how tightly tied or coupled the classes are. Option C is
the opposite of this, making it the answer.
|
32. A. An immutable class must not allow the state to change. The Flower class does this
correctly. While the class isn’t final, the getters are, so subclasses can’t change the value
returned. The Plant class lacks this protection, which makes it mutable. Option A is correct.
|
33. D. A static initializer is not allowed inside of a method. It should go on the class level
rather than the method level. Therefore, the code does not compile, and Option D is correct.
|
34. A. An object is required to have the same value for repeated calls to hashCode() if the value
has not changed. This makes III and IV incorrect. If two objects are equal, they are required
to have the same hash code. Since equality must be reflexive, it cannot return false if the
same object is passed, and I is incorrect. Since equals() must return false when null is
passed in, it cannot be true and II is incorrect. Therefore, Option A is the answer.
|
35. D. By definition, you cannot change the value of an instance variable in an immutable
class. There are no setter methods, making Option A incorrect. While Option B would
allow you to set the value, the class would no longer be immutable. Option D is correct. If
you are an advanced developer, you might know that you can use reflection to change the
value. Don’t read into questions like this on the exam. Reflection isn’t on the exam, so you
can pretend it doesn’t exist.
|
36. B. Option A is incorrect because the “is-a” principle is about inheritance. For example, a
String is an Object. Option C is incorrect because singletons require a static variable to
ensure there is only one instance. While it is common to have instance variables as well, this
is not required to implement the pattern. Option B is correct. For an object to be composed
of other objects, instance variables are required.
|
37. B. The static initializer only runs once since statics are shared by all instances. The instance
initializer runs twice because we call the constructor twice. Therefore, Option B is correct.
|
38. A. While there is a default keyword in Java, it is only allowed in interfaces or in switch
statements. It is not a visibility modifier. The author of this code probably intended for
the method to be package-private, which doesn’t use a visibility modifier. The line with
default doesn’t compile, so Option A is correct. If default was removed, the code would
all compile.
|
39. A. The reference b points to a Building object, which cannot be stored in a House reference.
This means the assignment to p compiles but fails at runtime. The other two casts
would run without issue if the code got that far.
|
40. C. The hashCode() method in the Object class does not have a parameter. Therefore, the
Sticker class provides an overloaded method rather than an overridden one. Since it is
not an overridden method, the contract for the Object class’ hashCode() method does not
apply, and any int value can be returned. Therefore, Option C is correct.
|
1. B. The lambda expression s -> true is valid, making Options A, C, and D incorrect.
Parentheses () are not required on the left-hand side if there is only one variable. Brackets
{} are not required if the right-hand side is a single expression. Parameter data types are
only required if the data type for at least one parameter is specified, otherwise none are
required. The remaining choice, the arrow operator ->, is required for all lambda expressions,
making Option B the correct answer.
|
2. D. The application contains a compilation error. The case statements incorrectly use the
enum name as well as the value, such as DaysOff.ValentinesDay. Since the type of the
enum is determined by the value of the variable in the switch statement, the enum name is
not allowed and throws a compilation error when used. For this reason, Option D is correct.
If the enum name DaysOff was removed, the application would output 12, since the
lack of any break statements causes multiple blocks to be reached, and Option C would
have been the correct answer.
|
3. C. A functional interface must include exactly one abstract method, either by inheritance
or declared directly. It may also have any number, including zero, of default or static
methods. For this reason, both parts of Option D are incorrect. The first part of Option A
is incorrect because more than one abstract method disqualifies it as a functional interface.
The first part of Option B is incorrect because the method must be abstract; that is
to say, any method will not suffice. Finally, Option C is the correct answer. The first part
of the sentence defines what it means to be a functional interface. The second part refers to
the optional @FunctionalInterface annotation. It is considered a good practice to add this
annotation to any functional interfaces you define because the compiler will report a problem
if you define an invalid interface that does not have exactly one abstract method.
|
4. C. While an anonymous inner class can extend another class or implement an interface, it cannot
be declared final or abstract since it has no class definition. For this reason, Option C is
correct. The other classes may be declared final or abstract since they have a class definition.
|
5. B. Option A is incorrect because the lambda expression is missing a semicolon (;) at the
end of the return statement. Option C is incorrect because the local variable test is used
without being initialized. Option D is also incorrect. The parentheses are required on the
left-hand side of the lambda expression when there is more than one value or a data type is
specified. Option B is the correct answer and the only valid lambda expression.
|
6. B. An enum cannot be marked abstract, nor can any of its values, but its methods can be
marked abstract, making Option B the correct answer. Note that if an enum contains an
abstract method, then every enum value must include an override of this abstract method.
|
7. B. The code compiles without issue, so Option D is incorrect. The first print() statement
refers to value in the Deeper class, so 5 is printed. The second and third print() statements
actually refer to the same value in the Deep class, so 2 is printed twice. The prefix
Matrix. is unnecessary in the first of the two print() statements and does not change the
result. For these reasons, Option B is the correct answer.
|
8. D. A local inner class can access final or effectively final local variables, making Option
D the correct answer. The second statement is invalid because access modifiers like private
cannot be applied to local variables.
|
9. C. The type of the variable in the switch statement is the enum Currency, but the case statements
use int values. While the enum class hierarchy does support an ordinal() method,
which returns an int value, the enum values cannot be compared directly with int values. For
this reason, the code does not compile, since the case statement values are not compatible with
the variable type in the switch statement, making Option C the correct answer.
|
10. C. A local variable is effectively final when it’s primitive value or object reference does not
change after it is initialized, making Option C the correct answer. Option D is incorrect. Any
change to the variable after it is initialized disqualifies it for being considered effectively final.
|
11. D. Both the Drive and Hover interfaces define a default method getSpeed() with the
same signature. In fact, both getSpeed() methods return the same value of 5. The class
Car implements both interfaces, which means it inherits both default methods. Since the
compiler does not know which one to choose, the code does not compile, and the answer is
Option D. Note that if the Car class had overridden the getSpeed() method, then the code
would have compiled without issue and printed 10 at runtime. In particular, the local class
Racecar defined in the main() method compiles without issue, making Option C incorrect.
|
12. B. An interface can be extended by another interface and a class can be extended by another
class, making the second part of Options A, C, and D incorrect. Option B is correct because
an enum cannot be extended. Note that Option C is also incorrect for this reason.
|
13. B. If the program is called with a single input WEST, then WEST would be printed at runtime.
If the program is called with no input, then the compass array would be of size zero, and an
ArrayIndexOutOfBoundsException would be thrown at runtime. Finally, if the program
is called with a string that does not match one of the values in Direction, then an
IllegalArgumentException would be thrown at runtime. The only result not possible is
south, since the enum value is in uppercase, making Option B the correct answer.
|
14. B. Enumerated types support creating a set of reusable values whose values are fixed and
consistent across the entire application. For these reason, Options A, C, and D are incorrect.
Option B is the false statement because enum values are defined at compile time and
cannot be changed or added at runtime.
|
15. D. The program contains three compilation problems. First off, the enum Color extends
the enum Light, but enums cannot extend other enums so the definition is invalid. Second,
the enum value list must end with a semicolon (;) if the enum definition contains anything
other than the enum values. Since it includes a constructor, a semicolon (;) is required after
GREEN. Finally, enum constructors must be private, meaning the protected constructor
for Color does not compile. For these three reasons, Option D is the correct answer.
|
16. D. Both abstract classes and interfaces can include static methods, so Options A and
C are incorrect. A static nested class can include static methods, but it is the only type
of inner class in which this is allowed. Local inner classes, anonymous inner classes, and
member inner classes do not support static methods. For these reasons, Option D is correct,
and Option B is incorrect.
|
17. B. A functional interface must contain exactly one abstract method. The Bend interface
contains two abstract methods, pump() and bend(), since it extends Pump and inherits
pump(). For this reason, the Bend method is not a valid functional interface and therefore
cannot be used as a lambda expression, making Option B the correct answer. The rest
of the code compiles without issue. Note that the usage of an instance variable to call a
static method, r.apply() in the main() method, is permitted but discouraged.
|
18. C. Applying the @Override annotation is optional and not required to override a method or
implement an interface method, making Options A and B incorrect. While partially helpful as
a form of documentation, it is not the best reason to apply the annotation, making Option D
incorrect. The best reason is that the compiler will actually fail to compile if the method that
the @Override annotation is being applied to is not actually overriding an inherited method.
This behavior helps correct typos or changes in superclasses or interfaces that could break the
class or lead to unexpected behavior. For this reason, Option C is the best choice.
|
19. C. The Bottle class includes a static nested class Ship that must be instantiated in a static
manner. Line w2 uses an instance of Bottle to instantiate the Ship. While this would be
allowed if Ship was a member inner class, since it is a static nested class, line w2 does not
compile, and Option C is the correct answer. Note that if Ship was changed to be a member
inner class, the code would still not compile since a member inner class cannot include
static members and enums are inherently static. Therefore, the correct change would be to
fix the declaration on line w2.
|
20. A. Option A is the invalid lambda expression because the type is specified for the variable
j, but not the variable k. The rest of the options are valid lambda expressions. To be a valid
lambda expression, the type must be specified for all of the variables, as in Option C, or
none of them, as in Options B and D.
|
21. D. This application declares an anonymous inner class that implements the Edible interface.
Interface methods are public, whereas the override in the anonymous inner class uses
package-private access. Since this reduces the visibility of the method, the declaration of
eat() on line 8 does not compile. Next, the declaration of the apple object must end with
a semicolon (;) on line 11, and it does not. For these two reasons, the code does not compile,
and Option D is the correct answer. Note that if these two issues were corrected, with
the public modifier and missing semi-colon (;), then the correct answer would be Option
A because the code does not actually call the eat() method; it just declares it.
|
22. A. The code compiles without issue and prints 15, making Option A correct and Option D
incorrect. The main() method defines a local class Oak that correctly extends Tree, a static
nested class, making Option B incorrect. Finally, the method getWater() is permitted to
read the variable water, defined in the main() method, since it is effectively final, having a
value of 15 when it is defined. For this reason, Option C is also incorrect.
|
23. C. Interfaces allow Java to support multiple inheritance because a class may implement any
number of interfaces. On the other hand, an anonymous inner class may implement at most
one interface, since it does not have a class definition to implement any others. For these
reasons, Option C is the correct answer.
|
24. A. The code does not compile because the declaration of isDanger() in the class
SeriousDanger is an invalid method override. An overridden method may not throw a
broader checked exception than it inherits. Since Exception is a superclass of Problem,
thrown by the inherited method in the Danger class, the override of this checked exception
is invalid. For this reason, line m1 does not compile, and Option A is the correct answer.
The rest of the lines of code compile without issue.
|
25. B. Options A, C, and D are true statements about interfaces and abstract classes. Option B
is the correct answer because neither abstract classes nor interfaces can be marked final.
For Option D, methods and variables can both be marked private in abstract classes in
some cases. The “some cases” refers to the fact that the private modifier cannot be applied
to abstract methods, since a method cannot be marked both final and abstract. Since
abstract classes can contain concrete methods, which can take the private access modifier,
the statement is true.
|
26. A. The code compiles without issue, so Option C is incorrect. Enum ordinal values are
indexed starting with zero, so 0 is printed first. The second line compiles and runs without
issue, with flurry being converted to FLURRY, using the toUpperCase() method. Since
there is a matching enum named FLURRY, that value is printed next. For these reasons,
Option A is the correct answer.
|
27. D. Java was updated to include default interface methods in order to support backward
compatibility of interfaces. By adding a default method to an existing interface, we can
create a new version of the interface, which can be used without breaking the functionality
of existing classes that implement an older version of the interface. For this reason, Option
D is the correct answer. Options A and C are not applicable to default interface methods,
whereas Option B could be achieved by using static interface methods.
|
28. C. The Penguin class includes a member inner class Chick. Member inner classes cannot
include static methods or variables. Since the variable volume is marked static, the member
inner class Chick does not compile, making Option C the correct answer. Note that the variable
volume referenced in the chick() method is one defined in the Penguin outer class. If the
static modifier was removed from the volume variable in the Chick class, then the rest of the
code would compile and run without issue, printing Honk(1)! at runtime.
|
29. D. Member inner classes require an instance of the surrounding class to be instantiated.
Option A is incorrect since we are told that the instantiation request is from a static
method. Note that this call would be valid from a non-static method in Dinosaur. Option
B is incorrect because it lacks the new keyword. Option C is incorrect. Pterodactyl is a
member inner class, not a static nested class. Option D is correct and uses the instance dino
to create a new Pterodactyl object.
|
30. C. First off, both CanBurrow and HasHardShell are functional interfaces since
they contain exactly one abstract method, although only the latter uses the optional
@FunctionalInterface annotation. The declarations of these two interfaces, along with
the abstract class Tortoise, compile without issue, making Options A and B incorrect.
The code does not compile, though, so Option D is incorrect. The class DesertTortoise
inherits two abstract methods, one from the interface CanBurrow and the other from the
abstract parent class Tortoise. Since the class only implements one of them and the class
is concrete, the class declaration of DesertTortoise fails to compile on line k3, making
Option C the correct answer.
|
31. B. First off, the two interface definitions contain identical methods, with the public
modifiers assumed in all interfaces methods. For the first statement, the write()
method is marked default in both interfaces, which means a class can only implement
both interfaces if the class overrides the default method with its own implementation
of the method. Since the Twins method does override write(), the method compiles
without issue, making the first statement incorrect. Next, the publish() method is
marked static in both interfaces and the Twins class. While having a static method
in all three is allowed, marking a static method with the @Override annotation is not
because only member methods may be overridden. For this reason, the second statement
is correct. Finally, the think() method is assumed to be abstract in both interfaces
since it doesn’t have a static or default modifier and does not define a body. The
think() method is then correctly overridden with a concrete implementation in the
Twins class, making the third statement incorrect. Since only the second statement was
true, Option B is the correct answer.
|
32. D. An enum and static inner class can define static methods, making Option D the correct
answer. Options A, B, and C are incorrect because the other types of inner classes cannot
define static methods. Note that interfaces and abstract classes can define static methods.
|
33. C. First off, Option A does not compile since the variables p and q are reversed, making the
return type of the method and usage of operators invalid. The first argument p is a String
and q is an int, but the lambda expression reverses them, and the code does not compile.
Option B also does not compile. The variable d is declared twice, first in the lambda
argument list and then in the body of the lambda expression. The second declaration in
the body of the lambda expression causes the compiler to generate a duplicate local variable
message. Note that other than it being used twice, the expression is valid; the ternary
operator is functionally equivalent to the learn() method in the BiologyMaterial class.
Option C is the correct answer since it compiles and handles the input in the same way as
the learn() method in the BiologyMaterial class.
|
34. C. The code does not compile since it contains two compilation errors, making Option
A incorrect. First, the enum list is not terminated with a semicolon (;). A semicolon (;)
is required anytime an enum includes anything beyond just the list of values, such as a
constructor or method. Second, the access modifier of TRUE’s implementation of getNick-
Name() is package-private, but the abstract method signature has a protected modifier.
Since package-private is a more restrictive access than protected, the override is invalid
and the code does not compile. For these two reasons, Option C is the correct answer. Note
that the @Override annotation is optional in the method signature, therefore FALSE’s version
of getNickName() compiles without issue. Also, note that the Proposition constructor
does not include a private access modifier, but the constructor compiles without issue.
Enum constructors are assumed to be private if no access modifier is specified, unlike
regular classes where package-private is assumed if no access modifier is specified.
|
35. A. The code compiles and runs without issue, printing 8 at runtime, making Option A correct
and Option D incorrect. The AddNumbers interface is a valid functional interface. While
it includes both static and default methods, it only includes one abstract method, the
precise requirement for it to be considered a functional interface, making Option B incorrect.
Finally, Option C is incorrect because the lambda expression is valid and used correctly.
|
36. A. While this code included a large number of final modifiers, none of them prevent
the code from compiling when a valid expression is placed in the blank, making Option
D incorrect. Option B is incorrect since it returns the size variable defined in the Insert
member inner class, not the Bottle class, printing 25 at runtime. Option C is incorrect
because the expression is invalid and does not compile when inserted into the blank.
Finally, Option A is the correct answer because it compiles, properly references the variable
size in the Bottle class, and prints 14 at runtime.
|
37. C. The main() method attempts to define an anonymous inner class instance but fails to
provide the class or interface name, or use the new keyword. The right-hand side of the
assignment to the seaTurtle variable should start with new CanSwim(). For this reason,
Option C is the correct answer. If the code was corrected with the proper declaration, it
would output 7, and Option B would be the correct answer.
|
38. D. The code does not compile, so Options A and B are incorrect. The declarations of the
local inner classes Robot and Transformer compile without issue. The anonymous inner
class that extends Transformer compiles without issue, since the public variable name is
inherited, making Option C incorrect. The only compilation problem in this class is the
last line of the main() method. The variable name is defined inside the local inner class and
not accessible outside class declaration without a reference to the local inner class. Due to
scope, this last line of the main() method does not compile, making Option D the correct
answer. Note that the first part of the print() statement in the main() method, if the code
compiled, would print GiantRobot.
|
39. B. The Dancer class compiles without issue, making Option A incorrect. The SwingDancer
class, though, does not compile because getPartner() is an invalid method override. In particular,
Leader and Follower are not covariant since Follower is not a subclass of Leader.
Therefore, line u2 does not compile, making Option B correct and Option D incorrect. Note
that the abstract method getPartner(int) is not implemented in SwingDancer, but this is
valid because SwingDancer is an abstract class and is not required to implement all of the
inherited abstract methods.
|
40. C. The code does not compile, so Options A and B are incorrect. The problem here is that
the DEFAULT_VALUE is an instance variable, not a static variable; therefore, the static
nested class GetSet cannot access it without a reference to the class. For this reason, the
declaration of the static nested class GetSet does not compile, and Option C is the correct
answer. The rest of the code compiles without issue. Note that if the DEFAULT_VALUE
variable was modified to be static, then the code would compile without issue, and
Option B would be the correct answer.
|
1. C. When declaring a class that uses generics, you must specify a name for the formal type
parameter. Java uses the standard rules for naming a variable or class. A question mark is
not allowed in a variable name, making I incorrect. While it is common practice to use a
single uppercase letter for the type parameter, this is not required. It certainly isn’t a good
idea to use existing class names like the News class being declared here or the Object class
built into java. However, this is allowed, and Option C is correct.
|
2. B. Option A is incorrect because the filter() method is available on Stream, but not
List. Option C is incorrect because the replace() method is available on List, but not
Stream. Option D is tricky because there is a sort() method on List and a sorted()
method on Stream. These are different method names though, so Option D is incorrect.
Option B is the answer because both interfaces have a forEach() method.
|
3. A. Notice how there is unnecessary information in this description. The fact that patrons
select books by name is irrelevant. The checkout line is a perfect example of a doubleended
queue. We need easy access to one end of the queue for patrons to add themselves
to the queue. We also need easy access to the other end of the queue for patrons to get off
the queue when it is their turn. The book lookup by ISBN is a lookup by key. We need
a map for this. A HashMap is probably better here, but it isn’t a choice. So the answer is
Option A, which does include both a double-ended queue and a map.
|
4. B. Java talks about the collections framework, but the Map interface does not actually
implement the Collection interface. TreeMap has different methods than ArrayDeque and
TreeSet. It cannot fill in the blank, so Option B is correct.
|
5. B. Options C and D are incorrect because the method signature is incorrect. Unlike the
equals() method, the method in Comparator takes the type being compared as the parameters
when using generics. Option A is a valid Comparator. However, it sorts in ascending
order by length. Option B is correct. If s1 is three characters and s2 is one character, it
returns -2. The negative value says that s1 should sort first, which is correct, because we
want the longest String first.
|
6. D. TreeMap and TreeSet keep track of sort order when you insert elements. TreeMap
sorts the keys and TreeSet sorts the objects in the set. This makes Option D correct. Note
that you have the option of having JellyBean implement Comparable, or you can pass a
Comparator to the constructor of TreeMap or TreeSet.
|
7. C. Option A is incorrect because a pipeline still runs if the source doesn’t generate any items
and the rest of the pipeline is correct. Granted some of the operations have nothing to do, but
control still passes to the terminal operation. Option B is incorrect because intermediate operations
are optional. Option C is the answer. The terminal operation triggers the pipeline to run.
|
8. B. The Iterator interface uses the hasNext() and next() methods to iterate. Since there is
not a hasMore() method, it should be changed to hasNext(), making Option B the answer.
With respect to Option A, the missing generic type gives a warning, but the code still runs. For
Option C, iterators can run as many times as you want, as can the forEach() method on list.
|
9. A. First the code creates an ArrayList of three elements. Then the list is transformed into
a TreeSet. Since sets are not allowed to have duplicates, the set only has two elements.
Remember that a TreeSet is sorted, which means that the first element in the TreeSet is 3.
Therefore, Option A is correct.
|
10. C. The word reduction is used with streams for a terminal operation, so Options A and B
are incorrect. Option D describes a valid terminal operation like anyMatch(), but is not a
reduction. Option C is correct because a reduction has to look at each element in the stream
in order to determine the result.
|
11. A. The offer() method adds an element to the back of the queue. After line 7 completes,
the queue contains 18 and 5 in that order. The push() method adds an element to the front
of the queue. How rude! The element 13 pushes past everyone on the line. After line 8 completes,
the queue now contains 13, 18, and 5, in that order. Then we get the first two
elements from the front, which are 13 and 18, making Option A correct.
|
12. D. The Magazine class doesn’t implement Comparable<Magazine>. It happens to
implement the compareTo() method properly, but it is missing actually writing
implements Comparable. Since TreeSet doesn’t look to see if the object can be compared
until runtime, this code throws a ClassCastException when TreeSet calls add(), so
Option D is correct.
|
13. C. Line 8 does not compile. String::new is a constructor reference. A constructor or
method reference is equivalent to a lambda. It participates in deferred execution. When it is
executed later, it returns a String. It does not return a String on line 8. It actually returns
a Supplier<String>, which cannot be stored in list. Since the code does not compile,
Option C is correct.
|
14. B. This code adds two elements to a list. It then gets a stream and iterates through the list,
printing two lines. The last line does the same thing again. Since a fresh stream is created,
we are allowed to iterate through it, and Option B is correct.
|
15. D. The Comic interface declares a formal type parameter. This means that a class implementing
it needs to specify this type. The code on line 21 compiles because the lambda
reference supplies the necessary context making Option A incorrect. Option B declares a
generic class. While this doesn’t tell us the type is Snoopy, it punts the problem to the
caller of the class. The declaration of c2 on line 22 compiles because it supplies the type,
making Option B incorrect. The code on line 23 compiles because the SnoopyClass itself
supplies the type making Option C incorrect. Option D has a problem. SnoopyClass and
SnoopyComic appear similar. However, SnoopyComic refers to C. This type parameter
exists in the interface. It isn’t available in the class because the class has said it is using
Snoopy as the type. Since the SnoopyComic class itself doesn’t compile, the line with c4
can’t instantiate it, and Option D is the answer.
|
16. A. In streams, the filter() method filters out any values that do not match. This means the
only value to make it to the terminal operator count() is Chicago, and Option A is correct.
|
17. C. When implementing Comparable, you implement the compareTo() method. Since this is
an instance method, it already has a reference to itself and only needs the item it is comparing.
Only one parameter is specified, and Option C is correct. By contrast, the Comparator
interface uses the compare() method and the method takes two parameters.
|
18. C. The source and any intermediate operations are chained and eventually passed to the
terminal operation. The terminal operation is where a non-stream result is generated, making
Option C correct.
|
19. A. A constructor reference uses the new keyword where a method name would normally go
in a method reference. It can implicitly take zero or one parameters just like a method reference.
In this case, we have one parameter, which gets passed to the constructor. Option A is
correct.
|
20. D. A custom sort order is specified using a Comparator to sort in descending order. However,
this Comparator is not passed when searching. When a different sort order is used for
searching and sorting, the result is undefined. Therefore, Option D is correct.
|
21. D. Java only allows you to operate on a stream once. The final line of code throws an
IllegalStateException because the stream has already been used up. Option D is the
correct answer.
|
22. D. The Wash class takes a formal type parameter named T. Option C shows the best way to
call it. This option declares a generic reference type that specifies the type is String. It also
uses the diamond syntax to avoid redundantly specifying the type on the right-hand side of
the assignment. Options A and B show that you can omit the generic type in the reference
and still have the code compile. You do get a compiler warning scolding you for having a
raw type. But compiler warnings do not prevent compilation. With the raw type, the compiler
treats T as if it is of type Object. That is OK in this example because the only method
we call is toString() implicitly when printing the value. Since toString() is defined on
the Object class, we are safe, and Options A and B work. Since all three can fill in the
blank, Option D is the answer.
|
23. D. The missing generic type gives a warning, but the code still runs, so Option A is incorrect.
The Iterator interface uses hasNext() and next() methods to iterate, so Option
B is incorrect. Option C applies to calling the same stream twice. One of our calls is to an
Iterator anyway, so Option C is incorrect. This code is in fact correct, making the answer
Option D.
|
24. B. This is a static method reference. It uses :: to separate the class name and method
name. Option B is correct.
|
25. B. A source and the terminal operation are required parts of a stream pipeline and must
occur exactly once. The intermediate operation is optional. It can appear zero or more
times. Since more than once falls within zero or more, Option B is correct.
|
26. B. ArrayList allows null elements, making Option B correct. TreeSet does not allow
nulls because they need to compare the values. ArrayDeque uses null for a special meaning,
so it doesn’t allow it in the data structure either.
|
27. D. Option A is the only one of the three options to compile. However, it results in no lines
being output since none of the three strings are empty. Options B and C do not even compile
because a method reference cannot have an operator next to it. Therefore, Option D is correct.
|
28. A. Unfortunately you do have to memorize two facts about sort order. First, numbers sort
before letters. Second, uppercase sorts before lowercase. Since TreeMap orders by key, the
first key is 3 and the last is three, making Option A correct.
|
29. C. The ? is an unbounded wildcard. It is used in variable references but is not allowed in
declarations. In a static method, the type parameter specified inside the <> is used in the
rest of the variable declaration. Since it needs an actual name, Options A and B are incorrect.
We need to specify a type constraint so we can call the add() method. Regardless of
whether the type is a class or interface, Java uses the extends keyword for generics. Therefore,
Option D is incorrect, and Option C is the answer.
|
30. B. On a stream, the filter() method only keeps values matching the lambda. The
removeIf() does the reverse on a Collection and keeps the elements that do not match.
In this case, that is Austin and Boston so Option B is correct.
|
31. D. The code correctly creates an ArrayDeque with three elements. The stream pipeline does
compile. However, there is no terminal operation, which means the stream is never evaluated
and the output is something like java.util.stream.ReferencePipeline$2@404b9385.
This is definitely not one of the listed choices, so Option D is correct.
|
32. C. The forEach() method that takes one parameter is defined on the Collection interface.
However, a map is not a Collection. There is a version of forEach() defined on
the Map interface, but it uses two parameters. Since two parameters can’t be used with a
method reference, Option C is the answer.
|
33. C. This code is almost correct. Calling two different streams is allowed. The code attempts
to use a method reference when calling the forEach() method. However, it does not use
the right syntax for a method reference. A double colon needs to be used. The code would
need to be changed to System.out::println to work and print two lines for each call.
Since it does not compile, Option C is correct.
|
34. B. This code shows a proper implementation of Comparable. It has the correct method
signature. It compares the magazine names in alphabetical order. Remember that uppercase
letters sort before lowercase letters. Since Newsweek is uppercase, Option B is correct.
|
35. C. The filter() method requires a boolean returned from the lambda or method reference.
The getColor() method returns a String and is not compatible. This causes the
code to not compile and Option C to be correct.
|
36. A. Option A is correct as the source and terminal operation are mandatory parts of a
stream pipeline. Option B is incorrect because a Stream must return non-primitives.
Specialized interfaces like IntStream are needed to return primitives. Option C is incorrect
because Stream has methods such as of() and iterate() that return a Stream. Option D
is incorrect because infinite streams are possible.
|
37. B. The stream pipeline is correct and filters all values out that are 10 characters or smaller.
Only San Francisco is long enough, so c is 1. The stream() call creates a new object, so
stream operations do not affect the original list. Since the original list is still 3 elements,
Option B is correct.
|
38. B. Options A and C are incorrect because a generic type cannot be assigned to another
direct type unless you are using upper or lower bounds in that statement. Now, we just
have to decide whether a lower or upper bound is correct for the T formal type parameter
in Wash. The clue is that the method calls size(). This method is available on Collection
and all classes that extend/implement it. Therefore, Option B is correct.
|
39. C. A Comparator takes two parameters, so Options A and B are incorrect. Option D
doesn’t compile. When using brackets, a return keyword and semicolon are required.
Option C is a correct implementation.
|
40. B. Option D is incorrect because there is a charAt() instance method. While Option C is
correct that the method takes in an int parameter, autoboxing would take care of conversion
for us if there were no other problems. So Option C is not the answer. Option A is not
true because there are constructor and instance method references. Option B is the answer.
With method references, only one item can be supplied at runtime. Here, we need either a
String instance with no parameters in the method or a static method with a single parameter.
The charAt() method is an instance method with a single parameter so does not meet
this requirement.
|
1. C. The Supplier functional interface does not take any inputs, while the Consumer functional
interface does not return any data. This behavior extends to the primitive versions of
the functional interfaces, making Option C the correct answer. Option A is incorrect because
IntConsumer takes a value, while LongSupplier returns a value. Options B and D are incorrect
because Function and UnaryOperator both take an input and produce a value.
|
2. A. The LongSupplier interface does not take any input, making Option D incorrect. It
also uses the method name getAsLong(). The rest of the functional interfaces all take a
long value but vary on the name of the abstract method they use. LongFunction contains
apply() and LongPredicate contains test(), making Options B and C, respectively,
incorrect. That leaves us with LongConsumer, which contains accept(), making Option A
the correct answer.
|
3. A. The code compiles without issue, so Options C and D are incorrect. The value for distance
is 2, which based on the lambda for the Predicate will result in a true expression,
and Saved will be printed, making Option A correct.
|
4. C. Both are functional interfaces in the java.util.function package, making Option A
true. The major difference between the two is that Supplier<Double> takes the generic
type Double, while the other does not take any generic type and instead uses the primitive
double. For this reason, Options B and D are true statements. For Supplier<Double>
in Option B, remember that the returned double value can be implicitly cast to Double.
Option C is the correct answer. Lambdas for Supplier<Double> can return a null value
since Double is an object type, while lambdas for DoubleSupplier cannot; they can only
return primitive double values.
|
5. B. The lambda (s,p) -> s+p takes two arguments and returns a value. For this reason,
Option A is incorrect because BiConsumer does not return any values. Option D is also
incorrect, since Function only takes one argument and returns a value. This leaves us with
Options B and C, which both use BiFunction, which takes two generic arguments and
returns a generic value. Option C is incorrect because the datatype of the unboxed sum s+q
is int and int cannot be autoboxed or implicitly cast to Double. Option B is correct. The
sum s+p is of type double, and double can be autoboxed to Double.
|
6. C. To begin with, ToDoubleBiFunction<T,U> takes two generic inputs and returns a
double value. Option A is compatible because it takes an Integer and Double and returns
a Double value that can be implicitly unboxed to double. Option B is compatible because
long can be implicitly cast to double. While we don’t know the data types for the input
arguments, we know that some values, such as using Integer for both, will work. Option
C cannot be assigned and is the correct answer because the variable v is of type Object and
Object does not have a length() method. Finally, Option D is compatible. The variable y
could be declared double in the generic argument to the functional interface, making y/z a
double return value.
|
7. C. The BiPredicate interface takes two generic arguments and returns a boolean value.
Next, DoubleUnaryOperator takes a double argument and returns a double value. Last,
ToLongFunction takes a generic argument and returns a long value. That leaves Option
C, which is the correct answer. While there is an ObjDoubleConsumer functional interface,
which takes a generic argument and a double value and does not return any data, there is
no such thing as ObjectDoubleConsumer. Remember that Object is abbreviated to Obj in
all functional interfaces in java.util.function.
|
8. C. The code does not compile, so Options A and D are incorrect. The IntUnaryOperator
functional interface is not generic, so the argument IntUnaryOperator<Integer> in the
takeTicket() does not compile, making Option C the correct answer. The lambda expression
compiles without issue, making Option B incorrect. If the generic argument <Integer>
was dropped from the argument declaration, the class would compile without issue and
output 51 at runtime, making Option A the correct answer.
|
9. A. Option A is the correct answer because BiPredicate takes two generic types and
returns a primitive boolean value. Option B is incorrect, since CharSupplier does not
exist in java.util.function. Option C is also incorrect, since LongFunction takes a
primitive long value and returns a generic type. Remember, Java only includes primitive
functional interfaces that operate on double, int, or long. Finally, Option D is incorrect.
UnaryOperator takes a generic type and returns a generic value.
|
10. D. First off, the forEach() method requires a Consumer instance. Option C can be immediately
discarded because Supplier<Double> does not inherit Consumer. For this same reason,
Option B is also incorrect. DoubleConsumer does not inherit from Consumer. In this
manner, primitive functional interfaces cannot be used in the forEach() method. Option
A seems correct, since forEach() does take a Consumer instance, but it is missing a generic
argument. Without the generic argument, the lambda expression does not compile because
the expression p<5 cannot be applied to an Object. The correct functional interface is
Consumer<Double>, and since that is not available, Option D is the correct answer.
|
11. C. BiFunction<Double,Double,Double> and BinaryOperator<Double> both take
two Double input arguments and return a Double value, making them equivalent to one
another. On the other hand, DoubleFunction<Double> takes a single double value and
returns a Double value. For this reason, it is different from the other two, making Option C
correct and Option D incorrect.
|
12. B. BinaryOperator<Long> takes two Long arguments and returns a Long value. For this
reason, Option A, which takes one argument, and Option D, which takes two Integer
values that do not inherit from Long, are both incorrect. Option C is incorrect because the
local variable c is re-declared inside the lambda expression, causing the expression to fail
to compile. The correct answer is Option B because intValue() can be called on a Long
object. The result can then be cast to long, which is autoboxed to Long.
|
13. C. The program does not compile, so Option A is incorrect. The Supplier functional
interface normally takes a generic argument, although generic types are not strictly required
since they are removed by the compiler. Therefore, line d1 compiles while triggering a compiler
warning, and Options B and D are incorrect. On the other hand, line d2 does cause a
compiler error, because the lambda expression does not return a value. Therefore, it is not
compatible with Supplier, making Option C the correct answer.
|
14. A. The input type of a unary function must be compatible with the return type. By compatible,
we mean identical or able to be implicitly cast. For this reason, Option A is the correct
answer. Option B is incorrect since all of the UnaryOperator functional interfaces, generic
or primitive, take exactly one value. Option C is incorrect because the primitive functional
interfaces do not take a generic argument. Finally, Option D is incorrect. For example, the
generic UnaryOperator<T> returns an Object that matches the generic type.
|
15. C. Remember that all Supplier interfaces take zero parameters. For this reason, the third
value in the table is 0, making Options A and B incorrect. Next, DoubleConsumer and
IntFunction each take one value, double and int, respectively. On the other hand,
ObjDoubleConsumer takes two values, a generic value and a double, and returns void. For
this reason, Option C is correct, and Option D is incorrect.
|
16. D. All Consumer functional interfaces have a void return type. For this reason, the
first and last values in the table are both void, making Options A and B incorrect.
IntFunction takes an int and returns a generic value, while LongSupplier does not
take any values and returns a long value. For this reason, Option C is incorrect, and
Option D is correct.
|
17. B. The removeIf() method requires a Predicate since it operates on a boolean result,
making Option A incorrect. The forEach() method takes a Consumer and does not return
any data, making Option B correct, and Options C and D incorrect.
|
18. C. The code does not compile, so Option A is incorrect. The lambda expression
compiles without issue, making Option B incorrect. The task variable is of type
UnaryOperator<Doll>, with the abstract method apply(). There is no accept()
method defined on that interface, therefore the code does not compile, and Option C
is the correct answer. If the code was corrected to use the apply() method, the rest of
it would compile without issue. At runtime, it would then produce an infinite loop. On
each iteration of the loop, a new Doll instance would be created with 5, since the postdecrement
(--) operator returns the original value of the variable, and that would make
Option D the correct answer.
|
19. C. To begin with, Consumer uses accept(), making Option A incorrect. Next, Function
and UnaryOperator use apply(), making Options B and D, respectively, incorrect. Finally,
Supplier uses get(), making Option C the correct answer.
|
20. D. First off, Options A and B are incorrect because the second functions for both
return a double or Double value, respectively. Neither of these values can be sent to a
UnaryOperator<Integer> without an explicit cast. Next, Option C is incorrect. The first
functional interface Function<Double,Integer> takes only one input, but the diagram
shows two inputs for the first functional interface. That leaves us with Option D. The
first functional interface BiFunction<Integer,Double,Integer> takes an int, which
can be implicitly autoboxed to Integer, and a Double and returns an Integer. The next
functional interface, BinaryOperator<Integer>, takes two Integer values and returns
an Integer value. Finally, this Integer value can be implicitly unboxed and sent to
IntUnaryOperator, returning an int. Since these behaviors match our diagram, Option D
is the correct answer.
|
21. D. Options A, B, and C are true statements about functional interfaces. A lambda may
be compatible with multiple functional interfaces, but it must be assigned to a functional
interface when it is declared or passed as a method argument. Also, a method can be created
with the return type that matches a functional interface, allowing a lambda expression
to be returned. Option D is the correct answer. Deferred execution means the lambda
expression is not evaluated until runtime, but it is compiled. Compiler errors in the lambda
expression will prevent the code from compiling.
|
22. B. Option A is incorrect because the String "3" is not compatible with the return type
int required for IntSupplier. Option B is the correct answer. Although this will result in
a divide by zero issue at runtime, the lambda is valid and compatible with IntSupplier.
Option C is incorrect because the lambda expression is invalid. The return statement is only
allowed inside a set of brackets {}. Finally, Option D is incorrect. The method reference is
used for Supplier, not Consumer, since it takes a value and does not return anything.
|
23. C. The lambda expression is invalid because the input argument is of type Boss, and Boss
does not define an equalsIgnoreCase() method, making Option C the correct answer. If
the lambda was corrected to use s.getName() instead of s, the code would compile and
run without issue, printing [JENNY, GRACE] at runtime and making Option A the correct
answer.
|
24. D. First of all, Consumer<Object> takes a single Object argument and does not return
any data. The classes ArrayList and String do not contain constructors that take an
Object, so neither of the first two statements are correct. The third statement does support
an Object variable, since the System.out.println(Object) method exists. For these reasons,
Option D is the correct answer.
|
25. B. The java.util.function package does not include any functional interfaces that
operate on the primitive float, making Option A incorrect. Remember, Java only includes
primitive functional interfaces that operate on double, int, or long. Option B is correct
because it is a valid functional interface. Option C is incorrect because there is no
UnaryIntOperator functional interface. Note that there is one called IntUnaryOperator.
Option D is incorrect. The java.util.function package does not include any tri- operators,
although many are easy to write.
|
26. D. A lambda expression can match multiple functional interfaces. It matches
DoubleUnaryOperator, which takes a double value and returns a double value. Note that
the data type of s+1 is double because one of the operands, in this case s, is double. It also
matches Function<String,String> since the (+) operator can be used for String concatenation.
Finally, it matches IntToLongFunction since the int value s+1can be implicitly
cast to long. On the other hand, the lambda expression is not compatible with UnaryOperator
without a generic type. When UnaryOperator is used without a generic argument, the
type is assumed to be Object. Since the (+) operator is not defined on Object, the code
does not compile due to the lambda expression body, making Option D the correct answer.
Note that if the lambda expression did not rely on the (+) operator, such as s -> s, then
UnaryOperator would be allowed by the compiler, even without a generic type.
|
27. B. The BiFunction interface takes two different generic values and returns a generic value,
taking a total of three generic arguments. Next, ToDoubleFunction takes exactly one
generic value and returns a double value, requiring one generic argument. The
ToIntBiFunction interface takes two generic values and returns an int value, for a total
of two generic arguments. For these reasons, Options A, C, and D are incorrect. The
correct answer is Option B. DoubleFunction takes a double value and returns a generic
result, taking exactly one generic argument, not two.
|
28. D. While lambda expressions can use primitive types as arguments, the functional interface
in this class uses the wrapper classes, which are not compatible. For this reason, Option A is
incorrect. Option B is also incorrect, since the number of arguments and return type does not
match the functional interface. Furthermore, the method reference System.out::print on
the right-hand side of the lambda expression is invalid here, since it returns a method reference,
not a double value. Option C is incorrect because 2*w is of type double, which cannot
be returned as an Integer without an explicit cast. Option D is the correct answer. It takes
exactly two arguments because the return value int can be implicitly autoboxed to Integer.
|
29. A. BooleanSupplier is the only functional interface that does not involve double, int,
or long, making Option A the correct answer. The rest of the functional interfaces are not
found in java.util.function. Java does not have built-in support for primitive functional
interfaces that include char, float, or short.
|
30. D. The code does not compile because the lambda expression p -> p*100 is not compatible
with the DoubleToIntFunction functional interface. The input to the functional interface
is double, meaning p*100 is also double. The functional interface requires a return
value of int, and since double cannot be implicitly cast to int, the code does not compile,
making Option D the correct answer. If the correct cast was applied to make (p*100) an
int, then the rest of the class would compile and 250 would be printed at runtime, making
Option B correct.
|
31. B. The ToDoubleFunction interface takes a generic value, not a double value, making
Option D incorrect. It also uses the method name accept(). The rest of the functional
interfaces all take a double value. DoubleConsumer contains the accept() method, making
Option A incorrect. DoublePredicate contains the test() method, making Option B
the correct answer. Finally, DoubleUnaryOperator contains the applyAsDouble() method,
making Option C incorrect.
|
32. D. To start with, line 5 does not compile because Function takes two generic arguments,
not one. Second, the assignment statement on line 7 does not end with a semicolon (;), so
it also does not compile. Finally, the forEach() method on line 10 requires a Consumer,
not a Function, so this line does not compile. For these three reasons, Option D is the
correct answer.
|
33. D. The DoubleToLongFunction interface takes a double argument and returns a long
value. Option A is compatible since the int value 1 can be implicitly cast to long, and 2L
is already a long. Option B is also compatible, since the double value 10.0*e is explicitly
cast to int then implicitly cast to long. Next, Option C is compatible because an explicit
cast of the double to a long value is used. Option D cannot be assigned and is the correct
answer. Although the Double class does have a longValue() method, the left-hand side
of the lambda expression must use the primitive double, not the wrapper Double. This
lambda expression violates the signature of the functional interface, since it allows Double
values to be sent to the interface, including those that could be null.
|
34. C. The DoublePredicate interface takes a double value and returns a boolean value.
LongUnaryOperator takes a long value and returns a long value. ToIntBiFunction takes
two generic values and returns an int value. The only choice that is not an existing functional
interface is ShortSupplier. Recall that Java only includes primitive functional interfaces
that operate on double, int, or long. For this reason, Option C is the correct answer.
|
35. A. The method reference System.out::println takes a single input and does not return
any data. Consumer<Sheep> is compatible with this behavior, making Option A the correct
answer and Option D incorrect. Option B is incorrect because void cannot be used as
a generic argument. Option C is incorrect since System.out::println() does not return
any data and UnaryOperator requires a return value.
|
36. C. The code does not compile, making Options A and B incorrect. The local variable
MAX_LENGTH is neither final nor effectively final, meaning it cannot be used inside the lambda
expression. The MAX_LENGTH variable starts off with an initial value of 2, but then is modified
with the increment assignment (+=) operator to a value of 5, disqualifying its ability to be considered
effectively final by the compiler. Since the lambda does not compile, Option C is the correct
answer. If the code was rewritten so that the MAX_LENGTH variable was marked final and
assigned a value of 5 from the start, then it would output 2, and Option A would be correct.
|
37. B. To begin with, all of the functional interfaces in the list of choices take two values.
The difference is in the name of the method they use. BiConsumer uses accept(),
making Option A incorrect. Option B is correct because BiFunction includes the
apply() method. Option C is incorrect, since BiPredicate uses the test() method.
DoubleBinaryOperator is almost correct but the name of the method is applyAsDouble(),
not apply(), making Option D incorrect. For the exam, you should be aware of which
primitive functional interfaces use a different method name than the generic ones.
|
38. B. To start with, IntFunction<Integer> takes an int value and returns an Integer. The
first statement uses Integer instead of int as the input argument and is therefore not compatible.
The second statement is compatible, since the return type null can be used as an
Integer return type. The last statement is also valid. An int can be autoboxed to Integer.
For these reasons, Option B is the correct answer.
|
39. C. The primitive Supplier functional interfaces, such as BooleanSupplier and
LongSupplier, do not have a get() method. Instead, they have methods such as
getAsBoolean() and getAsLong(), respectively. For this reason, the first line of the
checkInventory() method does not compile, making Option C the correct answer. If
the method call was changed to getAsBoolean(), then the rest of the code would compile
without issue, print Plenty! at runtime, and Option A would be the correct answer.
|
40. B. Java only supports a single return data type or void. Therefore, it is not possible to
define a functional interface that returns two data types, making Option A incorrect.
Although Java does not include built-in support for primitive functional interfaces that
include float, char, or short, there is nothing to prevent a developer from creating them
in their own project, making Option B the true statement and the correct answer. Option C
is incorrect because a functional interface that takes no values and returns void is possible.
In fact, Runnable is one such example. Option D is also incorrect, since IntFunction<R>
takes a primitive argument as input and a generic argument for the return type.
|
1. D. Option A is incorrect because it doesn’t print out one line. The peek() method is an
intermediate operation. Since there is no terminal operation, the stream pipeline is not
executed, so the peek() method is never executed. Options B and C are incorrect because
they correctly output one line using a method reference and lambda, respectively, and don’t
use any bad practices. Option D is the answer. It does output one line. However, it is bad
practice to have a peek() method that has side effects like modifying a variable.
|
2. A. This code generates an infinite stream of integers: 1, 2, 3, 4, 5, 6, 7, etc. The Predicate
checks if the element is greater than 5. With anyMatch(), the stream pipeline ends once element
6 is hit and the code prints true. For both the allMatch() and noneMatch() operators,
they see that the first element in the stream does not match and the code prints false.
Therefore, Option A is correct.
|
3. B. Only the average() method returns an OptionalDouble. This reflects that it doesn’t
make sense to calculate an average when you don’t have any numbers. By contrast, counting
without any numbers gives the long number 0 and summing gives the double number 0.0.
Since only one method matches the return type, Option B is correct.
|
4. C. The map() method can fill in the blank. The lambda converts a String to an int and
Java uses autoboxing to turn that into an Integer. The mapToInt() method can also fill
in the blank and Java doesn’t even need to autobox. There isn’t a mapToObject() in the
stream API. Note there is a similarly named mapToObj() method on IntStream. Since both
map() and mapToInt() work here, Option C is correct.
|
5. D. The average() method returns an OptionalDouble. This interface has a getAsDouble()
method rather than a get() method, so the code does compile. However, the stream is
empty, so the optional is also empty. When trying to get the value, the code throws a
NoSuchElementException, making Option D correct.
|
6. D. Option A is incorrect because anyMatch() returns a boolean. Option B is incorrect
because filter() is an intermediate operation, not a terminal operation, and therefore
returns a Stream. Both of these methods do take a Predicate as a parameter. While
findAny() does return an Optional, it doesn’t take any parameters. Therefore, Option C
is incorrect, and Option D is the answer.
|
7. B. This code builds a list with two elements. It then uses that list as a source for the stream,
sorts the stream as it goes by, and grabs the first sorted element. This does not change the
original list. The first element in the sorted stream is 1.2, but the first element of list
remains as 5.4. This makes Option B correct.
|
8. B. Primitive streams, like LongStream, declare an average() method, while summary
statistics classes, like LongSummaryStatistics, declare a getAverage() method, making
Options C and D incorrect. The average() method returns an OptionalDouble object,
which declares a getAsDouble() method rather than a get() method. Therefore, Option A
is incorrect, and Option B is correct.
|
9. B. Since the result of the collect() is not stored in a variable or used in any way, all the
code needs to do is compile. There is no Collectors.toArrayList() method. If you want
to specify an ArrayList, you can call Collectors.toCollection(ArrayList::new).
The Collectors.toList() method does in fact exist and compile. While there is a
Collectors.toMap() method, it requires two parameters to specify the key and value
functions, respectively. Since only one can compile, Option B is correct.
|
10. C. As tempting as it is, you can’t actually convert a Map into a Stream directly, which
means you can’t call the map() method on it either. However, you can build a Stream out of
the keys or values or key/value pairs. Since this code doesn’t compile, Option C is correct.
|
11. D. I is incorrect because isPresent() returns false for an empty Optional. II is incorrect
because of() throws a NullPointerException if you try to pass a null reference.
III doesn’t throw an exception as the ofNullable() is designed to allow a null reference.
However, it returns false because no value is present. Since none of the choices are correct,
Option D is the answer.
|
12. A. This code does compile. Remember that imports are implied, including the static
import for Collectors. The collector tries to use the number of characters in each stream
element as the key in a map. This works fine for the first two elements, speak and bark,
because they are of length 5 and 4, respectively. When it gets to meow, it sees another key
of 4. The merge function says to use the first one, so it chooses bark for the value. Similarly,
growl is 5 characters, but the first value of speak is used. There are only two distinct
lengths, so Option A is correct.
|
13. C. For the primitive stream that contains the int primitives, the interface names are incorrect.
They should be IntStream and IntSummaryStatistics, making Option C correct. If
this was fixed, Option B would be the answer.
|
14. B. This code does compile. As an intermediate operation, you are allowed to call peek()
many times in a stream pipeline. You can even call it multiple times in a row. While it is
common to write System.out::println directly as a parameter to peek(), nothing prevents
you from creating a Consumer variable. Since the forEach() method also takes a
Consumer, we can reuse it. The three peek() intermediate operations and one forEach()
operation total four lines of output. The map() operation could be omitted since it simply
passes the input through.
|
15. B. Character objects are allowed in a Stream, so line z1 compiles, making Option C
incorrect. Line z2 also compiles since findAny() returns an Optional and ifPresent() is
declared on Optional. Therefore, Option D is also incorrect. Now let’s look at the Stream.
The source has three elements. The intermediate operation sorts the elements and then we
request one from findAny(). The findAny() method is not guaranteed to return a specific
element. Since we are not using parallelization, it is highly likely that the code will print a.
However, you need to know this is not guaranteed, making Option B the answer.
|
16. A. The sorted() method takes an optional Comparator as the parameter, which takes two
String parameters and returns an int. Option A is correct because the lambda implements
this interface. Option B is incorrect because the method reference doesn’t take any parameters,
nor does it return an int.
|
17. D. The Optional class has an isPresent() method that doesn’t take any parameters. It
returns a boolean and is commonly used in if statements. There is also an ifPresent()
method that takes a Consumer parameter and runs it only if the Optional is non-empty.
The methods isNotNull() and forEach()are not declared in Optional. Therefore, Option
D is correct.
|
18. C. The first intermediate operation, limit(1), turns the infinite stream into a stream with
one element: true. The partitioningBy() method returns a map with two keys, true
and false, regardless of whether any elements actually match. If there are no matches, the
value is an empty list, making Option C correct.
|
19. B. The flatMap() method is used to turn a stream of streams into a one-dimensional
stream. This means it gets rid of the empty list and flattens the other two. Option A is
incorrect because this is the output you’d get using the regular map() method. Option B is
correct because it flattens the elements. Notice how it doesn’t matter that all three elements
are different types of Collection implementations.
|
20. D. The sorted() method allows an optional Comparator to be passed as a reference.
However, Comparator.reverseOrder() does not implement the Comparator interface. It
takes zero parameters instead of the required two. Since it cannot be used as a method reference,
the code does not compile, and Option D is correct.
|
21. D. Option A is incorrect because the findAny() might not return 1. The result could
be any of the three numbers. Option B is incorrect because there is no first() method
available as a terminal operation. Option C is tempting because there is a min() method.
However, since we are working with a Stream, this method requires a Comparator as a
parameter. Therefore, Option D is the answer.
|
22. C. List doesn’t have a filter() method, so Option A is incorrect. Stream does have
filter() and map() methods. However, Stream doesn’t have an ifPresent() method.
This makes IV incorrect, so Options B and D are incorrect. Both Collection and String
have an isEmpty() method, so either can be used with the Optional, making Option C the
answer.
|
23. D. This code generates an infinite stream of the number 1. The Predicate checks if the
element is greater than 5. This will never be true. With allMatch(), the stream pipeline
ends after checking the first element. It doesn’t match, so the code prints false. Both
anyMatch() and noneMatch() keep checking and don’t find any matches. However, they
don’t know if a future stream element will be different, so the code executes infinitely until
the process is terminated. Therefore, Option D is correct.
|
24. D. Both Collectors.groupingBy() and Collectors.partitioningBy() are useful for
turning a stream into a Map. The other two methods do not exist. However, when using a
condition, you should use partitioningBy() as it automatically groups using a Boolean
key. Therefore, Option D is correct.
|
25. B. Option A is incorrect because we are working with primitives rather than objects.
Option C compiles but outputs the stream references rather than the contents. Option B is
correct because it flattens the int primitives into one stream.
|
26. D. The summary statistics classes provide getters in order to access the data. The
getAverage() method returns a double and not an OptionalDouble. Option D is the only
option to compile.
|
27. D. Option A doesn’t compile because the get() method on Optional doesn’t take any
parameters. Options B and C do compile, but both print Cupcake since the Optional is not
empty. Therefore, Option D is correct.
|
28. C. The first line generates an infinite stream. The stream pipeline has a filter that lets all
these elements through. Since sorted() requires all the elements be available to sort, it
never completes, making Option C correct.
|
29. A. The mapToDouble() method compiles. However, it converts 9 into 9.0 rather than the
single digit 9. The mapToInt() method does not compile because a long cannot be converted
into an int without casting. The mapToLong() method is not available on LongStream so it
does not compile. It is available on DoubleStream, IntStream, and Stream implementations.
Since none of the options outputs the single digit 9, Option A is correct.
|
30. A. The filter() method either passes along a given element or doesn’t, making Option D
incorrect. The flatMap() method doesn’t pass along any elements for empty streams. For
non-empty streams, it flattens the elements, allowing it to return zero or more elements.
This makes Option B incorrect. Finally, the map() method applies a one-to-one function for
each element. It has to return exactly one element, so Option A is the correct answer.
|
31. D. First, we sort the stream. Option B is incorrect because findFirst() is guaranteed to
return the first element. However, the findFirst() method returns an Optional. Therefore,
the output of this code is Optional[a] rather than the letter a, making Option D correct.
|
32. C. There is not a stream pipeline method called sort(). There is one called sorted().
Since the code does not compile, Option C is correct. If this was fixed, Option A would be
correct since the Comparator sorts in ascending order.
|
33. B. This code compiles. It creates a stream of Ballot objects. Then it creates a map with the
contestant’s name as the key and the sum of the scores as the value. For Mario, this is 10 +
9, or 19, so Option B is correct.
|
34. D. Both anyMatch() and allMatch() take a Predicate as a parameter. This code does
not compile because the parameter is missing.
|
35. D. The flatMap() method works with streams rather than collections. The code does not
compile because the x is not a stream, making Option D correct. If this was fixed, Option B
would be the answer.
|
36. C. The groupingBy() collector always returns a Map (or a specific implementation
class of Map), so III can’t be right. The other two are definitely possible. To get I, you
can group using a Function that returns an Integer such as s.collect(Collectors
.groupingBy(String::length)). To get II, you need to group using a Function
that returns a Boolean and specify the type, such as s.collect(Collectors
.groupingBy(String::isEmpty, Collectors.toSet())). Notice that autoboxing is
used for both. Therefore, Option C is correct.
|
37. D. There is no built-in method to map a value to a boolean primitive. Therefore, Options B
and C don’t even compile, so they are incorrect. Option A does compile as it maps a Runner
to a Boolean. However, it doesn’t actually filter() the stream to eliminate any values,
so the output is not the same. It prints 3 instead of 1. None of these are correct, making
Option D the answer.
|
38. A. Option A is the answer because there is a getCount() method that returns a long
rather than a method named getCountAsLong(). Option B is incorrect because there is in
fact a getMax() method. Option C is incorrect because toString() is declared on Object,
which means it is inherited by all classes.
|
39. C. The main() method has warnings, but it does compile, making Option D incorrect. The
warnings are both about not declaring the generic type for Optional. Option A does not
compile because the orElse() method expects an Exception as the alternate value passed
as a parameter. IllegalArgumentException::new is a Supplier instead. Options B and C
both compile as both methods expect a Supplier as the parameter. However, orElseGet()
simply returns the exception from the method rather than throwing it. Option C actually
throws the exception the Supplier created and is the correct answer.
|
40. B. Option A happens to output the same result for both pairs. It outputs a blank line in
withFlatMap() because empty streams are removed and in withoutFlatMap() because
the filter() method removes the empty list. Option B outputs different results. The
withFlatMap() method outputs lastall queued up since it flattens the streams. By contrast,
the withoutFlatMap() method outputs [last, all queued up] since it leaves the
structure intact. Since the output is different. Option B produces different results so it is the
answer.
|
1. D. If no exception is thrown, then the catch block will not be executed. The try block is
always visited first, followed by the finally block, which is guaranteed to execute regardless
of whether an exception is thrown. For these reasons, Option D is the correct answer,
with the statements in the correct order.
|
2. C. Unlike a try-with-resources statement, in which the catch and finally blocks are
optional, a try statement requires a catch or finally block to be used, or both. For this
reason, Option C is the correct answer.
|
3. D. The code does not compile because the throw keyword is incorrectly used in the toss()
method declaration. The keyword throws should have been used instead. For this reason,
Option D is the correct answer. Since LostBallException inherits Throwable and the main()
method handles Throwable, LostBallException is handled by the main() method, making
Option B incorrect. Option C is also incorrect because ArrayStoreException is an unchecked
exception that extends RuntimeException and is not required to be handled or declared.
Finally, if throws was used instead of throw, the entire application would compile without
issue and print Caught!, making Option A the correct answer.
|
4. A. The only symbol permitted to separate exception types in a multi-catch statement is a
single pipe character (|). For this reason, Option A is correct.
|
5. D. In Java, assert is a keyword, meaning it cannot be used as a variable, class, or method
name. For this reason, line 5 does not compile. Line 6 also does not compile because the
assert statement is not a method and does not support parentheses around both expressions.
Because neither of these lines compile, Option D is the correct answer.
|
6. C. First off, Error is an unchecked exception. It is recommended that Error not be
caught by most application processes, making Option A incorrect. IllegalStateException
inherits RuntimeException, both of which are unchecked, making Options B and D,
respectively, incorrect. Option C is correct because ParseException must be handled or
declared.
|
7. D. The Exception class contains multiple constructors, including one that takes
Throwable, one that takes String, and a no-argument constructor. The first
WhaleSharkException constructor compiles, using the Exception constructor that takes a
String. The second WhaleSharkException constructor also compiles. The two statements,
super() and new Exception(), actually call the same constructor in the Exception class,
one after another. The last WhaleSharkException compiles with the compiler inserting
the default no-argument constructor super(), because it exists in the Exception class. For
these reasons, all of the constructors compile, and Option D is the correct answer.
|
8. B. The UnsupportedOperationException class is an unchecked exception, which means
it inherits from RuntimeException. While Error also is an unchecked exception, the diagram
indicates that the class does not inherit from Error. There is only one class between
Throwable and RuntimeException in the diagram, and since we know RuntimeException
inherits Exception, the other missing class must be Exception. For these reasons, Option
B is the correct answer.
|
9. C. The code does not compile because the variable b is used twice in the main() method,
both in the method declaration and in the catch block, making Option C the correct
answer. If a different variable name was used in one of the locations, the program would
print one line, complete, making Option A the correct answer. Note that while an exception
is created inside the turnOn() method, it is not thrown.
|
10. D. First off, unless assertions are enabled at runtime, no assertion statement guarantees an
assertion will be thrown at runtime, making Option D the correct answer. Next, Option
A does not compile because the assert statement is not a method and does not take arguments
in parentheses. It’s also invalid because it requires a boolean expression for the
first expression, not a numeric one. An additional value can be specified, but it requires a
colon separator (:). Option B would be the correct answer and trigger an error if assertions
are enabled, since 0==1 evaluates to false. Option C is incorrect. Even if assertions were
enabled, it would not trigger an error since 0==0 evaluates to true.
|
11. C. The class does not compile because in line r2, brackets {} are used instead of parentheses
() in the try-with-resources statement, making Option C the correct answer. If this line
was fixed to use parentheses (), then the rest of the class would compile without issue and
print This just in! at runtime, making Option A the correct answer.
|
12. C. When both a try block and close() method throw exceptions, the one in the try
block is the primary, while the one in the close() method is suppressed. For this reason,
Option A is a true statement. Option B is also a true statement, since a catch block is not
required when using a try-with-resources statement. Option C is the correct answer, since
resources are closed in reverse order in which they are created, not the other way around.
Option D is a true statement because multiple resources can be declared within a single set
of parentheses, each separated by a semicolon (;).
|
13. A. The program compiles without issue, so Option D is incorrect. The narrower
SpellingException and NullPointerException, which inherit from Exception, are
correctly presented in the first catch block, with the broader Exception being in the second
catch block. The if-then statement evaluates to true, and a new SpellingException
instance is created, but it is not thrown because it is missing the throw keyword. For this
reason, the try block ends without any of the catch blocks being executed. The finally
block is then called, making it the only section of code in the program that prints a line of
text. For this reason, Option A is the correct answer.
|
14. C. First off, the try block is capable of throwing two checked exceptions,
MissingMoneyException and MissingFoodException. The catch block uses the
Exception class to handle this, since both have Exception as a supertype. It then rethrows
the Exception. For this reason, Exception would be appropriate in the blank, making the
first statement correct. The compiler is also smart enough to know that there are only two
possible subclasses of Exception that can actually be thrown in the main() method, so
declaring MissingMoneyException and MissingFoodException together also allows the
code to compile, making the third statement correct. The second statement, only inserting
MissingMoneyException, would not allow the code to compile because the main() method
could throw a checked MissingFoodException that was not handled. For these reasons,
Option C is the correct answer.
|
15. C. First off, Closeable extends AutoCloseable, making Option A incorrect. The difference
between the two is that the close() method in AutoCloseable throws Exception,
while the close() method in Closeable throws IOException, making Option D incorrect.
Since IOException is a subclass of Exception, both close() methods can throw an
IOException, making Option B incorrect. On the other hand, Exception is not a subclass
of IOException. For this reason, the close() method in a class that implements
Closeable cannot throw an instance of the Exception class, because it is an invalid
override using a broader exception type, making Option C the correct answer.
|
16. B. Option A does not compile because a multi-catch expression uses a single variable, not
two variables. Option C does not compile because it is not possible to throw this checked
IOException in the try block. Option D does not compile because multi-catch blocks cannot
contain two exceptions in which one is a subclass of the other. If it did, one of the two
exceptions would be redundant. Option B is the correct answer and the only expression that
allows the class to compile. While both exceptions in the multi-catch block inherit from
Exception, neither is a subclass of the other.
|
17. C. First off, the order of exceptions in a multi-catch does not matter, only that they not
be subclasses of one another, making Options A and B incorrect. Option C is the correct
answer because a multi-catch variable is effectively final. Java forbids reassigning of multicatch
variables since it is unclear what the precise reference type is. Option D is incorrect
because a multi-catch with a single exception type is just a regular catch block. A regular
catch variable is not required to be effectively final and can be reassigned within the catch
block.
|
18. D. The code does not compile, so Option A is incorrect. The first compilation error is that
Shelf does not implement AutoCloseable, meaning a try-with-resources statement cannot
be used. Even though Shelf does implement Closing, an interface that uses the same
abstract method signature as AutoCloseable, the JVM requires AutoCloseable be
implemented to use try-with-resources. The second compilation problem is that throws is
used instead of throw inside the try block. Remember that throws is only used in method
signatures. The third compilation issue is that the order of exceptions in the two catch
blocks are reversed. Since Exception will catch all IllegalArgumentException instances,
the second catch block is unreachable. The final compilation error is that the shelf variable
is used in the finally block, which is out of scope. Remember that the scope of trywith-
resources variables ends when the try statement is complete. For these four reasons,
Option D is the correct answer.
|
19. A. Option A is the correct answer. Any catch or finally blocks used with a try-withresources
statement are executed after the declared resources have been closed, not before.
Options B and C are true statements, since Closeable extends AutoCloseable and the
requirement for try-with-resources is that they must be of type AutoCloseable. Finally,
Option D is a true statement and one of the primary motivations for using try-withresources
statements.
|
20. D. The optional second parameter of an assert statement, when used, must return a value.
The second assert statement uses System.out.print() as its second parameter, which
has a return type of void. For this reason, the code does not compile, making Option D the
correct answer. Other than this one line, the rest of the class compiles without issue.
|
21. D. Only one of the classes, MissingResourceException, inherits from the unchecked
RuntimeException class, making Option D the correct answer. In fact, IOException and
SQLException extend the checked Exception class directly. The NotSerializableException
is also checked, since it is a subclass of IOException via ObjectStreamException.
|
22. D. The code does not compile, making Options A and B incorrect. The declaration of
weatherTracker uses an anonymous inner class that correctly overrides the close()
method. Remember that overridden methods cannot throw any new or broader checked
exceptions than the inherited method. Alternatively, they can avoid throwing inherited
checked exceptions or declare new unchecked exceptions, such as RuntimeException.
The compilation error is in the catch block of the main() method, where the
weatherTracker variable is out of scope. In try-with-resources statements, the
resources are only accessible in the try block. For this reason, Option D is the correct
answer.
|
23. A. Asserts can be enabled by using the command-line options -ea or -enableassertions
and disabled by using -da or -disableassertions. Passing -di does not enable or disable
assertions, making Option A the correct answer.
|
24. A. The application compiles without issue and prints Hello, making Option A the correct
answer. The ReadSign and MakeSign classes are both correctly implemented, with both
overridden versions of close() dropping the checked exception. The try-with-resources
statement is also correctly implemented for two resources and does not cause any compilation
errors or runtime exceptions. Note that the semicolon (;) after the second resource
declaration is optional.
|
25. B. The code compiles, so Option D is incorrect. The order of evaluation for a try-withresources
statement is that the resources are closed before any associated catch or
finally blocks are executed. For this reason, 2 is printed first, followed by 1. The
ArithmeticException is then caught and 3 is printed. The last value printed is 4, since the
finally block runs at the end. For these reasons, Option B is the correct answer.
|
26. B. First off, Option A is an incorrect statement because the AutoCloseable interface does
not define a default implementation of close(). Next, the close() method should be
idempotent, which means it is able to be run multiple times without triggering any side
effects. For this reason, Option B is correct. After being run once, future calls to close()
should not change any data. Option C is incorrect because the close() method is fully
capable of throwing exceptions. In fact, the signature of the method in AutoCloseable
throws a checked Exception, although classes that override it may choose to drop the
checked exception. Option D is incorrect because the return type of close() is void, which
means no return value can be returned.
|
27. D. The play() method compiles without issue, rethrowing a wrapped exception in
the catch block. While the main() method does declare RuntimeException, it does
not declare or catch the Exception thrown by the calls to play(). Even though the
play() method does not appear to actually throw an instance of Exception, because it
is declared, the main() method must catch or declare it. Since the checked exception is
not handled, the main() method does not compile, and Option D is the correct answer.
If the main() method was changed to declare the appropriate checked exception, then
the rest of the code would compile, and exactly one exception would be printed, making
Option A the correct answer.
|
28. B. Assertions are often used to check method post conditions, test control flow invariants,
and validate class invariants, making Options A, C, and D true statements. Option B is the
correct answer. An assertion should never modify any data because it may be disabled at
runtime, leading to unintended side effects.
|
29. B. A multi-catch block cannot contain two exceptions in which one is a subclass of the
other, since it is a redundant expression. Since CarCrash is a subclass of RuntimeException
and RuntimeException is a subclass of Exception, line w2 contains a compilation error,
making Option B the correct answer. The rest of the lines of code do not contain any compilation
errors.
|
30. B. First off, a class must inherit from RuntimeException or Error to be considered an
unchecked exception. Dopey and Grumpy both are subclasses of Exception, but not
RuntimeException, making them both checked exceptions. Since IOException is a
checked exception, the subclass Happy is also a checked exception. Sleepy extends
IllegalStateException, which is an unchecked exception that extends
RuntimeException. Finally, Sneezy extends Throwable, which does not inherit
RuntimeException or Error, making it a checked exception. Therefore, there are a total of
four checked exceptions and one unchecked exception within the classes listed here. Since
there are no compilation errors in any of the class declarations, Option B is the correct
answer, with the first and third statement being true.
|
31. D. The close() method in each of the resources throws an Exception, which must be
handled or declared in the main() method. The catch block supports TimeException,
but it is too narrow to catch Exception. Since there are no other catch blocks present and
the main() method does not declare Exception, the try-with-resources statement does not
compile, and Option D is the correct answer. If the catch block was modified to handle
Exception instead of TimeException, the code would compile without issue and print
3215 at runtime, closing the resources in the reverse order in which they were declared and
making Option B the correct answer.
|
32. A. The try-catch block already catches Exception, so the correct answer would be the one
that is not a subclass of Exception. In this case, Error extends Throwable and is the only
choice that allows the code to compile. Because IllegalStateException and RingException
both inherit from Exception, Options B and C, respectively, are incorrect. Finally, Option D is
incorrect because there is an answer choice that allows the code to compile.
|
33. B. Option A does not compile because the assignment (age=2) has a value of int, not
boolean, which is required for an assert statement. Option B compiles without issue and
is the correct answer. Even though Error and 10 are different data types, String and int
respectively, the second assert parameter only needs to be a value, so both are allowed.
Option C does not compile because the usage of the lambda expression does not match a
functional interface. Option D is incorrect because a return statement is not allowed in the
second expression of an assert statement.
|
34. D. The MissedCallException is a checked exception since it extends Exception and does not
inherit RuntimeException. For this reason, the first catch block fails to compile, since the compiler
detects that it is not possible to throw this checked exception inside the try block, making
Option D the correct answer. Note that if MissedCallException was changed to extend the
checked RuntimeException, then the code would compile and the RuntimeException from
the finally block would replace the ArrayIndexOutOfBoundsException from the try block in
the message reported to the caller, making Option C the correct answer.
|
35. D. The catch variable d is of type BearException that cannot be assigned an instance of the
superclass RuntimeException without an explicit cast. For this reason, the first catch block
does not compile in tellStory(). The second catch block also does not compile, albeit for
a slightly different reason. A catch variable in a multi-catch block must be effectively final
because the precise type is not known until runtime. Therefore, the compiler does not allow
the variable e to be reassigned. For these two reasons, Option D is the correct answer. Note
that the first catch block does allow the catch variable d to be reassigned, it just must be to a
class that inherits BearException or is an instance of BearException.
|
36. D. The play() method declares two checked exceptions, OutOfTuneException and
FileNotFoundException, which are handled in the main() method’s catch block using
the Exception type. The catch block then rethrows the Exception. The compiler is smart
enough to know that only two possible checked exceptions can be thrown here, but they
both must be handled or declared. Since the main() method only declares one of the two
checked exceptions, FileNotFoundException is not handled, and the code does not compile.
For this reason, Option D is the correct answer. Note that the main() could have also
handled or declared Exception, since both checked exceptions inherit it. If the main()
method had declared Exception, then Song finished! would have been printed followed
by a stack trace, making Option C the correct answer.
|
37. C. The code compiles without issue, making Option D incorrect. Option A is incorrect
because assertions are not enabled by default in Java. Therefore, the code will run without
throwing any exceptions. Option B is also incorrect because the command enables assertions
everywhere but disables them for the Falcon class. Option C is the correct answer,
with the command disabling assertions everywhere except in the Falcon class, causing an
AssertionError to be thrown at runtime.
|
38. C. The Closeable interface defines a close() method that throws IOException. The
overridden implementation of MyDatabase, which implements Closeable, declares a
SQLException. This is a new checked exception not found in the inherited method signature.
Therefore, the method override is invalid and the close() method in MyDatabase
does not compile, making Option C the correct answer.
|
39. D. The code does not compile because the close() method throws an Exception that is
not handled or declared in the main() method, making Option D the correct answer. When
a try-with-resources statement is used with a close() method that throws a checked exception,
it must be handled by the method or caught within the try-with-resources statement.
|
40. B. The code compiles without issue, making Option C incorrect. In the climb() method,
two exceptions are thrown. One is thrown by the close() method and the other by the
try block. The exception thrown in the try block is considered the primary exception and
reported to the caller on line e1, while the exception thrown by the close() method is suppressed.
For this reason, java.lang.RuntimeException is thrown to the main() method,
and Option B is the correct answer.
|
1. C. The date and time classes added in Java 8 are in the java.time package, making
Option C correct. The older date classes are in the java.util package.
|
2. A. The Duration class is used to reflect an amount of time using small units like minutes.
Since it just uses units of time, it does not involve time zones. The LocalTime class contains
units of hours, minutes, seconds, and fractional seconds. The LocalDateTime class
contains all the data in a LocalTime and adds on a year, month, and date. Neither of these
classes uses time zones. There is a ZonedDateTime class when you need to use time zones.
Since none of the three classes listed includes a time zone, Option A is correct.
|
3. A. A Period is measured in days, weeks, months, or years. A Duration is measured in
smaller units like minutes or seconds. Only Duration has a getSeconds() method, making
Option A correct.
|
4. D. To compare times in different time zones, you can subtract the time zone from the time
to convert to GMT. This makes it 02:00 in Berlin because we subtract 1 from 3. Similarly,
it is 02:00 in Helsinki due to subtracting 2 from 4. Finally, it is 04:00 in Warsaw because
we subtracted 1 from 5. We have a tie because it is the same time in Berlin and Helsinki, so
Option D is correct.
|
5. B. On a normal night, adding three hours to 1 a.m. makes it 4 a.m. However, this date
begins daylight savings time. This means we add an extra hour to skip the 2 a.m. hour. This
makes later contain 05:00 instead of 04:00. Therefore, the code prints 5, and Option B is
correct.
|
6. C. LocalDate allows passing the month as an int or Month enum parameter. However,
Month.MARCH is an enum. It cannot be assigned to an int variable, so the declaration of
month does not compile, and Option C is correct.
|
7. C. Both LocalDate and DateTimeFormatter have a format() method. This makes II
incorrect. While it is tricky, you do need to know that the format() method can be called
on either object. Since I and III are correct, Option C is the answer.
|
8. C. Converting to GMT by subtracting the time zone offset, it is 17:00 for the Phoenix time
since 10 minus negative 7 is 17. In GMT, the Vancouver time is 16:00 due to subtracting
negative 8 from 8. Remember that subtracting a negative number is the same as adding.
Therefore, the Vancouver time is an hour earlier than the Phoenix time, and Option C is
correct.
|
9. C. While there is no 2 a.m. on the clock that night, Java adjusts the time to 3 a.m. automatically
and changes the time zone. It does not throw an exception, so Option D is incorrect.
Option B is a valid expression, since any value after the time adjustment is just a
normal time on the clock. Since both A and B are valid expressions, Option C is the correct
answer.
|
10. B. Line 12 creates a Period representing a year, six months, and three days. Adding this to
waffleDay gives us the year 2018, the month of September, and a day of 28. This new date
is stored in later on line 13 and represents September 28, 2018. Line 14 has no effect as
the return value is ignored. Line 17 checks that you know that isBefore() returns false
if the value is an exact match. Since thisOne is an exact match but thatOne is a whole day
before, the output is false true, making Option B correct.
|
11. D. Duration is supposed to be used with objects that contain times. While it has an
ofDays() method, this is a convenience method to represent a large number of seconds.
This means that calling Duration.ofDays(1) is fine. However, this code throws an
UnsupportedTemporalTypeException when you try to pass it the minus() method on
LocalDate, making Option D correct. Note that the question asks about a possible result
rather than the definitive result because the format of dates varies by region.
|
12. C. The DateTimeFormatter is created with ofLocalizedDate(). It knows how to format
date fields but not time fields. Line 18 is fine because a LocalDate clearly has date fields.
Line 19 is also fine. Since a LocalDateTime has both date and time fields, the formatter just
looks at the date fields. Line 20 is a problem. A LocalTime object does not have any date
fields so the formatter throws an UnsupportedTemporalTypeException, making Option C
the answer.
|
13. D. This question is tricky. It appears to be about daylight savings time. However, the result
of z.plusHours(1) is never stored in a variable or used. Since ZonedDateTime is
immutable, the time remains at 01:00. The code prints out 1, making none of these correct
and Option D the answer.
|
14. D. For dates, a lowercase m means minute while an uppercase M means month. This eliminates
Options A and C. A lowercase h means hour. Therefore, Option B is incorrect, and
Option D is the answer.
|
15. D. There are three overloads for LocalTime.of(). Options A, B, and C are all valid overloads.
Option D is not because Java only allows passing one fractional second parameter.
Java does support nanoseconds, but not the further granularity of picoseconds.
|
16. C. The LocalDate class represents a date using year, month, and day fields. There is a
getYear() method to get the year. The Period class holds units of years, months, and days.
It has a getYears() method. There is not a date/time class called ZonedDate. There is a class
called ZonedDateTime, which does have a getYear() method. Since only LocalDate and
Period have a method to get the year, Option C is correct.
|
17. A. Duration is used for units of time a day and smaller, making Option B a true statement.
Period is used for units of time a day and larger, making Option C a true statement.
While both represent the same length of time, they output different values when calling
toString(). The Duration object outputs PT24H, and the Period object outputs P1D. This
shows that Duration is providing the ofDays() method as a convenience instead of requiring
the programmer to type 24 hours. Option A is the answer.
|
18. B. The first thing to notice is that this is a LocalTime object. Since there is no date component,
Options C and D are incorrect. Four parameters are passed to this LocalTime
method. The first three are the hour, minute, and second. The fourth is nanoseconds,
which are fractions of a second. While you aren’t expected to do calculations with nanoseconds,
you should know that a fraction of a second is at the end of the output. Option A is
incorrect because .4 is 40 percent of a second. That’s far larger than 4 nanoseconds. Therefore,
Option B is correct.
|
19. B. LocalDate starts counting months from one, so month 2 is February. This rules out
Options A and C. The pattern specifies that the date should appear before the month, making
Option B correct.
|
20. A. The ChronoUnit enum contains values for various measures of time including HOURS, so
Option A is correct.
|
21. B. Adding three hours to 13:00 makes it 16:00. While this date happens to be the start of
daylight savings time, the change occurs at 2 a.m. This code uses 13:00, which is 1 p.m.
Since the calculation does not cross 2 a.m., the fact that it is the date that starts daylight
savings time is irrelevant. Option B is correct because the hour is 16 and the time is 16:00.
|
22. B. This code correctly subtracts a day from montyPythonDay. It then outputs a
LocalDateTime value. Option A is incorrect because it omits the time. Option B is correct
because it represents one day earlier than the original date and includes a time in the
output.
|
23. D. There is a DateTimeFormatter class, but not a DateFormatter class. The
DateTimeFormatter class is used for formatting dates, times, or both. Since the provided
code does not compile, nothing can fill in the blank to make the code print 2017-01-15,
and Option D is the answer.
|
24. B. There are many overloads for LocalDateTime.of(). Option A is a valid overload
because it uses date and time objects. Options C and D are also valid overloads, showing
you can pass the month as an int or Month enum. Option B is the answer. Java doesn’t
allow combining a LocalDate object with time fields directly.
|
25. C. In the first time change of the year, clocks “spring ahead” and skip the 02:00–03:00
hour entirely. This means 1:59 is followed by 03:00 on March 12, 2017. By contrast, July
4 is a normal day and 1:59 is followed by 02:00. In the second time change of the year,
clocks “fall back” and repeat an hour, so 1:59 is followed by 01:00. Granted, you can’t tell
whether this is the first or second 1:59 from the image. If this information is relevant to a
question’s context, the question will specify this fact. In this case, 03:00, 02:00, 02:00 is
not a choice. Option C is the answer.
|
26. D. February has 28 or 29 days, depending on the year. There is never a February 31. Java
throws a DateTimeException when you try to create an invalid date, making Option D
correct.
|
27. A. This one is tricky. In order to determine GMT, you need to subtract the time zone offset
from the hour. In this case, the time zone offset is negative 10. Since subtracting a negative
number is like adding a positive number, this means we are adding 16 and 10. That gives us
26. However, there are only 24 hours in a day. We’ve crossed a time zone boundary, so we
can remove a whole 24-hour day. Subtracting 24 from 26 gives us 2. This means it is 02:00 in
GMT, and Option A is correct. It’s also a day later in GMT, but the question didn’t ask that.
|
28. D. An Instant represents a specific moment in time using GMT. Since there are no time
zones included, Options A and C are incorrect. This code correctly adds one day to the
instant, making Option D correct.
|
29. D. Make sure to pay attention to date types. This code attempts to add a month to a
LocalTime value. There is no plusMonths() method on LocalTime, so Option D is correct.
|
30. D. The format of the pattern is incorrect. You can’t just put literal text in there. Most
of the characters of Holiday: are not defined formatting symbols. The code throws an
IllegalArgumentException, so Option D is correct.
|
31. A. To compare times in different time zones, you can subtract the time zone from the time.
This makes it 09:00 in Bangkok because we subtract 7 from 16. Similarly, it is 14:00 in
Dubai due to subtracting 4 from 18. Finally, it is 12:00 in Kuala Lumpur because we subtracted
8 from 20. Notice how we used a 24-hour clock to make comparing times easier.
The earliest time is in Bangkok, so Option A is correct.
|
32. C. Line 12 creates a Period representing three days. Period objects do not chain, so only
the last method call, which is to ofDays(3), is used in determining the value. Adding three
days sets later to March 28, 2017. Line 14 has no effect as the return value is ignored.
March 28, 2017, is before both thisOne and thatOne, so Option C is correct.
|
33. B. The TemporalUnit interface does not define a DAYS constant, making II and IV incorrect.
The until() and between() methods have the same behavior. They determine how
many units of time are between two dates. One takes both dates as parameter and the other
is an instance method on the date. Since I and III are equivalent, Option B is the answer.
Note that while we don’t have date times in this question, the until() and between()
methods work the same way for them.
|
34. A. The DateTimeFormatter class is used to format all of these objects. The method will
throw an exception if called with a LocalDate since the formatter only knows about time
fields. However, it will still compile, making Option A correct.
|
35. B. This code begins by correctly creating four objects. It then adds a month to
date. Since Java 8 date/time classes are immutable, this does not affect the value of
iceCreamDay. Therefore, iceCreamDay remains in July. Since months count from one,
Option B is correct.
|
36. A. Java 8 date and time classes are immutable. They use a static factory method to get
the object reference rather than a constructor. This makes Options B and D incorrect. Further,
there is not a ZonedDate class. There is a ZonedDateTime class. As a result, Option C
is incorrect, and Option A is the answer.
|
37. B. The first line of code correctly creates a LocalDate object representing March 3, 2017.
The second line adds two days to it, making it March 5. It then subtracts a day, making it
March 4. Finally, it subtracts yet another day ending at March 3. The outcome of all this is
that we have two dates that have the same value, and Option B is correct.
|
38. C. An Instant represents a specific moment in time using GMT. Since LocalDateTime
does not have a time zone, it cannot be converted to a specific moment in time. Therefore,
the toInstant() call does not compile, and Option C is correct.
|
39. A. While it is traditional to include the year when outputting a date, it is not required. This
code correctly prints the month followed by a decimal point. After the decimal point, it
prints the day of the month followed by the hours and minutes. Happy Pi Day!
|
40. C. Normally, adding an hour would result in 02:00 in the same time zone offset of –05:00.
Since the hour is repeated, it is 01:00 again. However, the time zone offset changes instead.
Therefore, Option C is correct.
|
1. B. Writer is an abstract class, making Option B the correct answer. Note that
InputStream, OutputStream, and Reader are also abstract classes.
|
2. D. File uses mkdir() and mkdirs() to create a directory, not createDirectory(),
making Option A incorrect. Note there is a createDirectory() method in the NIO.2
Files class. The getLength() method also does not exist, as the correct method is called
length(). Next, there is a listFiles() method used to read the contents of a directory,
but there is no listFile() method. That leaves us with renameTo(), which does exist and
is used to rename file system paths.
|
3. C. The skip() method just reads a single byte and discards the value. The read() method
can be used for a similar purpose, making Option C the correct answer. Option A is incorrect
because there is no jump() method defined in InputStream. Options B and D are
incorrect because they cannot be used to skip data, only to mark a location and return to it
later, respectively.
|
4. D. Serializable is a marker or tagging interface, which means it does not contain any
methods and is used to provide information about an object at runtime. Therefore, Option
D is the correct answer because the interface does not define any abstract methods.
|
5. C. Given a valid instance of Console, reader() returns an instance of Reader, while
writer() returns an instance of PrintWriter. Reader and PrintWriter was not an
answer choice though, making Option C the next best choice since PrintWriter inherits
Writer. Options A and B are incorrect because PrintReader is not defined in the java
.io library. Option D is incorrect because the type of the instance returned by reader() is
Reader, which does not inherit StringReader.
|
6. D. BufferedWriter is a wrapper class that requires an instance of Writer to operate on.
In the Smoke class, a FileOutputStream is passed, which does not inherit Writer, causing
the class not to compile, and making Option D the correct answer. If FileWriter was used
instead of FileOutputStream, the code would compile without issue and print 13, making
Option B the correct answer.
|
7. A. The File class is used to read both files and directories within a file system, making
Option A the correct answer. The other three classes do not exist. Note there is an NIO.2
interface, java.nio.file.Path, used to read both file and path information.
|
8. C. FileOutputStream and FileReader are both low-level streams that operate directly on
files, making Options A and B incorrect. ObjectInputStream is a high-level stream that
can only wrap an existing InputStream. For this reason, Option C is the correct answer.
PrintWriter can operate on other streams, but it can also operate on files. Since the question
asks which class can only wrap low-level streams, Option D is incorrect.
|
9. D. The code compiles, so Option C is incorrect. The FileInputStream does not support
marks, though, leading to an IOException at runtime when the reset() method is called.
For this reason, Option D is the correct answer. Be suspicious of any code samples that call
the mark() or reset() method without first calling markSupported().
|
10. C. The absolute path is the full path from the root directory to the file, while the relative
path is the path from the current working directory to the file. For this reason, Option C is
the correct answer.
|
11. D. The difference between the two methods is that writeSecret1() does not take any
steps to ensure the close() method is called after the resource is allocated. On the other
hand, writeSecret2() uses a try-with-resources block, which automatically tries to
close the resource after it is used. Without a try-with-resources statement or an equivalent
finally block, any exception thrown by the write() method would cause the
resource not to be closed in the writeSecret1() method, possibly leading to a resource
leak. For this reason, Option D is the correct answer. Option A is incorrect since they
are not equivalent to each other. Finally, Options B and C are incorrect because both
compile without issue.
|
12. A. The constructor for Console is private. Therefore, attempting to call new Console()
outside the class results in a compilation error, making Option A the correct answer.
The correct way to obtain a Console instance is to call System.console(). Even if
the correct way of obtaining a Console had been used, and the Console was
available at runtime, stuff is null in the printItinerary() method. Referencing
stuff.activities results in a NullPointerException, which would make Option B
the correct answer.
|
13. A. While you might not be familiar with FilterOutputStream, the diagram shows that
the two classes must inherit from OutputStream. Options B and C can be eliminated as
choices since PrintOutputStream and Stream are not the name of any java.io classes.
Option D can also be eliminated because OutputStream is already in the diagram, and you
cannot have a circular class dependency. That leaves us with the correct answer, Option
A, with BufferedOutputStream and PrintStream both extending FilterOutputStream.
Note that ByteArrayOutputStream and FileOutputStream referenced in Options C and
D, respectively, do not extend FilterOutputStream, although knowing this fact was not
required to solve the problem.
|
14. D. The Cereal class does not implement the Serializable interface; therefore, attempting
to write the instance to disk, or calling readObject() using ObjectInputStream,
will result in a NotSerializableException at runtime. For this reason, Option D is the
correct answer. If the class did implement Serializable, then the value of name would
be CornLoops, since none of the constructor, initializers, or setters methods are used on
deserialization, making Option B the correct answer.
|
15. B. An OutputStream is used to write bytes, while a Writer is used to write character data.
Both can write character data, the OutputStream just needs the data converted to bytes
first. For this reason, Option A is incorrect. Option B is the correct answer, with Writer
containing numerous methods for writing character or String data. Both interfaces contain
a flush() method, making Option C incorrect. Finally, because both can be used with
a byte array, Option D is incorrect.
|
16. C. First off, the code compiles without issue. The first method call to mkdirs() creates two
directories, /templates and /templates/proofs. The next mkdir() call is unnecessary,
since /templates/proofs already exists. That said, calling it on an existing directory is
harmless and does not cause an exception to be thrown at runtime. Next, a file draft.doc
is created in the /templates directory. The final two lines attempt to remove the newly
created directories. The first call to delete() is successful because /templates/proofs is
an empty directory. On the other hand, the second call to delete() fails to delete the
directory /templates because it is non-empty, containing the file draft.doc. Neither of
these calls trigger an exception at runtime, though, with delete() just returning a
boolean value indicating whether the call was successful. Therefore, our program ends
without throwing any exceptions, and Option C is the correct answer.
|
17. D. To answer the question, you need to identify three of the four ways to call the systemindependent
file name separator. For example, the file name separator is often a forwardslash
(/) in Linux-based systems and a backward-slash (\) in Windows-based systems.
Option A is valid because it is the fully qualified name of the property. Option B is also
valid because File.separator and File.separatorChar are equivalent. While accessing
a static variable using an instance is discouraged, as shown in Option B, it is allowed.
Option C is valid and a common way to read the character using the System class. Finally,
Option D is the correct answer and one call that cannot be used to get the system-dependent
name separator character. Note that System.getProperty("path.separator") is
used to separate sets of paths, not names within a single path.
|
18. D. The first compilation error is that the FileReader constructor call is missing the new
keyword. The second compilation error is that the music variable is marked final, but
then modified in the while loop. The third compilation problem is that the readMusic()
method fails to declare or handle an IOException. Even though the IOException thrown
by readLine() is caught, the one thrown by the implicit call to close() via the try-withresources
block is not caught. Due to these three compilation errors, Option D is the correct
answer.
|
19. C. Both of the methods do exist, making Option D incorrect. Both methods take the
same arguments and do the exact same thing, making Option C the correct answer. The
printf() was added as a convenience method, since many other languages use printf()
to accomplish the same task as format().
|
20. C. FileWriter and BufferedWriter can be used in conjunction to write large amounts of
text data to a file in an efficient manner, making Option C the correct answer. While you
can write text data using FileOutputStream and BufferedOutputStream, they are primarily
used for binary data. Since there is a better choice available, Option A is incorrect.
Option B is incorrect since FileOutputWriter and FileBufferedWriter are not classes
that exist within the java.io API. Option D is incorrect since ObjectOutputStream is a
high-level binary stream. Also, while it can write String data, it writes it in a binary format,
not a text format.
|
21. D. The code compiles and runs without issue, so Options A and B are incorrect. The problem
with the implementation is that checking if ios.readObject() is null is not the recommended
way of iterating over an entire file. For example, the file could have been written
with writeObject(null) in-between two non-null records. In this case, the reading of the
file would stop on this null value, before the end of the file has been reached. For this reason,
Option D is the correct answer. Note that the valid way to iterate over all elements of a
file using ObjectInputStream is to continue to call readObject() until an EOFException
is thrown.
|
22. D. BufferedInputStream is the complement of BufferedOutputStream. Likewise,
BufferedReader and FileReader are the complements of BufferedWriter and
FileWriter, respectively. On the other hand, PrintWriter does not have an accompanying
PrintReader class within the java.io API, making Option D the correct answer.
Remember that this is also true of PrintStream, as there is no PrintInputStream class.
|
23. C. The File getParent() method returns a String, not a File object. For this reason,
the code does not compile on the last line since there is no getParent() method defined
in the String class, and Option C is correct. If the first method call on the last line was
changed to getParentFile(), then the code would compile and run without issue, outputting
/ - null and making Option B the correct answer. The File class does not require
the location to exist within the file system in order to perform some operations, like
getParent(), on the path.
|
24. D. All three statements about the program are correct. If System.console() is available,
then the program will ask the user a question and then print the response if one is entered.
On the other hand, if System.console() is not available, then the program will exit with a
NullPointerException. It is strongly recommended to always check whether or not
System.console() is null after requesting it. Finally, the user may choose not to respond
to the program’s request for input, resulting in the program hanging indefinitely and making
the last statement true.
|
25. C. The code contains two compilation errors. First, the File list() method returns a list
of String values, not File values, so the call to deleteTree() with a String value does
not compile. Either the call would have to be changed to f.listFiles() or the lambda
expression body would have to be updated to deleteTree(new File(s)) for the code to
work properly. Next, there is no deleteDirectory() method in the File class. Directories
are deleted with the same delete() method used for files, once they have been emptied.
With those two sets of corrections, the method would compile and be capable of deleting a
directory tree. Notice we continually used the phrase “capable of deleting a directory tree.”
While the corrected code is able to delete a directory tree, it may fail in some cases, such as
if the file system is read-only.
|
26. C. System.err, System.in, and System.out are each valid streams defined in the System
class. System.info is not, making Option C the correct answer.
|
27. D. The code compiles without issue, making Options B and C incorrect. The BufferedWriter
uses the existing FileWriter object as the low-level stream to write the file to disk. By using
the try-with-resources block, though, the BufferedWriter calls close() before executing
any associated catch or finally blocks. Since closing a high-level stream automatically closes
the associated low-level stream, the w object is already closed by the time the finally block is
executed. For this reason, the flush() command triggers an IOException at runtime, making
Option D the correct answer. Note that the call to w.close(), if that line was reached, does
not trigger an exception, because calling close() on already closed streams is innocuous.
|
28. B. The Console class contains a reader() method that returns a Reader object. The
Reader class defines a read() method, but not a readLine() method. For this reason,
Option B is the correct answer. Recall that a BufferedReader is required to call the
readLine() method. Options A, C, and D are valid ways to read input from the user.
|
29. C. The code compiles without issue, since InputStream and OutputStream both support
reading/writing byte arrays, making Option A incorrect. Option D is also incorrect. While
it is often recommended that an I/O array be a power of 2 for performance reasons, it is not
required, making Option D incorrect. This leaves us with Options B and C. The key here
is the write() method used does not take a length value, available in the chirps variable,
when writing the file. The method will always write the entire data array, even when only
a handful of bytes were read into the data array, which may occur during the last iteration
of the loop. The result is that files whose bytes are a multiple of 123 will be written correctly,
while all other files will be written with extra data appended to the end of the file.
For this reason, Option C is the correct answer. If the write(data) call was replaced with
write(data,0,chirps), which does take the number of bytes read into consideration, then
all files would copy correctly, making Option B the correct answer.
|
30. C. The class name has three components that tell you what it would do if it was a java.io
stream. First, Buffered tells you it can be used to handle large data sets efficiently. Next,
File tells you it is involved in reading or writing files. Finally, Reader tells you it is used to
read character data. Therefore, the class would be useful for reading large files of character
data from disk efficiently, making Option C the correct answer. Option A is incorrect
because it refers to a small file over a network. Options B and D are incorrect because both
involve binary data.
|
31. A. The code compiles and runs without issue. The first two values of the
ByteArrayInputStream are read. Next, the markSupported() value is tested. Since -1 is not
one of the possible answers, we assume that ByteArrayInputStream does support marks. Two
values are read and three are skipped, but then reset() is called, putting the stream back in the
state before mark() was called. In other words, everything between mark() and reset() can
be ignored. The last value read is 3, making Option A the correct answer.
|
32. C. Line 5 creates a File object, but that does not create a file in the file system unless
cake.createNewFile() is called. Line 6 also does not necessarily create a file, although
the call to flush() will on line 7. Note that this class does not properly close the file
resource, potentially leading to a resource leak. Line 8 creates a new File object, which is
used to create a new directory using the mkdirs() method. Recall from your studies that
mkdirs() is similar to mkdir(), except that it creates any missing directories in the path.
Since directories can have periods (.) in their name, such as a directory called info.txt,
this code compiles and runs without issue. Since two file system objects, a file and a directory,
are created, Option C is the correct answer.
|
33. B. Since the file is stored on disk, FileInputStream is an appropriate choice. Next,
because the data is quite large, a BufferedInputStream would help improve access.
Finally, since the data is a set of Java values, ObjectInputStream would allow various
different formats to be read. The only one that does not help in this process is
BufferedReader, Option B. BufferedReader should be used with text-based Reader
streams, not binary InputStream objects.
|
34. B. The flush() method is defined on classes that inherit Writer and OutputStream,
not Reader and InputStream. For this reason, the r.flush() in both methods does
not compile, making Option B the correct answer and Option C incorrect. The methods
are not equivalent even if they did compile, since getNameSafely() ensures the
resource is closed properly by using a try-with-resources statement, making Option A
incorrect for two reasons. Finally, Option D would be correct if the calls to flush()
were removed.
|
35. A. First off, the class compiles without issue. Although there are built-in methods to print
a String and read a line of input, the developer has chosen not to use them for most of the
application. The application first prints Pass, one character at a time. The flush() method
does not throw an exception at runtime. In fact, it helps make sure the message is presented
to the user. Next, the user enters badxbad and presses Enter. The stream stops reading on
the x, so the value stored in the StringBuilder is bad. Finally, this value is printed to the
user, using the format() method along with Result: as a prefix. For these reasons, Option
A is the correct answer.
|
36. B. The readPassword() returns a char array for security reasons. If the data was stored as
a String, it would enter the shared JVM string pool, potentially allowing a malicious user
to access it, especially if there is a memory dump. By using a char array, the data can be
immediately cleared after it is written and removed from memory. For this reason, Option B
is the correct answer. The rest of the statements are not true.
|
37. A. The BufferedInputStream constructor in the readBook() method requires an
InputStream as input. Since FileReader does not inherit InputStream, the readBook()
method does not compile, and Option A is the correct answer. If FileReader was changed
to FileInputStream, then the code would compile without issue. Since read() is called
twice per loop iteration, the program would print every other byte, making Option C
correct. Remember that InputStream read() returns -1 when the end of the stream is
met. Alternatively, we use EOFException with ObjectInputStream readObject() to
determine when the end of the file has been reached.
|
38. B. Generally speaking, classes should be marked with the Serializable interface if they
contain data that we might want to save and retrieve later. Options A, C, and D describe
the type of data that we would want to store over a long period of time. Option B, though,
defines a class that manages transient or short-lived data. Application processes change
quite frequently, and trying to reconstruct a process is often considered a bad idea. For
these reasons, Option B is the best answer.
|
39. D. The receiveText() method compiles and runs without issue. The method correctly
checks that the mark() method is supported before attempting to use it. Based on the
implementation with reset(), the pointer is in the same location before/after the if-then
statement. On the other hand, the sendText() method does not compile. The skip()
method is defined on InputStream and Reader, not OutputStream and Writer, making
Option D the correct answer. If this line was removed, the rest of the code would compile
and run without issue, printing You up? at runtime and making Option A the correct
answer.
|
40. B. The class compiles and runs without issue, so Option D is incorrect. The class defines
three variables, only one of which is serializable. The first variable, chambers, is serializable,
with the value 2 being written to disk and then read from disk. Note that constructors
and instance initializers are not executed when a class is deserialized. The next variable,
size, is transient. It is discarded when it is written to disk, so it has the default object
value of null when read from disk. Finally, the variable color is static, which means
it is shared by all instances of the class. Even though the value was RED when the instance
was serialized, this value was not written to disk, since it was not part of the instance. The
constructor call new Value() between the two try-with-resources blocks sets this value to
BLUE, which is the value printed later in the application. For these reasons, the class prints
2,null,BLUE, making Option B the correct answer.
|
1. C. A symbolic link is a file that contains a reference to another file or directory within the
file system, making Options A and B incorrect. Further, there is no such thing as an irregular
file. Option C is the correct answer because a regular file is not a directory and contains
content, unlike a symbolic link or resource. Option D is also incorrect because all symbolic
links are stored as files, not directories, even when their target is a directory.
|
2. C. The NIO.2 Path interface contains the methods getRoot() and toRealPath(). On
the other hand, the method isDirectory() is found in the NIO.2 Files class, while the
method listFiles() is found in the java.io.File class. For these reasons, Option C is
the correct answer.
|
3. A. The code does not compile because there is no NIO.2 class File that contains an
isHidden() method, making Option A the correct answer. There is a java.io.File class, but
that does not contain an isHidden() method either. The correct call is Files.isHidden().
Remember to check File vs. Files as well as Path vs. Paths on the real exam. If the correct
method call was used, the program would print Found!, and Option C would be the correct
answer.
|
4. D. A breadth-first traversal is when all elements of the same level, or distance from the
starting path, are visited before moving on to the next level. On the other hand, a depthfirst
traversal is when each element’s entire path, from start to finish, is visited before moving
onto another path on the same level. Both walk() and find() use depth-first traversals,
so Option D is the correct answer.
|
5. A. Reading an attribute interface is accomplished in a single trip to the underlying file
system. On the other hand, reading multiple file attributes using individual Files methods
requires a round-trip to the file system for each method call. For these reasons, Option
A is the correct answer. Option B is incorrect because nothing guarantees it will perform
faster, especially if the Files method is only being used to read a single attribute. For multiple
calls, it is expected to be faster, but the statement uses the word guarantees, which is
incorrect. Option C is also incorrect because both have built-in support for symbolic links.
Finally, Option D is incorrect because this discussion has nothing to do with memory leaks.
|
6. B. First off, the class compiles without issue. It is not without problems, though. The
Files.isSameFile() method call on line j1 first checks if the Path values are equivalent in
terms of equals(). One is absolute and the other is relative, so this test will fail. The
isSameFile() method then moves on to verify that the two Path values reference the same file
system object. Since we know the directory does not exist, the call to isSameFile() on line j1
will produce a NoSuchFileException at runtime, making Option B the correct answer.
|
7. B. A cycle is caused when a path contains a symbolic link that references the path itself, or
a parent of the parent, triggering an infinitely deep traversal. That said, Files.walk() does
not follow symbolic links by default. For this reason, the cycle is never activated, and the code
would print a number at runtime, making Option B the correct answer. If the FOLLOW_LINKS
enum value was used in the call to Files.walk(), then it would trigger a cycle resulting in a
FileSystemLoopException at runtime, and Option A would be the correct answer.
|
8. B. The methods length() and getLength() do not exist in the Files class, making
Options A and C incorrect. Recall that the java.io.File method retrieves the size of a
file on disk. The NIO.2 Files class includes the Files.size() method to accomplish this
same function. For this reason, Option B is the correct answer.
|
9. D. The code compiles without issue, making Option C incorrect. Even though tricks
would be dropped in the normalized path /bag/of/disappear.txt, there is no
normalize() call, so path.subpath(2,3) returns tricks on line 5. On line 6,
the call to getName() throws an IllegalArgumentException at runtime. Since
getName() is zero-indexed and contains only one element, the call on line 6 throws an
IllegalArgumentException, making Option D the correct answer. If getName(0) had
been used instead of getName(1), then the program would run without issue and print
/home/tricks, and Option A would have been the correct answer.
|
10. A. The NIO.2 Files class contains the method isSameFile(). The methods length()
and mkdir() are found in java.io.File, with the NIO.2 equivalent versions being
Files.size() and Files.createDirectory(), respectively. In addition, the relativize()
method is found in NIO.2 Path, not Files. Since only isSameFile() is found in NIO.2
Files, Option A is the correct answer.
|
11. B. First off, the code compiles without issue, so Option D is incorrect. The enum value
REPLACE_EXISTING does not use a type, although this compiles correctly if a static
import of StandardCopyOption is used. The AtomicMoveNotSupportedException in
Option A is only possible when the ATOMIC_MOVE option is passed to the move() method.
Similarly, the FileAlreadyExistsException in Option C is only possible when the
REPLACE_EXISTING option is not passed to the move() method. That leaves us with the
correct answer of Option B. A DirectoryNotEmptyException can occur regardless of the
options passed to the Files.move() method.
|
12. D. The Path method getFileName() returns a Path instance, not a String. For this reason,
the code does not compile, regardless of which line of code is inserted into the blank,
making Option D the correct answer. Statements I and III are two valid ways to create a
Path instance. If the method was updated to use Path as the return type, then Option B
would be the correct answer. Statement II would cause the method to not compile, because
Path is an interface and requires a class to be instantiated.
|
13. A. The code compiles without issue, but that’s about it. The class may throw an exception
at runtime, since we have not said whether or not the source file exists nor whether the
target file already exists, is a directory, or is write-protected. For these reason, Option B is
incorrect. Option C is also incorrect because the implementation is a flawed copy method.
On a regular file, the code will copy the contents but the line breaks would be missing in
the target file. In order to correctly copy the original file, a line break would have to be
written after each time temp is written. Since it is the only correct statement, Option A is
the correct answer.
|
14. C. First off, there is no Files.readLines() method, making Options B and D immediately
incorrect. The Files.readAllLines() method returns a List<String>, while the
Files.lines() method returns a Stream<String>. For this reason, Option C is the correct
answer, and Option A is incorrect.
|
15. A. The program compiles and runs without issue, making Options C and D incorrect.
Like String instances, Path instances are immutable. For this reason, the resolve()
operation on line 7 has no impact on the lessTraveled variable. Since one Path ends with
/spot.txt and the other does not, they are not equivalent in terms of equals(), making
Option A the correct answer. If lines 6 and 7 were combined, such that the result of the
resolve() operation was stored in the lessTraveled variable, then normalize() would
reduce lessTraveled to a Path value that is equivalent to oftenTraveled, making Option
B the correct answer.
|
16. C. Options A, B, and D are each advantages of using NIO.2. As you may remember, using
an attribute view to read multiple attributes at once is more efficient than a single attribute
call since it involves fewer round trips to the file system. Option C is the correct answer.
Neither API provides a single method to delete a directory tree.
|
17. C. The Files.delete() method has a return type of void, not boolean, resulting in
a compilation error and making Option C the correct answer. There is another method,
Files.deleteIfExists(), which returns true if the file is able to be deleted. If it was used
here instead, the file would compile and print a list of true values, making Option A the
correct answer. As stated in the description, the directory tree is fully accessible, so none of
the Files.deleteIfExists() would return false.
|
18. D. First off, DosFileAttributes and PosixFileAttributes extend
BasicFileAttributes, which means they are compatible with the readAttributes()
method signature. Second, they produce instances that inherit the interface
BasicFileAttributes, which means they can be assigned to a variable b of type
BasicFileAttributes without an explicit cast. For this reason, all three interfaces
are permitted, and Option D is the correct answer.
|
19. D. The relativize() method requires that both path values be absolute or relative. Based
on the details provided, p1 is a relative path, while p2 is an absolute path. For this reason,
the code snippet produces an exception at runtime, making Option D the correct answer.
If the first path was modified to be absolute by dropping the leading dot (.) in the path
expression, then the output would match the values in Option A.
|
20. C. First off, p2 is an absolute path, which means that p1.resolve(p2) just returns p2. For
this reason, Option B is incorrect. Since p1 is a relative path, it is appended onto p2, making
Option C correct and Option A incorrect.
|
21. B. The code does not compile because Files.list() returns a Stream<Path>, not a
List<Path>, making Option B the correct answer. Note that java.io.File does include
a list() method that returns an array of String values and a listFiles() method that
returns an array of File values, but neither is applicable here.
|
22. C. For this problem, remember that the path symbols can be applied to simplify the path
before needing to apply any symbolic links in the file system. The paths in Options A and
B can both be reduced from /objC/bin/../backwards/../forward/Sort.java and
/objC/bin/../forward/./Sort.java, respectively, to /objC/forward/Sort.java just
using the path symbols. Because of the symbolic link, this references the same file as
/java/Sort.java. For these reasons, Options A and B match our target path.
Option C can be reduced from /objC/bin/../java/./forward/Sort.java to
/objC/java/forward/Sort.java, which does not match the desired path for the file. The
symbolic link is not followed since it exists in the /objC directory, not in the /objC/java
directory. This causes a stack trace to be printed at runtime since the path does
not exist, making Option C the correct answer. Option D can be reduced from
/objC/bin/../../java/Sort.java to /java/Sort.java, which matches the target path
without using the symbolic link.
|
23. B. We need to empty the /objC directory before we can delete it. First, the Heap.exe file
would have to be deleted before the bin directory could be removed, for a total of two
calls to Files.delete(). Next, the Heap.m file is easily deleted with a single call to
Files.delete(). Calling Files.delete() on the symbolic link forward deletes the link
itself and leaves the target of the symbolic link intact. With a total of four calls, Option B is
the correct answer. Option A is incorrect because Java requires directories to be empty before
they can be deleted. Option C is also incorrect. It might make sense if Files.delete()
traversed symbolic links on a delete, but since this is not the case, it is an incorrect answer.
Option D is incorrect because there is no Files.deleteSymbolicLink() method defined in
the Java NIO.2 API.
|
24. C. Since System.out is a PrintStream that inherits OutputStream and implements
Closeable, line y1 compiles without issue. On the other hand, the Files.copy()
does not compile because there is no overloaded version of Files.copy() that takes an
OutputStream as the first parameter. For this reason, Option C is the correct answer. If
the order of the arguments in the Files.copy() call was switched, then the code would
compile and print the contents of the file at runtime, making Option D the correct answer.
|
25. B. To begin with, the BasicFileAttributeView class contains methods to read and write
file data, while the BasicFileAttributes class only contains methods to read file data.
The advantage of using a BasicFileAttributeView is to also modify file data, so Option
D is incorrect. Next, The BasicFileAttributeView does not include a method to modify
the hidden attribute. Instead, a DosFileAttributeView is required, making Option A
incorrect. Option B is the correct answer because BasicFileAttributeView includes a
setTimes() method to modify the file date values. Finally, Option C is incorrect because
both read file information in a single round-trip.
|
26. A. Trick question! The code does not compile, therefore no Path values are printed, and
Option A is the correct answer. The key here is that toRealPath() interacts with the file
system and therefore throws a checked IOException. Since this checked exception is not
handled inside the lambda expression, the class does not compile. If the lambda expression
was fixed to handle the IOException, then the expected number of Path values printed
would be six, and Option C would be the correct answer. A maxDepth value of 1 causes the
walk() method to visit two total levels, the original /flower and the files it contains.
|
27. D. The first statement returns a null value, since the path .. does not have a parent. That
said, it does not throw an exception at runtime, since it is not operated upon. The second
and third statements both return paths representing the root (/) at runtime. Remember
that calling getRoot() on a root path returns the root path. The fourth statement throws a
NullPointerException at runtime since getRoot() on a relative path returns null, with
the call to getParent() triggering the exception. Since the fourth statement is the only one
to produce a NullPointerException at runtime, Option D is the correct answer.
|
28. C. The code compiles without issue, so Options A and B are incorrect. While many of the
Files methods do throw IOException, most of the Path methods do not throw a checked
exception. The lack of indent of the return statement on line 6 is intentional and does not
prevent the class from compiling. If the input argument p is null or not an absolute path,
then the if-then clause is skipped, and it is returned to the caller unchanged. Alternatively,
if the input argument is an absolute path, then calling toAbsolutePath() has no effect. In
both cases, the return value of the method matches the input argument, making Option C
the correct answer.
|
29. D. Option A is incorrect because both methods take exactly one Path parameter, along
with an optional vararg of FileAttribute values. Option B is also incorrect because both
methods will throw a FileAlreadyExistsException if the target exists and is a file.
Option C is incorrect since both methods declare a checked IOException. The correct
answer is Option D. The method createDirectory() creates a single directory, while
createDirectories() may create many directories along the path value.
|
30. C. The toAbsolutePath() combines the current working directory and relative path to
form a /hail/../jungle/.././rain.. path. The normalize() method removes the path
symbols and leaves a /rain.. value. Note that the last double period (..) is not removed
because it is part of a path name and not interpreted as a path symbol. The result is then
appended with snow.txt and we are left with /rain../snow.txt, making Option C the
correct answer.
|
31. A. The program compiles and runs without issue, so Options C and D are incorrect. The process
breaks apart the inputted path value and then attempts to reconstitute it. There is only
one problem. The method call getName(0) does not include the root element. This results in
the repaired variable having a value of tissue/heart/chambers.txt, which is not equivalent
to the original path. The program prints false, and Option A is the correct answer.
|
32. B. Unlike Files.delete(), the Files.deleteIfExists() method does not throw an
exception if the path does not exist, making Option B the correct answer. Options A, C,
and D describe situations in which the Java process encounters a path in a state that cannot
be deleted. In each of these situations, an exception would be thrown at runtime.
|
33. D. The code does not compile because Path is an interface and does not contain a get()
method. Since the first line contains a compilation error, Option D is the correct answer. If
the code was corrected to use Paths.get(), then the output would be true false true,
and Option B would be the correct answer. The normalized path of both is /desert/sand.
doc, which means they would be equivalent, in terms of equals(), and point to the same
path in the file system. On the other hand, the non-normalized values are not equivalent, in
terms of equals(), since the objects represent distinct path values.
|
34. C. First off, the Files.getFileAttributeView() method requires a reference to a subclass
of FileAttributeView, such as BasicFileAttributeView.class. The parameter must also
be compatible with the reference assignment to vw. For these two reasons, this line of code
does not compile. Next, BasicFileAttributeView does not contain a creationTime()
method, so vw.creationTime() results in a compilation error. For the exam, remember that
view classes do contain access to attributes, but only through the readAttributes method,
such as vw.readAttributes().creationTime(). Since these are the only two lines that contain
compilation errors, Option C is the correct answer. Note that we purposely omitted all
import statements in this question, since this may happen on the real exam.
|
35. B. The program compiles and runs without issue, making Options C and D incorrect.
The first variable, halleysComet, is created with normalize() being applied right away,
leading to a value of stars/m1.meteor. The second variable, lexellsComet, starts with a
value of ./stars/../solar/. The subpath() call reduces it to its first two components,
./stars. The resolve() method then appends m1.meteor, resulting in a value of
./stars/m1.meteor. Finally, normalize() further reduces the value to stars/m1.meteor.
Since this matches our first Path, the program prints Same!, and Option B is the correct answer.
|
36. D. Both stream statements compile without issue, making Options A and B incorrect. The
two statements are equivalent to one another and print the same values at runtime. For this
reason, Option C is incorrect, and Option D is correct. There are some subtle differences in
the implementation besides one using walk() with a filter() and the other using find().
The walk() call does not include a depth limit, but since Integer.MAX_VALUE is the default
value, the two calls are equivalent. Furthermore, the walk() statement prints a stream of
absolute paths stored as String values, while the find() statement prints a stream of Path
values. If the input p was a relative path, then these two calls would have very different
results, but since we are told p is an absolute path, the application of toAbsolutePath()
does not change the results.
|
37. A. The code does not compile because Files.lines() and Files.readAllLines() throw a
checked IOException, which must be handled or declared. For the exam, remember that other
than a handful of test methods, like Files.exists(), most methods in the NIO.2 Files
class that operate on file system records declare an IOException. Now, if the exceptions were
properly handled or declared within the class, then jonReads() would likely take more time
to run. Like all streams, Files.lines() loads the contents of the file in a lazy manner, meaning
the time it takes for jenniferReads() to run is constant regardless of the file size. Note
the stream isn’t actually traversed since there is no terminal operation. Alternatively,
Files.readAllLines() reads the entire contents of the file before returning a list of String
values. The larger the file, the longer it takes jonReads() to execute. Since the original question
says the file is significantly large, then if the compilation problems were corrected,
jonReads() would likely take longer to run, and Option C would be the correct answer.
|
38. C. The first copy() method call on line q1 compiles without issue because it matches the
signature of a copy() method in Files. It also does not throw an exception because the
REPLACE_EXISTING option is used and we are told the file is fully accessible within the file
system. On the other hand, the second copy() method on line q2 does not compile. There
is a version of Files.copy() that takes an InputStream, followed by a Path and a list of
copy options. Because BufferedReader does not inherit InputStream, though, there is no
matching copy() method and the code does not compile. For this reason, Option C is the
correct answer.
|
39. C. The Files.isSameFile() throws a checked IOException. Even though accessing the
file system can be skipped in some cases, such as if the Path instances are equivalent in
terms of equals(), the method still declares IOException since it may access the file system
to determine if the two Path instances refer to the same file. For this reason, Option C
is the correct answer. The rest of the methods listed do not throw any checked exceptions,
even though they do access the file system, instead returning false if the file does not exist.
|
40. B. The program compiles and runs without issue, making Options C and D incorrect.
The program uses Files.list() to iterate over all files within a single directory. For
each file, it then iterates over the lines of the file and counts the sum. For this reason,
Option B is the correct answer. If the count() method had used Files.walk() instead of
Files.lines(), then the class would still compile and run, and Option A would be the
correct answer. Note that we had to wrap Files.lines() in a try-catch block because
using this method directly within a lambda expression without a try-catch block leads to
a compilation error.
|
1. A. The ExecutorService interface defines the two submit() methods shown in Options
C and D. Because ExecutorService extends Executor, it inherits the execute(Runnable)
method presented in Option B. That leaves us with the correct answer, Option A, because
ExecutorService does not define nor inherit an overloaded method execute() that takes
a Callable parameter.
|
2. B. The class compiles and runs without throwing an exception, making the first statement
true. The class defines two values that are incremented by multiple threads in parallel. The
first IntStream statement uses an atomic class to update a variable. Since updating an
atomic numeric instance is thread-safe by design, the first number printed is always 10, and
the second statement is true. The second IntStream statement uses an int with the preincrement
operator (++), which is not thread-safe. It is possible two threads could update
and set the same value at the same time, a form of race condition, resulting in a value less
than 5. For this reason, the third statement is not true. Since only the first two statements
are true, Option B is the correct answer.
|
3. C. Option A is incorrect, although it would be correct if Executors was replaced with
ExecutorService in the sentence. While an instance of ExecutorService can be obtained
from the Executors class, there is no method in the Executors class that performs a task
directly. Option B is also incorrect, but it would be correct if start() was replaced with
run() in the sentence. It is recommended that you override the run() method, not the
start() method, to execute a task using a custom Thread class. Option C is correct, and
one of the most common ways to define an asynchronous task. Finally, Option D is incorrect
because Options A and B are incorrect.
|
4. D. Trick question! ExecutorService does not contain any of these methods. In order
to obtain an instance of a thread executor, you need to use the Executors factory class.
For this reason, Option D is the correct answer. If the question had instead asked which
Executors method to use, then the correct answer would be Option C. Options A and B
do not allow concurrent processes and should not be used with a CyclicBarrier expecting
to reach a limit of five concurrent threads. Option C, on the other hand, will create
threads as needed and is appropriate for use with a CyclicBarrier.
|
5. C. CopyOnWriteArrayList makes a copy of the array every time it is modified, preserving
the original list of values the iterator is using, even as the array is modified. For this reason,
the for loop using copy1 does not throw an exception at runtime. On the other hand,
the for loops using copy2 and copy3 both throw ConcurrentModificationException
at runtime since neither allows modification while they are being iterated upon. Finally,
the ConcurrentLinkedQueue used in copy4 completes without throwing an exception at
runtime. For the exam, remember that the Concurrent classes order read/write access such
that access to the class is consistent across all threads and processes, while the synchronized
classes do not. Because exactly two of the for statements produce exceptions at runtime,
Option C is the correct answer.
|
6. C. Resource starvation is when a single active thread is perpetually unable to gain access
to a shared resource. Livelock is a special case of resource starvation, in which two or more
active threads are unable to gain access to shared resources, repeating the process over and
over again. For these reasons, Option C is the correct answer. Deadlock and livelock are
similar, although in a deadlock situation the threads are stuck waiting, rather than being
active or performing any work. Finally, a race condition is an undesirable result when two
tasks that should be completed sequentially are completed at the same time.
|
7. B. The class does not compile because the Future.get() on line 8 throws a checked
InterruptedException and ExecutionException, neither of which is handled nor
declared by the submitReports() method. If the submitReports() and accompanying
main() methods were both updated to declare these exceptions, then the application
would print null at runtime, and Option A would be the correct answer. For the exam,
remember that Future can be used with Runnable lambda expressions that do not have a
return value but that the return value is always null when completed.
|
8. A. Options B and C are both proper ways to obtain instances of ExecutorService.
Remember that newSingleThreadExecutor() is equivalent to calling newFixedThreadPool()
with a value of 1. Option D is the correct way to request a single-threaded
ScheduledExecutorService instance. The correct answer is Option A. The method
newFixedScheduledThreadPool() does not exist in the Executors class, although there is
one called newScheduledThreadPool().
|
9. A. The code compiles without issue but hangs indefinitely at runtime. The application
defines a thread executor with a single thread and 12 submitted tasks. Because only one
thread is available to work at a time, the first thread will wait endlessly on the call to
await(). Since the CyclicBarrier requires four threads to release it, the application
waits endlessly in a frozen condition. Since the barrier is never reached and the code
hangs, the application will never output Ready, making Option A the correct answer. If
newCachedThreadPool() had been used instead of newSingleThreadExecutor(), then the
barrier would be reached three times, and Option C would be the correct answer.
|
10. D. First off, BlockingDeque is incorrect since it is an interface, not a class. Next,
ConcurrentLinkedDeque does support adding elements to both ends of an ordered data
structure but does not include methods for waiting a specified amount of time to do so,
referred to as blocking. ConcurentSkipListSet is also incorrect, since its elements are
sorted and not just ordered, and it does not contain any blocking methods. That leaves the
correct answer, Option D. A LinkedBlockingDeque includes blocking methods in which
elements can be added to the beginning or end of the queue, while waiting at most a specified
amount of time.
|
11. A. The findAny() method can return any element of the stream, regardless of whether the
stream is serial or parallel. While on serial streams this is likely to be the first element in the
stream, on parallel streams the result is less certain. For this reason, Option A is the correct
answer. When applied to an ordered stream, the rest of the methods always produce the
same results on both serial and parallel streams. For this reason, these operations can be
costly on a parallel stream since it has to be forced into a serial process.
|
12. D. The static method Array.asList() returns a List instance, which inherits the
Collection interface. While the Collection interface defines a stream() and
parallelStream() method, it does not contain a parallel() method. For this reason,
the second stream statement does not compile, and Option D is the correct answer. If
the code was corrected to use parallelStream(), then the arrays would be consistently
printed in the same order, and Option C would be the correct answer. Remember that the
forEachOrdered() method forces parallel streams to run in sequential order.
|
13. D. To start with, the ForkJoinTask is the parent class of RecursiveAction and
RecursiveTask and does not contain a compute() method, neither abstract nor concrete,
making Options A and C automatically incorrect. The RecursiveTask class contains the
abstract compute() method that utilizes a generic return type, while the RecursiveAction
class contains the abstract compute() method that uses a void return type. For this reason,
Option D is the correct answer.
|
14. B. An accumulator in a serial or parallel reduction must be associative and stateless. In
a parallel reduction, invalid accumulators tend to produce more visible errors, where the
result may be processed in an unexpected order. Option A is not associative, since (a-b)-c
is not the same as a-(b-c) for all values a, b, and c. For example, using values of 1, 2, and
3 results in two different values, -4 and 2. Option C is not stateless, since a class or instance
variable i is modified each time the accumulator runs. That leaves us with Option B, which
is the correct answer since it is both stateless and associative. Even though it ignores the
input parameters, it meets the qualifications for performing a reduction.
|
15. B. The code does not compile because Callable must define a call() method, not a
run() method, so Option B is the correct answer. If the code was fixed to use the correct
method name, then it would complete without issue, printing Done! at runtime, and Option
A would be the correct answer.
|
16. C. Part of synchronizing access to a variable is ensuring that read/write operations are
atomic, or happen without interruption. For example, an increment operation requires reading
a value and then immediately writing it. If any thread interrupts this process, then data
could be lost. In this regard, Option C shows proper synchronized access. Thread 2 reads a
value and then writes it without interruption. Thread 1 then reads the new value and writes
it. The rest of the answers are incorrect because one thread writes data to the variable inbetween
another thread reading and writing to the same variable. Because a thread is writing
data to a variable that has already been written to by another thread, it may set invalid
data. For example, two increment operations running at the same time could result in one
of the increment operations being lost.
|
17. D. The code compiles and runs without issue. The two methods hare() and tortoise()
are nearly identical, with one calling invokeAll() and the other calling invokeAny(). The
key is to know that both methods operate synchronously, waiting for a result from one or
more tasks. Calling the invokeAll() method causes the current thread to wait until all
tasks are finished. Since each task is one second long and they are being executed in parallel,
the hare() method will take about one second to complete. The invokeAny() method
will cause the current thread to wait until at least one task is complete. Although the result
of the first finished thread is often returned, it is not guaranteed. Since each task takes one
second to complete, though, the shortest amount of time this method will return is after
one second. In this regard, the tortoise() method will also take about one second to
complete. Since both methods take about the same amount of time, either may finish first,
causing the output to vary at runtime and making Option D the correct answer. Note that
after this program prints the two strings, it does not terminate, since the ExecutorService
is not shut down.
|
18. B. ConcurrentSkipListMap implements the SortedMap interface, in which the keys
are kept sorted, making Option B the correct answer. While the other answers define
ordered data structures, none are guaranteed to be sorted. Remember, if you see
SkipList as part of a concurrent class name, it means it is sorted in some way, such as
a sorted set or map.
|
19. D. The synchronized block used in the getQuestion() method requires an object to
synchronize on. Without it, the code does not compile, and Option D is the correct answer.
What if the command was fixed to synchronize on the current object, such as using
synchronized(this)? Each task would obtain a lock for its respective object, then wait a
couple of seconds before requesting the lock for the other object. Since the locks are already
held, both wait indefinitely, resulting in a deadlock. In this scenario, Option A would be the
correct answer since a deadlock is the most likely result. We say most likely because even
with corrected code, a deadlock is not guaranteed. It is possible, albeit very unlikely, for the
JVM to wait five seconds before starting the second task, allowing enough time for the first
task to finish and avoiding the deadlock completely.
|
20. B. The ScheduledExecutorService does not include a scheduleAtFixedDelay()
method, so Option A is incorrect. The scheduleAtFixedRate() method creates a new
task for the associated action at a set time interval, even if previous tasks for the same
action are still active. In this manner, it is possible multiple threads working on the same
action could be executing at the same time, making Option B the correct answer. On
the other hand, scheduleWithFixedDelay() waits until each task is completed before
scheduling the next task, guaranteeing at most one thread working on the action is
active in the thread pool.
|
21. D. The application compiles, so Option B is incorrect. The stroke variable is threadsafe
in the sense that no write is lost since all writes are wrapped in a synchronized
method, making Option C incorrect. Even though the method is thread-safe, the value
of stroke is read while the threads may still be executing. The result is it may
output 0, 1000, or anything in-between, making Option D the correct answer. If the
ExecutorService method awaitTermination() is called before the value of stroke is
printed and enough time elapses, then the result would be 1000, and Option A would be
the correct answer.
|
22. B. A race condition is an undesirable result when two tasks that should be completed
sequentially are completed at the same time. The result is often corruption of data in some
way. If two threads are both modifying the same int variable and there is no synchronization,
then a race condition can occur with one of the writes being lost. For this reason,
Option B is the correct answer. Option A is the description of resource starvation. Options
C and D are describing livelock and deadlock, respectively.
|
23. A. The code compiles, so Option C is incorrect. The application attempts to count the elements
of the sheep array, recursively. For example, the first two elements are totaled by
one thread and added to the sum of the remainder of the elements in the array, which is
calculated by another thread. Unfortunately, the class contains a bug. The count value is
not marked static and not shared by all of the CountSheep subtasks. The value of count
printed in the main() menu comes from the first CountSheep instance, which does not
modify the count variable. The application prints 0, and Option A is the correct answer. If
count was marked static, then the application would sum the elements correctly, printing
10, and Option B would be the correct answer.
|
24. D. First off, certain stream operations, such as limit() or skip(), force a parallel
stream to behave it a serial manner, so Option A is incorrect. Option B is also incorrect.
Although some operations could take less time to execute, there is no guarantee any operation
will actually be faster. For example, the JVM may only allocate a single thread to
a parallel stream. In other words, parallel streams may improve performance but do not
guarantee it. Option C is incorrect because parallel stream operations are not synchronized.
It is up to the developer to provide synchronization or use a concurrent collection
if required. Finally, Option D is the correct answer. The BaseStream interface, which all
streams inherit, includes a parallel() method. Of course, the results of an operation
may change in the presence of a parallel stream, such as when a stateful lambda expression
is used, but they all can be made parallel.
|
25. A. The code compiles and runs without issue. The JVM will fall back to a single-threaded
process if all of the conditions for performing the parallel reduction are not met. The
stream used in the main() method is not parallel, but the groupingbyConcurrent()
method can still be applied without throwing an exception at runtime. Although performance
will suffer from not using a parallel stream, the application will still process
the results correctly. Since the process groups the data by year, Option A is the correct
answer.
|
26. A. The code compiles and runs without issue. The three-argument reduce() method
returns a generic type, while the one-argument reduce() method returns an Optional.
The concat1() method is passed an identity "a", which it applies to each element, resulting
in the reduction to aCataHat. The lambda expression in the concat2() method reverses the
order of its inputs, leading to a value of HatCat. Therefore, Option A is the correct answer.
|
27. A. The code compiles without issue, so Options B and C are incorrect. The f1 declaration
uses the version of submit() in ExecutorService, which takes a Runnable and returns
a Future<?>. The call f1.get() waits until the task is finished and always returns null,
since Runnable expressions have a void return type. The f2 declaration uses an overloaded
version of submit(), which takes a Callable expression and returns a generic Future
object. Since the double value can be autoboxed to a Double object, the line compiles
without issue with f2.get() returning 3.14159. For these reasons, Option A is the correct
answer. Option D is incorrect because no exception is expected to be thrown at runtime.
|
28. C. The class compiles without issue, making Options A and D incorrect. The class attempts
to create a synchronized version of a List<Integer>. The size() and addValue() help
synchronize the read/write operations. Unfortunately, the getValue() method is not
synchronized so the class is not thread-safe, and Option C is the correct answer. It is possible
that one thread could add to the data object while another thread is reading from
the object, leading to an unexpected result. Note that the synchronization of the size()
method is valid, but since ThreadSafeList.class is a shared object, this will synchronize
all instances of the class to the same object. This could result in a substantial performance
cost if enough threads are creating ThreadSafeList objects.
|
29. D. The post-decrement operator (––) decrements a value but returns the original value. It
is equivalent to the atomic getAndDecrement() method. The pre-increment operator (++)
increments a value and then returns the new value. It is equivalent to the incrementAndGet()
atomic operation. For these reasons, Option D is the correct answer.
|
30. B. When a CyclicBarrier goes over its limit, the barrier count is reset to zero. The application
defines a CyclicBarrier with a barrier limit of 5 threads. The application then
submits 12 tasks to a cached executor service. In this scenario, a cached thread executor
will use between 5 and 12 threads, reusing existing threads as they become available. In
this manner, there is no worry about running out of available threads. The barrier will then
trigger twice, printing five 1s for each of the sets of threads, for a total of ten 1s. For this
reason, Option B is the correct answer. The application then hangs indefinitely, as discussed
in the next question.
|
31. D. The application does not terminate successfully nor produce an exception at runtime,
making Options A and B incorrect. It hangs at runtime because the CyclicBarrier limit is
five, while the number of tasks submitted and awaiting activation is 12. This means that 2
of the tasks will be left over, stuck in a deadlocked state waiting for the barrier limit to be
reached but with no more tasks available to trigger it. For this reason, Option D is the correct
answer. If the number of tasks was a multiple of the barrier limit, such as 10 instead of 12,
then the application will still hang because the ExecutorService is never shut down. The
isShutdown() in the application finally block does not trigger a shutdown. Remember that
it is important to shut down an ExecutorService after you are finished with it, else it can
prevent a program from terminating. In this case, Option C would be the correct answer.
|
32. C. The code does not compile because the blocking methods offerLast() and pollFirst()
each throw a checked InterruptedException that are not handled by the lambda expressions,
so Option C is the correct answer. If the lambda expressions were wrapped with
try-catch blocks, then the process would first add all items to the queue, then remove them
all of them, resulting in an output of 0. In this case, Option A would be the correct answer.
Even though the tasks are completed in parallel, each stream does not terminate until all
tasks are done. Note that 10 seconds is more than enough time under normal circumstances
to add/remove elements from the queue.
|
33. A. First of all, the for loops using copy1 and copy4 both throw
ConcurrentModificationException at runtime since neither allows modification while they
are being iterated upon. Next, CopyOnWriteArrayList makes a copy of the array every time
it is modified, preserving the original list of values the iterator is using, even as the array is
modified. For this reason, the for loop using copy2 completes without throwing an exception
or creating an infinite loop. Finally, the ConcurrentLinkedDeque used in copy3 completes
without producing an exception or infinite loop. The Concurrent collections order read/write
access such that access to the class is consistent across all threads and processes, even iterators.
Because the values are inserted at the head of the queue using push() and the underlying data
structure is ordered, the new values will not be iterated upon and the loop finishes. Since none
of the for statements produce an infinite loop at runtime, Option A is the correct answer. If
push() had been used instead of offer() in the third loop, with new values being inserted at
the tail of the queue instead of at the head, then the for loop would have entered an infinite
loop, and Option B would be the correct answer.
|
34. B. Options A, C, and D are the precise requirements for Java to perform a concurrent
reduction using the collect() method, which takes a Collector argument. Recall
from your studies that a Collector is considered concurrent and unordered if it has the
Collector.Characteristics enum values CONCURRENT and UNORDERED, respectively.
Option B is the correct answer because elements of a stream are not required to implement
Comparable in order to perform a parallel reduction.
|
35. D. The class compiles and runs without issue, making Options A and B incorrect. The
purpose of the fork/join framework is to use parallel processing to complete subtasks across
multiple threads concurrently. Unfortunately, calling the compute() method inside of an
existing compute() does not spawn a new thread. The result is that this task is completed
using a single thread, despite a pool of threads being available. For this reason, Option D is
the correct answer. In order to properly implement the fork/join framework, the compute()
method would need to be rewritten. The f1.compute() call should be replaced with
f1.fork() to spawn a separate task, followed by f2.compute() to process the data on the
current thread, and ending in f1.join() to retrieve the results of the first task completed
while f2.compute() was being processed. If the code was rewritten as described, then
Option C would be the correct answer.
|
36. D. The shutdown() method prevents new tasks from being added but allows existing
tasks to finish. In addition to preventing new tasks from being added, the shutdownNow()
method also attempts to stop all running tasks. Neither of these methods guarantee any
task will be stopped, making Option D the correct answer. Option C is incorrect because
there is no halt() method in ExecutorService.
|
37. B. First off, the class uses a synchronized list, which is thread-safe and allows modification
from multiple threads, making Option D incorrect. The process generates a list of numbers
from 1 to 5 and sends them into a parallel stream where the map() is applied, possibly out
of order. This results in elements being written to db in a random order. The stream then
applies the forEachOrdered() method to its elements, which will force the parallel stream
into a single-threaded state. At runtime, line p1 will print the results in order every time
as 12345. On the other hand, since the elements were added to db in a random order, the
output of line p2 is random and cannot be predicted ahead of time. Since the results may
sometimes be the same, Option B is the correct answer. Part of the reason that the results
are indeterminate is that the question uses a stateful lambda expression, which based on
your studies should be avoided in practice!
|
38. C. The program compiles and does not throw an exception at runtime, making Options
B and D incorrect. The class attempts to add and remove values from a single cookie
variable in a thread-safe manner but fails to do so because the methods deposit() and
withdrawal() synchronize on different objects. The instance method deposit() synchronizes
on the bank object, while the static method withdrawal() synchronizes on
the static Bank.class object. Even though method calls of the same type are protected,
calls across the two different methods are not. Since the compound assignment operators
(+=) and (-=) are not thread-safe, it is possible for one call to modify the value of cookies
while the other is already operating on it, resulting in a loss of information. For this reason,
the output cannot be predicted, and Option C is the correct answer. If the two sets
of calls were properly synchronized on the same object, then the cookies variable would
be protected from concurrent modifications, and Option A would be the correct answer.
|
39. A. The code attempts to search for a matching element in an array recursively. While it
does not contain any compilation problems, it does contain an error. Despite creating
Thread instances, it is not a multi-threaded program. Calling run() on a Thread runs
the process as part of the current thread. To be a multi-threaded execution, it would need
to instead call the start() method. For this reason, the code completes synchronously,
waiting for each method call to return before moving on to the next and printing true
at the end of the execution, making Option A the correct answer. On the other hand, if
start() had been used, then the application would be multi-threaded but then the result
may not be ready by the time the println() method is called, resulting in a value that
cannot be predicted ahead of time. In this case, Option D would be the correct answer.
|
40. C. Line 13 does not compile because the execute() method has a return type of void,
not Future. Line 15 does not compile because scheduleAtFixedRate() requires
four arguments that include an initial delay and period value. For these two reasons,
Option C is the correct answer.
|
1. C. Connection is an interface for communicating with the database. Driver is tricky
because you don’t write code that references it directly. However, you are still required to
know it is a JDBC interface. DriverManager is used in JDBC code to get a Connection.
However, it is a concrete class rather than an interface. Since Connection and Driver are
JDBC interfaces, Option C is correct.
|
2. D. Database-specific implementation classes are not in the java.sql package. The implementation
classes are in database drivers and have package names that are specific to the
database. Therefore, Option D is correct. The Driver interface is in the java.sql package.
Note that these classes may or may not exist. You are not required to know the names of
any database-specific classes, so the creators of the exam iare free to make up names.
|
3. D. All JDBC URLs begin with the protocol jdbc followed by a colon as a delimiter. Option
D is the only one that does both of these, making it the answer.
|
4. A. The Driver interface is responsible for getting a connection to the database, making
Option A the answer. The Connection interface is responsible for communication with the
database but not making the initial connection. The Statement interface knows how to run
the SQL query, and the ResultSet interface knows what was returned by a SELECT query.
|
5. B. The requirement to include a java.sql.Driver file in the driver jar file was introduced
in JDBC 4.0. A 3.0 driver is allowed, but not required, to include this file. JDBC 3.0 also
requires a call to Class.forName(). As a result, Option B best fills in the blanks.
|
6. C. Connection is an interface. Since interfaces do not have constructors, Option D is
incorrect. The Connection class doesn’t have a static method to get a Connection either,
making Option A incorrect. The Driver class is also an interface without static methods,
making Option B incorrect. Option C is the answer because DriverManager is the class
used in JDBC to get a Connection.
|
7. B. The DriverManager.getConnection() method can be called with just a URL. It is also
overloaded to take the URL, username, and password, making Option B correct.
|
8. D. CallableStatement and PreparedStatement are interfaces that extend the Statement
interface. You don’t need to know that for the exam. You do need to know that a database
driver is required to provide the concrete implementation class of Statement rather than
the JDK. This makes Option D correct. Note that while Derby is provided with Java, it is in
a separate jar from the “main” JDK.
|
9. C. A JDBC URL has three components separated by colons. All three of these URLs meet
those criteria. For the data after the component, the database driver specifies the format.
Depending on the driver, this might include an IP address and port. Regardless, it needs
to include the database name or alias. I and II could both be valid formats because they
mention the database box. However, III only has an IP address and port. It does not have a
database name or alias. Therefore III is incorrect and Option C correct.
|
10. C. The requirement to include a java.sql.Driver file in the driver jar was introduced
in JDBC 4.0. A call to Class.forName() was made optional with JDBC 4.0. As a result,
Option C best fills in the blanks.
|
11. A. Scroll sensitive is a result set type parameter, and updatable is a concurrency mode. The
result set type parameter is passed to createStatement() before the concurrency mode. If
you request options that the database driver does not support, it downgrades to an option
it does support rather than throwing an exception. Statements I and III are correct, making
Option A the answer.
|
12. B. JDBC 4.0 allows, but does not require, a call to the Class.forName() method. However,
since it is in the code, it needs to be correct. This method is expecting a fully qualified
class name of a database driver, not the JDBC URL. As a result, the Class.forName()
method throws a ClassNotFoundException, and Option B is the answer.
|
13. B. There are two ResultSet concurrency modes: CONCUR_READ_ONLY and
CONCUR_UPDATABLE. All database drivers support read-only result sets, but not all support
updatable ones. Therefore, Option B is correct.
|
14. D. This code is missing a call to rs.next(). As a result, rs.getInt(1) throws a
SQLException with the message Invalid cursor state – no current row. Therefore,
Option D is the answer.
|
15. D. The execute() method is allowed to run any type of SQL statements. The
executeUpdate() method is allowed to run any type of the SQL statement that returns
a row count rather than a ResultSet. Both DELETE AND UPDATE SQL statements are
allowed to be run with either execute() or executeUpdate(). They are not allowed to be
run with executeQuery() because they do not return a ResultSet. Therefore, Option D is
the answer.
|
16. C. Connection is an interface rather than a concrete class. Therefore, it does not
have a constructor and line s2 does not compile. As a result, Option C is the answer.
Option A would be the answer if the code new Connection() was changed to
DriverManager.getConnection().
|
17. A. There are three ResultSet type options: TYPE_FORWARD_ONLY, TYPE_SCROLL_INSENSITIVE,
and TYPE_SCROLL_SENSITIVE. Only one of these is in the list, making Option A correct.
|
18. B. Unlike arrays, JDBC uses one-based indexes. Since num_pages is in the second column,
the parameter needs to be 2, ruling out Options A and C. Further, there is not a method
named getInteger() on the ResultSet interface, ruling out Option D. Since the proper
method is getInt(), Option B is the answer.
|
19. D. Option A does not compile because you have to pass a column index or column name to
the method. Options B and C compile. However, there are not columns named 0 or 1. Since
these column names don’t exist, the code would throw a SQLException at runtime. Option
D is correct as it uses the proper column name.
|
20. B. The parameters to createStatement() are backward. However, they still compile
because both are of type int. This means the code to create the Statement does compile,
and Option A is incorrect. Next comes the code to create the ResultSet. While both
execute() and executeQuery() can run a SELECT SQL statement, they have different
return types. Only executeQuery() can be used in this example. The code does not compile
because the execute() method returns a boolean, and Option B is correct. If this was
fixed, Option D would be the answer because rs.next() is never called.
|
21. D. Since this code opens Statement using a try-with-resources, Statement gets closed
automatically at the end of the block. Further, closing a Statement automatically closes a
ResultSet created by it, making Option D the answer. Remember that you should close
any resources you open in code you write.
|
22. C. Option A is incorrect because Driver is an interface while DriverManager is a concrete
class. The inverse isn’t true either; DriverManager doesn’t implement Driver. Option B
is incorrect because the Connection implementation comes from the database driver jar.
Option C is correct. You can turn off auto-commit mode, but it defaults to on. Option D is
incorrect because you need to call rs.next() or an equivalent method to point to the first
row.
|
23. C. The requirement to include a java.sql.Driver file in the META-INF directory was
introduced in JDBC 4.0. Older drivers are not required to provide it, making Option B
incorrect. A file named jdbc.driver has never been a requirement. Option A is incorrect
and is simply here to trick you. All drivers are required to implement the Connection interface,
making Option C the answer.
|
24. D. First, rs.next() moves the cursor to point to the first row, which contains the number
10. Line q1 moves the cursor to immediately before the first row. This is the same as the
position it was in before calling rs.next() in the first place. It is a valid position but isn’t
a row of data. Line q2 tries to retrieve the data at this position and throws a SQLException
because there isn’t any data, making Option D the answer.
|
25. B. This code shows how to properly update a ResultSet. Note that it calls updateRow()
so the changes get applied in the database. This allows the SELECT query to see the changes
and output 10. Option B is correct. Remember that unlike this code, you should always
close a ResultSet when you open it in real code.
|
26. C. There is no ResultSet method named prev(). Therefore, the code doesn’t compile, and
Option C is correct. If prev() was changed to previous(), the answer would be Option B
because updateRow() is never called. Remember that unlike this code, you should always
close a ResultSet when you open it in real code.
|
27. D. While the code turns off automatic committing, there is a commit() statement after the
first two inserts that explicitly commits those to the database. Then automatic commit is
turned back on and the third commit is made, making Option D the answer.
|
28. A. The count(*) function in SQL always returns a number. In this case, it is the number
zero. This means line r1 executes successfully because it positions the cursor at that row.
Line r2 also executes successfully and prints 0, which is the value in the row. Since the code
runs successfully, Option A is the answer.
|
29. B. The cursor starts out at position zero, right before the first row. Line 6 moves the cursor
to position five. Line 7 tries to move the cursor ten rows before that position which is row
negative five. Since you can’t move back before row zero, the cursor is at row zero instead.
Then line 8 moves the cursor forward five positions from row zero, leaving it at row five
and making Option B the answer.
|
30. C. JDBC 4.0 allows, but does not require, a call to the Class.forName() method. Since
the database does not exist, DriverManager.getConnection() throws a SQLException,
and Option C is the answer.
|
31. D. When running a query on a Statement, Java closes any already open ResultSet
objects. This means that rs1 is closed on line 8. Therefore, it throws a SQLException on
line 9 because we are trying to call next() on a closed ResultSet, and Option D is correct.
|
32. B. The code turns off automatic committing, so the inserts for red and blue are not immediately
made. The rollback() statement actually prevents them from being committed.
Then automatic commit is turned back on and one insert is made, making Option B the
answer.
|
33. A. This code correctly obtains a Connection and Statement. It then runs a query, getting
back a ResultSet without any rows. The rs.next() call returns false, so nothing is
printed, making Option A correct.
|
34. B. Since the ResultSet type allows scrolling, the code does not throw a SQLException
at runtime. Immediately after getting the ResultSet, the cursor is positioned at the end
immediately after Scott’s row. The next two lines try to move forward one row. This has
no effect since the cursor is already at the end. Then previous() moves the cursor to point
to the last row, which is Scott’s row. The second previous() call moves the cursor up one
more row to point to Elena’s row, making Option B the answer.
|
35. B. When passing a negative number to absolute(), Java counts from the end instead of
the beginning. The last row is Scott’s row, so the first print statement outputs Scott. When
passing a positive number to absolute(), Java counts from the beginning, so Jeanne is
output. Therefore, Option B is correct.
|
36. D. When creating the Statement, the code doesn’t specify a result set type. This means it
defaults to TYPE_FORWARD_ONLY. The absolute() method can only be called on scrollable
result sets. The code throws a SQLException, making Option D the answer.
|
37. B. This code does not compile because the ResultSet options need to be supplied when
creating the Statement object rather than when executing the query. Since the code does
not compile, Option B is correct.
|
38. B. The code turns off automatic committing, so the inserts for red and blue are not immediately
made. The rollback() statement says to prevent any changes made from occurring.
This gets rid of red and blue. Then automatic commit is turned back on and the one insert
for green is made. The final rollback has no effect since the commit was automatically
made. Since there was one row added, Option B is the answer.
|
39. D. Line 18 doesn’t compile because beforeFirst() has a void return type. Since the
code doesn’t compile, it doesn’t print true at all, and Option D is correct. If line 18 called
rs.beforeFirst() without trying to print the result, Option B would be the answer. All
the other statements are valid and return true.
|
40. B. When manually closing database resources, they should be closed in the reverse order
from which they were opened. This means that the ResultSet object is closed before the
Statement object and the Statement object is closed before the Connection object. This
makes Option B the answer.
|
1. D. Oracle defines a locale as a geographical, political, or cultural region. Time zones often
span multiple locales, so Option D is correct.
|
2. C. Currencies vary in presentation by locale. For example, 9,000 and 9.000 both represent
nine thousand, depending on the locale. Similarly, for dates, 01-02-1991 and 02-01-1991
represent January 2, 1991, depending on the locale. This makes Option C the answer.
|
3. C. The Locale object provides getDefault() and setDefault() methods for working
with the default locale, so Option C is correct. There is no get() method declared on
Locale.
|
4. A. Internationalization means the program is designed so it can be adapted for multiple
languages. By extracting the town names, this is exactly what has happened here, making
Option A correct. Localization means the program actually supports multiple locales.
There’s no mention of multiple locales here, so Option B is incorrect. Similarly, there is no
mention of multiple languages, making Option D incorrect. Finally, specialization is not a
term relevant to properties, making Option C incorrect.
|
5. A. The Properties class is a Map, making III correct. Hashtable and HashMap are concrete
classes rather than interfaces, so I and II are incorrect. While a Properties object is a
Hashtable, this is not an interface. Since only III is correct, Option A is the answer.
|
6. C. Java supports properties file resource bundles and Java class resource bundles. Properties
file resource bundles contain String keys and String values. Java class resource
bundles contain String keys and any type of classes as values. Since both are valid, Option
C is correct.
|
7. B. Calling Locale.setDefault() changes the default locale within the program. It does
not change any settings on the computer. The next time you run a Java program, it will
have the original default locale rather than the one you changed it to.
|
8. B. Line 18 prints the value for the property with the key mystery, which is bag. Line 19
prints a space. Line 20 doesn’t find the key more so it prints null. Therefore, it prints
bag null, and Option B is correct.
|
9. C. There is not a built-in class called JavaResourceBundle, making Options A and B
incorrect. The ListResourceBundle class is used to programmatically create a resource
bundle. It requires one method to be implemented named getContents(), making Option
D incorrect and Option C correct. This method returns a 2D array of key/value pairs.
|
10. A. When both a language and country code are present, the language code comes first. The
language code is in all lowercase letters and the country code is in all uppercase.
|
11. C. Java starts out by looking for a Java file with the most specific match, which is language
and country code. Since this is happening at runtime, it is looking for the corresponding file
with a .class extension. This matches Option C, making it the answer. If this file was not
found, Java would then look for a .properties file with the name, which is Option D. If
neither was found, it would continue dropping components of the name, eventually getting
to Options A and B in that order.
|
12. A. This class correctly creates a Java class resource bundle. It extends ListResourceBundle
and creates a 2D array as the property contents. Since count is an int, it is autoboxed
into an Integer. In the main() method, it gets the resource bundle without a locale and
requests the count key. Since Integer is a Java Object, it calls getObject() to get the
value. The value is not incremented each time because the getContents() method is only
called once. Therefore, Option A is correct.
|
13. A. A Locale can consist of a language only, making Option A correct. It cannot consist of
a country code without a language, so Option B is incorrect. Finally, if both a language and
country code are present, the language code is first, making Option C incorrect.
|
14. A. Java supports properties file resource bundles and Java class resource bundles. Properties
file resource bundles require String values, making Option B incorrect. Java class
resource bundles allow any type of classes as values. Since the question asks about defining
values, it is the .java source code rather than the .class bytecode file, making Option A
the answer.
|
15. C. At least one matching resource bundle must be available at the time of the call to
getBundle(). While the requested key determines which of the resource bundles is used, at
least one must exist simply to get the ResourceBundle reference, so Option C is the answer.
|
16. D. The Properties class implements Map. While the get() method, inherited from the
superclass, is available, it returns an Object. Since Object cannot be cast to String, it does
not compile, and Option D is the answer.
|
17. D. Java supports properties file resource bundles and Java class resource bundles. Both
require String as the key format, so Option D is the answer.
|
18. A. Java starts out by looking for a Java file with the most specific match, which is language
and country code. Since there is no such matching file, it drops the country code
and looks for a match by language code. Java looks for bytecode files before properties
files. Therefore, Option A is the answer. If it wasn’t present, Option B would be the
next choice. Options C and D would never be considered, as a locale doesn’t just have a
country code.
|
19. D. There is no get() method on Locale. You need to use a constructor or a predefined
Locale constant to obtain a Locale object. Therefore, Option D is the correct answer.
Option B is close in that Locale.ITALIAN does reference a Locale object. However, it
should not be passed to the nonexistent get() method.
|
20. A. This code creates a Map with two elements. Then it copies both key/value pairs to a
Properties object. This works because a Properties object is also a Map and therefore
has a put() method that takes Object parameters. Finally, the code gets the String property
values of both keys and prints hammer nail. Therefore, Option A is correct.
|
21. D. The code attempts to create a Java class resource bundle. However, the Type class does
not extend ListResourceBundle. It compiles, but throws an exception on line 9 because
no resource bundle is actually defined. Therefore, Option D is correct.
|
22. D. This code compiles and runs without exception, making Option D the answer. Line 3
uses a predefined Locale constant. Line 5 passes a language and country code for English
in Australia. Line 7 incorrectly passes capital letters as a language code. However, Java
automatically converts it to lowercase without throwing an exception. The three lines
printed by the code are ko, en_US and en.
|
23. C. Line 18 prints the value for the property with key mystery, which is bag. Line 19 prints
a space. Line 20 doesn’t find the key more so it uses the second parameter ? as the default
value. The code prints bag ?, so Option C is correct.
|
24. B. The getBundle() method matches Cars_fr_FR.properties since that is the requested
locale. The country key is in that properties file directly, so France is used as the value.
The engine key is not, so Java looks higher up in the hierarchy and finds it in the languagespecific
Cars_fr.properties file and uses moteur as the value. Therefore, Option B is correct.
Note that the default locale isn’t used.
|
25. D. The getBundle() method matches Cars_fr.properties. Since the requested locale of
French Canada is not available, it uses the language-specific locale of French. The engine
key is in that properties file directly, so moteur is retrieved as the value. However, we have
a problem getting the horses key. It is not in the hierarchy of Cars_fr.properties. It is
in the English properties file, but Java cannot look at the default locale if it found a match
with the requested locale. As a result, the code throws a MissingResourceException,
making Option D the answer.
|
26. A. The getBundle() method matches Cars_en.properties. Since the requested locale of
English Canada is not available, it uses the language-specific locale of English. The engine
key is in that properties file directly, so engine is retrieved as the value. The horses key is
also in that properties file, so 241 is used as the value, and Option A is the answer.
|
27. B. A ListResourceBundle is a Java class that provides key/value pairs. The values can
be any Java class type and can be created at runtime, making Options A and C false statements.
When you want to provide a language-specific resource bundle, an underscore and
the language code are added after the class name. Since Option B does not have an underscore,
it is a false statement. Since all three statements are false, Option D is the answer.
|
28. D. Since a Locale is passed when requesting the ResourceBundle, that Locale is used first
when looking for bundles. Since there isn’t a bundle called Colors_zh_CN.properties, Java
goes on to check for the language. Option D provides a match on language. If this was
not found, Java would go on to the default locale, eventually matching Option B. Since
country is not used without language, Options A and C would not be considered as
options.
|
29. B. This class correctly creates a Java class resource bundle. It extends
ListResourceBundle and creates a 2D array as the property contents. In the main()
method, it gets the resource bundle without a locale and requests the count key. Since this
is a Java Object, it calls getObject() to get the value and casts it to the correct type. Then
the getCount() method is called twice, incrementing each time, making Option B the correct
answer. Note that having a mutable object as a property is a bad practice.
|
30. D. Line 10 is incorrect. It tries to get a bundle named Type. However, this code is in a
package and named keyboard.Type. Therefore, a MissingResourceException is thrown,
and Option D is correct.
|
31. B. Since no locale is specified, the code tries to find a bundle matching the default
locale. While none of the resource bundles match English United States, two do match
the language English. The Java class one is used since it is present. Since the Java
resource bundle for English doesn’t have a key wheels, we go up to the parent resource
bundle. The default Java resource bundle does have the key wheels with the value 4, so
Option B is correct.
|
32. D. Since no locale is specified, the code tries to find a bundle matching the default locale.
Two resource bundles match the language English. The Java class one is used since it is
present. However, it does not contain a key color, nor does its parent. Java does not
allow looking in a properties file resource bundle once it has matched a Java class resource
bundle. Therefore, it throws a MissingResourceBundleException, and Option D is the
answer.
|
33. B. Since no locale is specified, the code tries to find a bundle matching the default locale.
None of the resource bundles match the language, so the default resource bundle is used.
The default Java resource bundle is used since it is present and has the key wheels with the
value 4. Therefore, Option B is correct.
|
34. A. Since a locale is passed when requesting the ResourceBundle, that locale is used first
when looking for bundles. Since there isn’t a bundle for that locale, Java checks for the
language zh. There still isn’t a match, so Java goes on to check for the default locale. Still
no match. Next Java checks the language of the default locale and finally finds a match in
Option A. If that match wasn’t found, Java would match on Option B, which is the default
bundle. Option C would never be checked since the base name is Red rather than the
requested Color.
|
35. C. A Properties object implements Map. This makes the get() method available.
Properties also defined a getProperty() method. Therefore, both methods can fill in the
blank, and Option C is correct.
|
36. B. This code compiles and runs without issue. It creates a default Java class resource bundle.
Lines 5 through 7 show it has one key and one ArrayList value. Line 9 gets a reference
to the resource bundle. Lines 10 through 16 retrieve the ArrayList and add six values to
it. Since this is a reference, line 17 gets the same object and prints the size of 6. Therefore,
Option B is correct.
|
37. B. The class on line p1 should be Properties rather than Property. As written it is incorrect
and does not compile, making Option B the answer.
|
38. C. ResourceBundle is an abstract class and uses a factory to obtain the right subclass.
Since a call to the constructor new ResourceBundle() does not compile, Option C is the
answer. If this was fixed, Option A would be the answer because getContents() is only
called once.
|
39. A. This code sets the default locale to English and then tries to get a resource
bundle for container in the pod package. It finds the resource bundle
pod.container_en.properties as the most specific match. Both keys are found in this
file, so Option A is the answer.
|
40. D. Option C is not a valid match for this resource bundle because the base name is Red
rather than the requested Colors. Options A and B are not valid matches because they
contain uppercase letters for the language code while Java requires lowercase. Since none
match, Option D is correct, and the code throws an exception at runtime.
