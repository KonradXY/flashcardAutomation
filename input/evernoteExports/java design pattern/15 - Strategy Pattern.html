<html>
<head>
  <title>Evernote Export</title>
  <basefont face="Segoe UI" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/308716 (en-US, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: Segoe UI;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="479"/>

<div>
<span><div><h2><span style="font-weight: bold;">15 - Strategy Pattern</span></h2><div><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 846px;"></col></colgroup><tbody><tr><td style="width: 846px; padding: 8px; border: 1px solid;"><div>D:   can you give the gof definition of the strategy pattern ?</div></td></tr><tr><td style="width: 846px; padding: 8px; border: 1px solid;"><div>R: Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from the clients that use it.</div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 846px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div>D:   can you show an uml diagram that explains the strategy pattern ?</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div>R: Before you proceed, let’s keep in mind the following points.</div><ul><li><div>The strategy pattern encourages you to use object composition instead of subclassing. So, it suggests you do <span style="font-style: italic;">not</span> override parent class behaviors in different subclasses. Instead, you put these behaviors in separate classes (called a <span style="font-style: italic;">strategy</span>) that share a common interface.</div></li><li><div>The client class only decides which algorithm to use; the context class does not decide that.</div></li><li><div>A context object contains reference variables for the strategy objects’ interface type. So, you can obtain different behaviors by changing the strategy in the context.</div></li></ul><div>In the following implementation, the Vehicle class is an abstract class that plays the role of a context. Boat and Aeroplane are two concrete implementations of the Vehicle class. You know that they are associated with different behaviors: one travels through water and the other one travels through air.</div><div>These behaviors are placed in two concrete classes: AirTransport and WaterTransport. These classes share a common interface, TransportMedium. So, these concrete classes are playing the role of the strategy classes where different behaviors are reflected through the transport() method implementations.</div><div>In the Vehicle class, there is a method called showTransportMedium() . Using this method, I am delegating the task to the corresponding behavior class. So, once you pick your strategy, the corresponding behavior can be invoked. Notice that in the Vehicle class, there is a method called commonJob(),which is not supposed to vary in the future, so its behavior is not treated as a volatile behavior.</div><div style="text-align: center;"><br/></div><div style="text-align: center;"><img src="15 - Strategy Pattern_files/Image.jpg" type="image/jpeg" data-filename="Image.jpg" style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; -webkit-font-smoothing: antialiased; border: 0px; height: 19.35em; max-width: 100%; vertical-align: middle; margin: 0px; padding: 2px;" width="624"/></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 846px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div>D:   can you show an implementation of the strategy pattern ?</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div>R: Here’s the implementation.</div><div><font face="Source Code Pro"><br/></font></div><div><font face="Source Code Pro">// Vehicle.java</font></div><div><font face="Source Code Pro">package jdp2e.strategy.demo;</font></div><div><font face="Source Code Pro">//Context class</font></div><div><font face="Source Code Pro">public abstract class Vehicle</font></div><div><font face="Source Code Pro">{</font></div><div><font face="Source Code Pro">   /*A context object contains reference variable/s for the strategy object/s interface type.*/</font></div><div><font face="Source Code Pro">   TransportMedium transportMedium;</font></div><div><font face="Source Code Pro">   public Vehicle()</font></div><div><font face="Source Code Pro">   {</font></div><div><font face="Source Code Pro">   }</font></div><div><font face="Source Code Pro">   public void showTransportMedium()</font></div><div><font face="Source Code Pro">   {</font></div><div><font face="Source Code Pro">       //Delegate the task to the //corresponding behavior class.</font></div><div><font face="Source Code Pro">       transportMedium.transport();</font></div><div><font face="Source Code Pro">   }</font></div><div><font face="Source Code Pro">   //The code that does not vary.</font></div><div><font face="Source Code Pro">   public void commonJob()</font></div><div><font face="Source Code Pro">   {</font></div><div><font face="Source Code Pro">       System.<span style="font-style: italic;">out</span>.println(&quot;We all can be used to transport&quot;);</font></div><div><font face="Source Code Pro">   }</font></div><div><font face="Source Code Pro">   public abstract void showMe();</font></div><div><font face="Source Code Pro">}</font></div><div><font face="Source Code Pro">// Boat.java</font></div><div><font face="Source Code Pro">package jdp2e.strategy.demo;</font></div><div><font face="Source Code Pro">public class Boat extends Vehicle</font></div><div><font face="Source Code Pro">{</font></div><div><font face="Source Code Pro">   public Boat()</font></div><div><font face="Source Code Pro">   {</font></div><div><font face="Source Code Pro">       transportMedium= new WaterTransport();</font></div><div><font face="Source Code Pro">   }</font></div><div><font face="Source Code Pro">   @Override</font></div><div><font face="Source Code Pro">   public void showMe() {</font></div><div><font face="Source Code Pro">       System.<span style="font-style: italic;">out</span>.println(&quot;I am a boat.&quot;);</font></div><div><font face="Source Code Pro">   }</font></div><div><font face="Source Code Pro">}</font></div><div><font face="Source Code Pro">// Aeroplane.java</font></div><div><font face="Source Code Pro">package jdp2e.strategy.demo;</font></div><div><font face="Source Code Pro">public class Aeroplane extends Vehicle</font></div><div><font face="Source Code Pro">{</font></div><div><font face="Source Code Pro">   public Aeroplane()</font></div><div><font face="Source Code Pro">   {</font></div><div><font face="Source Code Pro">       transportMedium= new AirTransport();</font></div><div><font face="Source Code Pro">   }</font></div><div><font face="Source Code Pro">   @Override</font></div><div><font face="Source Code Pro">   public void showMe() {</font></div><div><font face="Source Code Pro">       System.<span style="font-style: italic;">out</span>.println(&quot;I am an aeroplane.&quot;);</font></div><div><font face="Source Code Pro">   }</font></div><div><font face="Source Code Pro">}</font></div><div><font face="Source Code Pro">// TransportMedium.java</font></div><div><font face="Source Code Pro">package jdp2e.strategy.demo;</font></div><div><font face="Source Code Pro">public interface TransportMedium</font></div><div><font face="Source Code Pro">{</font></div><div><font face="Source Code Pro">   public void transport();</font></div><div><font face="Source Code Pro">}</font></div><div><font face="Source Code Pro">//WaterTransport.java</font></div><div><font face="Source Code Pro">package jdp2e.strategy.demo;</font></div><div><font face="Source Code Pro">//This class represents an algorithm/behavior .</font></div><div><font face="Source Code Pro">public class WaterTransport implements TransportMedium</font></div><div><font face="Source Code Pro">{</font></div><div><font face="Source Code Pro">   @Override</font></div><div><font face="Source Code Pro">   public void transport()</font></div><div><font face="Source Code Pro">   {</font></div><div><font face="Source Code Pro">       System.<span style="font-style: italic;">out</span>.println(&quot;I am transporting in water.&quot;);</font></div><div><font face="Source Code Pro">   }</font></div><div><font face="Source Code Pro">}</font></div><div><font face="Source Code Pro">//AirTransport.java</font></div><div><font face="Source Code Pro">package jdp2e.strategy.demo;</font></div><div><font face="Source Code Pro">//This class represents an algorithm/behavior.</font></div><div><font face="Source Code Pro">public class AirTransport implements TransportMedium</font></div><div><font face="Source Code Pro">{</font></div><div><font face="Source Code Pro">   @Override</font></div><div><font face="Source Code Pro">   public void transport()</font></div><div><font face="Source Code Pro">   {</font></div><div><font face="Source Code Pro">       System.<span style="font-style: italic;">out</span>.println(&quot;I am transporting in air.&quot;);</font></div><div><font face="Source Code Pro">   }</font></div><div><font face="Source Code Pro">}</font></div><div><font face="Source Code Pro">// StrategyPatternExample.java</font></div><div><font face="Source Code Pro">package jdp2e.strategy.demo;</font></div><div><font face="Source Code Pro">//Client code</font></div><div><font face="Source Code Pro">public class StrategyPatternExample {</font></div><div><font face="Source Code Pro">   public static void main(String[] args) {</font></div><div><font face="Source Code Pro">       System.<span style="font-style: italic;">out</span>.println(&quot;***Strategy Pattern Demo***&quot;);</font></div><div><font face="Source Code Pro">       Vehicle vehicleContext=new Boat();</font></div><div><font face="Source Code Pro">       vehicleContext.showMe();</font></div><div><font face="Source Code Pro">       vehicleContext.showTransportMedium();</font></div><div><font face="Source Code Pro">       System.<span style="font-style: italic;">out</span>.println(&quot;________&quot;);</font></div><div><font face="Source Code Pro">       vehicleContext=new Aeroplane();</font></div><div><font face="Source Code Pro">       vehicleContext.showMe();</font></div><div><font face="Source Code Pro">       vehicleContext.showTransportMedium();</font></div><div><font face="Source Code Pro">   }</font></div><div><font face="Source Code Pro">}</font></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 846px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div>D:   <span style="font-weight: bold;">Why are you complicating the example by avoiding simple subclassing of these behaviors?</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div><b>R: </b>In object-oriented programming, you may prefer to use the concept of polymorphism so that your code can pick the intended object (among different object types) at runtime, leaving your code unchanged.</div><div>When you are familiar with design patterns, most often, you prefer composition over inheritance.</div><div>Strategy patterns help you combine composition with polymorphism. Let’s examine the reasons behind this.</div><div>It is assumed that you try to use the following guidelines in any application you write:</div><ul><li><div>Separate the code that varies a lot from the part of code that does not vary.</div></li><li><div>Try to maintain the varying parts as freestanding as possible (for easy maintenance).</div></li><li><div>Try to reuse them as much as possible.</div></li></ul><div>Following these guidelines, I have used composition to extract and encapsulate the volatile/varying parts of the code, so that the whole task can be handled easily, and you can reuse them.</div><div>But when you use inheritance, your parent class can provide a default implementation, and then the derived class changes it (Java calls it <span style="font-style: italic;">overriding it</span>). The next derived class can further modify the implementation, so you are basically spreading out the tasks over different levels, which may cause severe maintenance and extensibility issues in the future</div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 846px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div>D:   <span style="font-weight: bold;">If this is the case, you could create a separate interface, TransportInterface, and place the showTransportMedium() method in that interface. Now any class that wants to get the method can implement that interface also. Is this understanding correct?</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div>R: Yes, you can do that. But this is what the code looks like:<br/></div><div><font face="Source Code Pro"><br/></font></div><div><font face="Source Code Pro">abstract class Vehicle</font></div><div><font face="Source Code Pro">{</font></div><div><font face="Source Code Pro">   //The code that does not vary.</font></div><div><font face="Source Code Pro">   public void commonJob()</font></div><div><font face="Source Code Pro">   {</font></div><div><font face="Source Code Pro">       System.<span style="font-style: italic;">out</span>.println(&quot;We all can be used to transport&quot;);</font></div><div><font face="Source Code Pro">   }</font></div><div><font face="Source Code Pro">   public abstract void showMe();</font></div><div><font face="Source Code Pro">}</font></div><div><font face="Source Code Pro">interface TransportInterface</font></div><div><font face="Source Code Pro">{</font></div><div><font face="Source Code Pro">   void showTransportMedium();</font></div><div><font face="Source Code Pro">}</font></div><div><font face="Source Code Pro">class Aeroplane extends Vehicle implements TransportInterface</font></div><div><font face="Source Code Pro">{</font></div><div><font face="Source Code Pro">   @Override</font></div><div><font face="Source Code Pro">   public void showMe() {</font></div><div><font face="Source Code Pro">       System.<span style="font-style: italic;">out</span>.println(&quot;I am an aeroplane.&quot;);</font></div><div><font face="Source Code Pro">   }</font></div><div><font face="Source Code Pro">   @Override</font></div><div><font face="Source Code Pro">   public void showTransportMedium() {</font></div><div><font face="Source Code Pro">       System.<span style="font-style: italic;">out</span>.println(&quot;I am transporting in air.&quot;);</font></div><div><font face="Source Code Pro">   }</font></div><div><font face="Source Code Pro">}</font></div><div><font face="Source Code Pro">class Boat extends Vehicle implements TransportInterface</font></div><div><font face="Source Code Pro">{</font></div><div><font face="Source Code Pro">   @Override</font></div><div><font face="Source Code Pro">   public void showMe()</font></div><div><font face="Source Code Pro">   {</font></div><div><font face="Source Code Pro">       System.<span style="font-style: italic;">out</span>.println(&quot;I am a boat.&quot;);</font></div><div><font face="Source Code Pro">   }</font></div><div><font face="Source Code Pro">   @Override</font></div><div><font face="Source Code Pro">   public void showTransportMedium() {</font></div><div><font face="Source Code Pro">       System.<span style="font-style: italic;">out</span>.println(&quot;I am transporting in water.&quot;);</font></div><div><font face="Source Code Pro">   }</font></div><div><font face="Source Code Pro">}</font></div><div><font face="Source Code Pro">You can see that each class and its subclasses may need to provide its own implementations for the showTransportMedium() method. So, you cannot reuse your code, which is as bad as inheritance in this case.</font></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 846px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div>D:   <span style="font-weight: bold;">Can you use an abstract class instead of an interface?</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div><b>R:  </b>Yes. It is suitable in some cases where you may want to put common behaviors in the abstract class. I discussed it in detail in the “Q&amp;A Session” section on the builder pattern.</div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 846px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div>D:   <span style="font-weight: bold;">What are the key</span> <span style="font-weight: bold;">advantages</span> <span style="font-weight: bold;">of using a strategy design pattern?</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div>R: This pattern makes your classes independent from algorithms. Here, a class delegates the algorithms to the strategy object (that encapsulates the algorithm) dynamically at runtime. So, you can simply say that the choice of the algorithm is not bound at compile time.</div><ul><li><div>Easier maintenance of your codebase.</div></li><li><div>It is easily extendable. (Refer to the answers for questions 2 and 3 in this context.)</div></li></ul></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 846px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div>D:   <span style="font-weight: bold;">What are key challenges associated with a strategy design pattern?</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 846px; padding: 8px;"><div><b>R: </b></div><ul><li><div>The addition of context classes causes more objects in our application.</div></li><li><div>Users of the application must be aware of different strategies; otherwise, the output may surprise them. So, there exists a tight coupling between the client code and the implementation of different strategies.</div></li><li><div>When you introduce a new behavior/algorithm, you may need to change the client code also.</div></li></ul></td></tr></tbody></table></div></div><div><br/></div></span>
</div></body></html> 