<html>
<head>
  <title>Evernote Export</title>
  <basefont face="Segoe UI" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/309091 (it-IT, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: Segoe UI;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="813"/>

<div>
<span><div><div><div><div><div><font style="font-size: 10pt;"><br/></font></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-size: 10pt;"><b>Even-odd sort.</b> </span></div><div><span style="font-size: 10pt;">Given an array of integers, order the array so that odd entries appear on the left and even entries appear on the right. Don't use additional memory to order the array</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">private int[] sort(int[] array, int lo, int hi) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">   int i = lo - 1;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">   for (int k = lo; k &lt;= hi; k++) {   </span><span style="font-family: &quot;Courier New&quot;; font-size: 10pt; font-weight: bold; color: rgb(65, 173, 28);">// cosi' mi trovo gli array divisi pari e dispari nella stessa sequenza</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">     if (isOdd(array[k])) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">       swap(array, ++i, k);</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">     }</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">   }</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">   array = quickSort(array, 0, i);</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">   array = quickSort(array, i + 1, hi);</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">   return array;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">}</span></div></td></tr></tbody></table><div><font style="font-size: 10pt;"><br/></font></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-weight: bold; font-size: 10pt;">Dutch national problem. </span></div><div><span style="font-size: 10pt;">Write a program that takes an array A and an index i into A, and rearranges the element such that all elements less then A[i] (the &quot;pivot&quot;) appear first, followed by elements equal to the pivot, followed by elements greater than the pivot.</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-size: 10pt;">This problem is solved by the 3-way quicksort for which we use 2 pivots (less and more):</span></div><div><font style="font-size: 10pt;"><br/></font></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">private Comparable[] sort(Comparable[] array, int lo, int hi) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  if (hi &lt; lo) return array;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  int less = lo, more = hi;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  Comparable pivot = array[lo];</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  int i = lo;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  while (i &lt;= more) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    int compare = array[i].compareTo(pivot);</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    if (compare &lt; 0) swap(less++, i++);</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    else if (compare &gt; 0) swap(i, more--);</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    else i++;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  }</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  array = sort(array, lo, less - 1);</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  array = sort(array, more + 1, hi);</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  return array;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">}</span></div></td></tr></tbody></table><div><font style="font-size: 10pt;"><br/></font></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-weight: bold; font-size: 10pt;">Delete duplicates from a sorted array. </span></div><div><span style="font-size: 10pt;">Write a program which takes as input a sorted array and updates it so that all duplicates have been removed and the remaining elements have been shifted left to fill the emptied indices. Return the number of valid elements.</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-size: 10pt;">La soluzione consiste nel tenere un pivot (un puntatore) che si distanzia dall'indice del for e rappresenta il numero di entries uguale.</span></div><div><span style="font-size: 10pt;">La chiave sta nel fatto che essenso l'array ordinato noi dobbiamo tenere in considerazione solo i numeri successivi a quello preso in esame.</span></div><div><font style="font-size: 10pt;"><br/></font></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">public int[] deleteRepeated(int[] array) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">   int pivot = 0;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">   for (int i = 1; i &lt; array.length; i++) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">     if (array[i] != array[pivot]) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">       array[++pivot] = array[i];</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">     }</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">   }</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">   for (int i = pivot + 1; i &lt; array.length; i++) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">     array[i] = 0;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">   }</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">   return array;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">}</span></div></td></tr></tbody></table><div><font style="font-size: 10pt;"><br/></font></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-weight: bold; font-size: 10pt;">Buy and sell stocks once. </span></div><div><span style="font-size: 10pt;">Write a program that takes an array denoting the daily stock price and returns the maximum profit that could be made by buying and then selling one share of that stock.</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-size: 10pt;">The maximum profit that can be made by selling on each specific day is the difference of the current price and the minimum seen so far.</span></div><div><font style="font-size: 10pt;"><br/></font></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">public static double computeMaxProfit(List &lt; Double &gt; prices) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  double minPrice = Double.MAX_VALUE, maxProfit = ®.®;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  for (Double price: prices) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    maxProfit = Math.max(maxProfit, price - minPrice);</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    minPrice = Math.min(minPrice, price);</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  }</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  return maxProfit;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">}</span></div></td></tr></tbody></table><div><font style="font-size: 10pt;"><br/></font></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-size: 10pt; font-weight: bold;">Buy and sell stocks twice</span><span style="font-size: 10pt;">. </span></div><div><span style="font-size: 10pt;">Write a program that computes the maximum profit that can be made by buying and selling a share at most twice. The second buy must be made on another date after the first sale</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-size: 10pt;">Using the algorithm for the single version would take O(n^2) time complexity. The inefficiency in the above approaches comes from not taking advantage of previous computations. </span></div><div><font style="font-size: 10pt;"><br/></font></div><div><font style="font-size: 10pt;"><br/></font></div><div><span style="font-size: 10pt;">// secondo me l'idea giusta e' quella di avere uno stack (o una priority queue) col quale mantenere le due differenze piu' alte possibili (e le cose escono molto piu' semplici di come descritto nel libro)</span></div></td></tr></tbody></table><div><font style="font-size: 10pt;"><br/></font></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-size: 10pt; font-weight: bold;">Enumerates all primes to N.</span><span style="font-size: 10pt;">  </span></div><div><span style="font-size: 10pt;">Write a program that takes an integer argument and returns all the primes between 1 and that integer.</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-size: 10pt;">The solution is the sieve of Eratosthenes that can be expressed in pseudocode as follows:</span></div><div><font style="font-size: 10pt;"><br/></font></div><div style="background-color: rgb(248, 249, 250); letter-spacing: normal; orphans: 2; white-space: pre-wrap; widows: 2; word-spacing: 0px;"><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 1.3;">algorithm</span> <span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">Sieve of Eratosthenes</span> <span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 1.3;">is</span></div><div style="background-color: rgb(248, 249, 250); letter-spacing: normal; orphans: 2; white-space: pre-wrap; widows: 2; word-spacing: 0px;"><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 1.3;">input</span><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">: an integer</span> <span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">n</span> <span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">&gt; 1.</span></div><div style="background-color: rgb(248, 249, 250); letter-spacing: normal; orphans: 2; white-space: pre-wrap; widows: 2; word-spacing: 0px;"><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 1.3;">output</span><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">: all prime numbers from 2 through</span> <span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">n</span><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">.</span></div><div style="background-color: rgb(248, 249, 250); letter-spacing: normal; orphans: 2; white-space: pre-wrap; widows: 2; word-spacing: 0px;"><font style="font-size: 10pt;"><br/></font></div><div style="background-color: rgb(248, 249, 250); letter-spacing: normal; orphans: 2; white-space: pre-wrap; widows: 2; word-spacing: 0px;"><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 1.3;">let</span> <span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">A</span> <span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">be an</span> <span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 1.3;">array of</span> <a href="https://en.wikipedia.org/wiki/Boolean_data_type" style="background: none; font-size: 10pt; color: rgb(6, 69, 173); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 1.3;" title="Boolean data type">Boolean</a> <span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">values, indexed by</span> <span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 1.3;">integer</span><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">s 2 to</span> <span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">n</span><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">,</span></div><div style="background-color: rgb(248, 249, 250); letter-spacing: normal; orphans: 2; white-space: pre-wrap; widows: 2; word-spacing: 0px;"><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">initially all</span> <span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 1.3;">set</span> <span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">to</span> <span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 1.3;">true</span><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">.</span></div><div style="background-color: rgb(248, 249, 250); color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; letter-spacing: normal; line-height: 1.3; orphans: 2; white-space: pre-wrap; widows: 2; word-spacing: 0px;"></div><div style="background-color: rgb(248, 249, 250); letter-spacing: normal; orphans: 2; white-space: pre-wrap; widows: 2; word-spacing: 0px;"><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 1.3;">for</span> <span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">i</span> <span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">= 2, 3, 4, ..., not exceeding</span> <span style="white-space: nowrap; font-size: 10pt; color: rgb(0, 0, 0); font-family: &quot;Nimbus Roman No9 L&quot;, &quot;Times New Roman&quot;, Times, serif; font-feature-settings: 'lnum' 1, 'tnum' 1, 'kern' 0; font-kerning: none; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-variant-numeric: lining-nums tabular-nums; line-height: 1;">√</span><span style="white-space: nowrap; border-top: 1px solid; font-size: 10pt; color: rgb(0, 0, 0); font-family: &quot;Nimbus Roman No9 L&quot;, &quot;Times New Roman&quot;, Times, serif; font-feature-settings: 'lnum' 1, 'tnum' 1, 'kern' 0; font-kerning: none; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; font-variant-numeric: lining-nums tabular-nums; line-height: 1;">n</span> <span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 1.3;">do</span></div><div style="background-color: rgb(248, 249, 250); letter-spacing: normal; orphans: 2; white-space: pre-wrap; widows: 2; word-spacing: 0px;"><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 1.3;">if</span> <span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">A</span><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">[</span><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">i</span><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">]</span> <span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 1.3;">is</span> <span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 1.3;">true</span></div><div style="background-color: rgb(248, 249, 250); letter-spacing: normal; orphans: 2; white-space: pre-wrap; widows: 2; word-spacing: 0px;"><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 1.3;">for</span> <span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">j</span> <span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">=</span> <span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">i</span><span style="vertical-align: super; font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1;">2</span><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">,</span> <span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">i</span><span style="vertical-align: super; font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1;">2</span><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">+</span><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">i</span><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">,</span> <span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">i</span><span style="vertical-align: super; font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1;">2</span><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">+2</span><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">i</span><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">,</span> <span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">i</span><span style="vertical-align: super; font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1;">2</span><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">+3</span><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">i</span><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">, ..., not exceeding</span> <span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">n</span> <span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 1.3;">do</span></div><div style="background-color: rgb(248, 249, 250); letter-spacing: normal; orphans: 2; white-space: pre-wrap; widows: 2; word-spacing: 0px;"><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">A</span><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">[</span><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">j</span><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">] :=</span> <span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 1.3;">false</span></div><div style="background-color: rgb(248, 249, 250); letter-spacing: normal; orphans: 2; white-space: pre-wrap; widows: 2; word-spacing: 0px;"><font style="font-size: 10pt;"><br/></font></div><div style="background-color: rgb(248, 249, 250); letter-spacing: normal; orphans: 2; white-space: pre-wrap; widows: 2; word-spacing: 0px;"><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 1.3;">return</span> <span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">all</span> <span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">i</span> <span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">such that</span> <span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">A</span><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">[</span><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">i</span><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">]</span> <span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 1.3;">is</span> <span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 1.3;">true</span><span style="font-size: 10pt; color: rgb(0, 0, 0); font-family: monospace, monospace; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.3;">.</span></div><div><font style="font-size: 10pt;"><br/></font></div><div><span style="font-size: 10pt;">It includes a common optimization, which is to start enumerating the multiples of each prime i from i^2. The time complexity of this algorithm is O(nloglogn) provided the array update is an O(1) operation.</span></div></td></tr></tbody></table><div><font style="font-size: 10pt;"><br/></font></div></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-size: 10pt; font-weight: bold;">Permutes the elements of an array.</span> <span style="font-size: 10pt;">(NB: le permutazioni senza ripetizioni sono i fattoriali)</span></div><div><span style="font-size: 10pt;">A permutation can be specified by an array P, where P[i] represents the location of the element at i in the permutation. Given an array A of n elements and a permutation P, apply P to A.</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-size: 10pt;">The key of the solution consist in considering that every permutation can be represented by a collection of independent permutations, each of which is cyclic, that is, it moves all elements by a fixed offset, wrapping around. One way to perform this without explicitly using additional O(n) storage is to use the sign bit in the entries in the permutation-array. Specifically, we subtract n from P[i] after applying it. This means that if an entry in P[i] is negative, we have performed the corresponding move.</span></div><div><font style="font-size: 10pt;"><br/></font></div><div><span style="font-size: 10pt;">// sinceramente questo mi sembra stia facendo cose un po' troppo strane per risolvere sto problema. Semplicemente qua mi sta dando gli indici con cui swappare i valori. Dovrei provare a fare questo da solo</span></div><div><span style="font-size: 10pt;">// da inserire il courier qui</span></div></td></tr></tbody></table><div><font style="font-size: 10pt;"><br/></font></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-weight: bold; font-size: 10pt;">Select random values from array. </span></div><div><span style="font-size: 10pt;">Implement an algorithm that takes as input an array of distinct elements and a size, and returns a subset of the given size of the array elements. All subsets should be equally likely. Return the result in input array itself.</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-size: 10pt;">A naive approach is ot iterate through the input array, selecting entries with probability k/n. Although the average number of selected entries is k, we may select more or less than k entries in this way.</span></div><div><span style="font-size: 10pt;">Another approach is to enumerate all the subsets of size k but this is very huge in terms of complexity.</span></div><div><span style="font-size: 10pt;">The key to efficiently building a random subset of size exactly k is to first build one of size k-1 and then adding one more element, selected randomly from the rest. The problem is trivial when k = 1. We make one call to the random number generator, take the returned value mod n (call it r), and swap A[0] with A[r]. A formal proof uses mathematical induction.</span></div><div><span style="font-size: 10pt;">Simply put first we take a random number between 0 : N-1, then 1 : N-1 and so on</span></div><div><font style="font-size: 10pt;"><br/></font></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">public static void randomsampling(int k, List&lt;Integer&gt; A) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  Random gen = new Random() </span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  for (int i = 0; i &lt; k; ++i) {</span></div><div><font color="#41AD1C" style="font-size: 10pt;"><span style="color: rgb(65, 173, 28); font-family: &quot;Courier New&quot;; font-size: 10pt; font-weight: bold;">    // Generate a random int in [i, A.size() - 1].</span></font></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    Collections.swap(A, i, i + gen.nextlnt(A.size() - i));</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  }</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">}</span></div></td></tr></tbody></table><div><font style="font-size: 10pt;"><br/></font></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-weight: bold; font-size: 10pt;">Compute the next permutation. </span></div><div><span style="font-size: 10pt;">Write a program that takes as input a permutation and returns the next permutation under dictionary ordering. If the permutation is the last permutation return the empty array. For example if the input is {1,0,3,2} your function should return {1,2,0,3}</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-size: 10pt;">Compute all the permutation is a nontrivial problem. THe key insight is that we want to increase the permutation by as little as possible</span></div><div><font style="font-size: 10pt;"><br/></font></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">public static List &lt; Integer &gt; nextPermutation(List &lt; Integer &gt; perm) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  int k = perm.sizeO - 2;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  while (k &gt;= ® &amp;&amp; perm.get(k) &gt;= perm.get(k + 1)) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    --k;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  }</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  if (k == -1) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    return Collections.emptyList();</span> <span style="font-family: &quot;Courier New&quot;; font-size: 10pt; font-weight: bold; color: rgb(65, 173, 28);">// perm is the last permutation</span><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">.</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  }</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  </span><span style="font-family: &quot;Courier New&quot;; font-size: 10pt; font-weight: bold; color: rgb(65, 173, 28);">// Swap the smallest entry after index k that is greater than perm[k] . We</span></div><div><font color="#41AD1C" face="Courier New" style="font-size: 10pt;"><span style="color: rgb(65, 173, 28); font-family: &quot;Courier New&quot;; font-size: 10pt; font-weight: bold;">  // exploit the fact that perm .subList (k + 1, perm.sizeO) is decreasing so</span></font></div><div><font color="#41AD1C" face="Courier New" style="font-size: 10pt;"><span style="color: rgb(65, 173, 28); font-family: &quot;Courier New&quot;; font-size: 10pt; font-weight: bold;">  // if we search in reverse order, the first entry that is greater than</span></font></div><div><font color="#41AD1C" face="Courier New" style="font-size: 10pt;"><span style="color: rgb(65, 173, 28); font-family: &quot;Courier New&quot;; font-size: 10pt; font-weight: bold;">  // perm[k ] is the smallest such entry.</span></font></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  for (int i = perm.sizeO - 1; i &gt; k; --i) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    if (perm.get(i) &gt; perm.get(k)) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">      Collections.swap(perm, k, i);</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">      break;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    }</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  }</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  </span><span style="font-family: &quot;Courier New&quot;; font-size: 10pt; color: rgb(65, 173, 28); font-weight: bold;">// Since perm . subList[k + 1, perm.size()) is in decreasing order, we can</span></div><div><font color="#41AD1C" face="Courier New" style="font-size: 10pt;"><span style="color: rgb(65, 173, 28); font-family: &quot;Courier New&quot;; font-size: 10pt; font-weight: bold;">  // build the smallest dictionary ordering of this subarray by reversing it.</span></font></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  Collections.reverse(perm.subList(k + 1, perm.size()));</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  return perm;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">}</span></div></td></tr></tbody></table><div><font style="font-size: 10pt;"><br/></font></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-size: 10pt; font-weight: bold;">Generate nonuniform random numbers.</span><span style="font-size: 10pt;"> </span></div><div><span style="font-size: 10pt;">You are given n numbers as well as probabilities p0..pn-1 which sum up to 1. Given a random number generator that produces values in [0,1] uniformly, how would you generate one of the n numbers according to the specified probabilities?</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-size: 10pt;">// anche questo secondo me lo fa troppo difficile. In realta' basterebbe generare uniformemente un valore compreso tra 0-1 e fare il check su dove cade all'interno delle probabilita' (semplicemente diamo piu' spazio ai valori che danno maggiore probabilita' di uscire all'interno della funzione random). In questo modo non devo usare nessun array e la funzione mi prende tempo costante in tempo e memoria (bastano una serie di if). Da rivedere insieme al libro questo.</span></div></td></tr></tbody></table><div><font style="font-size: 10pt;"><br/></font></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-size: 10pt; font-weight: bold;">Sudoku</span><span style="font-size: 10pt;">. </span></div><div><span style="font-size: 10pt;">Check whether a 9x9 2D array representing a partially completed sudoku is valid. Specifically, check that no row, column or 3x3 2D subarray contains duplicates. A 0-value in the 2D array indicates that entry is blank, every other entry is in [1,9]</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-size: 10pt;">There is no real scope for algorithm optimization in this problem - it's all about writing clean code. It is convenient tu use bit arrays to test for constraint violations, that is to ensure no number in [1,9] appears more than once.</span></div><div><span style="font-size: 10pt;">// da vedere</span></div></td></tr></tbody></table><div><font style="font-size: 10pt;"><br/></font></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-size: 10pt; font-weight: bold;">Compute the spiral ordering of a 2D array.</span><span style="font-size: 10pt;"> </span></div><div><span style="font-size: 10pt;">Write a program which takes a nxn 2d array and returns the spiral ordering of the array.</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-size: 10pt;">// Questo lo voglio provare prima di scrivere di copiare il codice</span></div><div><span style="font-size: 10pt;">// CODICE QUI</span></div></td></tr></tbody></table><div><font style="font-size: 10pt;"><br/></font></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-size: 10pt; font-weight: bold;">Rotate a 2D array.</span><span style="font-size: 10pt;"> </span></div><div><span style="font-size: 10pt;">The image below represents the rotation operation on a 2D array representing a bit-map of an image. Specifically, the image is rotated by 90 degrees clockwise. Write a function that takes as unput an NxN 2D array and rotates the array by 90 degrees clockwise</span></div><div><span style="font-size: 10pt;"><img src="esercizi_files/Image.png" type="image/png" data-filename="Image.png"/></span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-size: 10pt;">// Anche questo lo voglio provare da solo</span></div></td></tr></tbody></table><div><font style="font-size: 10pt;"><br/></font></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-size: 10pt;"><b>Compute rows in a Pascal's triangle</b>.</span></div><div><span style="font-size: 10pt;"> Write a program which takes as input a nonnegative integer n and returns the first n rows of Pascal's triangle.</span></div><div><font style="font-size: 10pt;"><br/></font></div><div><span style="font-size: 10pt;"><img src="esercizi_files/Image [1].png" type="image/png" data-filename="Image.png"/></span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-size: 10pt;">// TODO</span></div></td></tr></tbody></table><div><font style="font-size: 10pt;"><br/></font></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-size: 10pt; font-weight: bold;">Palindromic string</span><span style="font-size: 10pt;">. </span></div><div><span style="font-size: 10pt;">Write a program that checks if a string is palindromic</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">public static boolean isPalindromic(String s) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    for (int i = ®, j = s.length() - 1; i &lt; j; ++i, --j) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">      if (s.charAt(i) != s.charAt(j)) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">        return false;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">      }</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    }</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    return true;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">}</span></div></td></tr></tbody></table><div><font style="font-size: 10pt;"><br/></font></div></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-size: 10pt; font-weight: bold;">Interconvert strings and integers.</span><span style="font-size: 10pt;"> </span></div><div><span style="font-size: 10pt;">In this problem, you have to implement methods that take a string representing an integer and return the corresponding integer and viceversa. </span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">public static String intToString(int x) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  boolean isNegative = false;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  if (x &lt; 8) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    isNegative = true;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  }</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  StringBuilder s = new StringBuilder();</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  do {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    s.append((char)('0' + Math.abs(x % 10)));</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    x /= 10;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  ) while (x != 0);</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  if (isNegative) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    s.append('-');</span> <span style="font-family: &quot;Courier New&quot;; font-size: 10pt; font-weight: bold; color: rgb(65, 173, 28);">// Adds the negative sign back .</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  }</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  s.reverse();</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  return s.toString();</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">}</span></div><div><font face="Courier New" style="font-size: 10pt;"><br/></font></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">public static int stringToInt(String s) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  int result = 8;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  for (int i = s.charAt(S) == '-' ? 1 : 0; i &lt; s.length(); ++i) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    final int digit = s.charAt(i) - ’0’;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    result = result * 10 + digit;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  }</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  return s.charAt(S) == '-' ? -result : result;</span></div><div><font face="Courier New" style="font-size: 10pt;"><br/></font></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">}</span></div></td></tr></tbody></table><div><font style="font-size: 10pt;"><br/></font></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-size: 10pt; font-weight: bold;">Base conversion</span><span style="font-size: 10pt;">. </span></div><div><span style="font-size: 10pt;">Write a program that performs base conversion. The input is a string, an integer b1 and another integer b2. The string represents an integer in base b1. The output should be the string representing the integer in base b2.</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-size: 10pt;">We can convert a a string in base b1 to integer tpe using a sequenc of multiply and adds. Then we convert that integer type to a string in base b2 using a sequence of modulus and division operations.</span></div><div><font style="font-size: 10pt;"><br/></font></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">public static String convertBase(String numAsString, int bl, int b2) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  boolean isNegative = numAsString.startsWith(&quot;-&quot;);</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  int numAsInt = 0;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  for (int i = (isNegative ? 1 : 0); i &lt; numAsString.length(); ++i) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    numAsInt *= bl;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    numAsInt += Character.isDigit(numAsString.charAt(i)) ?</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">      numAsString.charAt(i) - '0' :</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">      numAsString.charAt(i) - 'A' + 10;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  }</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  return (isNegative ? : &quot;&quot;) +</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    (numAsInt == 0 ? &quot;0&quot; : constructFromBase(numAsInt, b2));</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">}</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">private static String constructFromBase(int numAsInt, int base) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  return numAsInt == 0 ?</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    &quot;&quot; :</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    constructFromBase(numAsInt / base, base) + (char)(numAsInt % base &lt;= 10 ? 'A' + numAsInt % base - 10 : '0' + numAsInt % base);</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">}</span></div></td></tr></tbody></table><div><font style="font-size: 10pt;"><br/></font></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-size: 10pt; font-weight: bold;">Replace and remove.</span><span style="font-size: 10pt;"> </span></div><div><span style="font-size: 10pt;">Write a program which takes as input an array of chars and removes each 'b' and replaces each 'a' by two 'd's. Specifically along with the array you are provided an integer-valued size. Size denotes the number of entries of the array that the operation is to be applied to. You do not have to worry preserving about subsequent entries.</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-size: 10pt;">The problem is trivial to solve in O(n) time if we write result to a new array. However this entails O(n) additional space. </span></div><div><font style="font-size: 10pt;"><br/></font></div><div><span style="font-size: 10pt;">If there are no 'a' we can implement the function without allocating additional space with oen forward iteration by skipping 'b's and copying over other characters. </span></div><div><font style="font-size: 10pt;"><br/></font></div><div><span style="font-size: 10pt;">If there are no 'b's we can implement the function without additional space as follows. First we compute the final lenght of the resulting string, which is the length of the array plus the number of 'a's. We can then write the result char by char, starting from the last char working our way backwards.</span></div><div><font style="font-size: 10pt;"><br/></font></div><div><span style="font-size: 10pt;">We can combine these two approaches to get a complete algorithm. </span></div><div><font style="font-size: 10pt;"><br/></font></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">public static int replaceAndRemove(int size, char[] s) {</span></div><div><font color="#41AD1C" style="font-size: 10pt;"><span style="color: rgb(65, 173, 28); font-family: &quot;Courier New&quot;; font-size: 10pt; font-weight: bold;">  // Forward iteration: remove &quot;b&quot;s and count the number of &quot;a&quot;s.</span></font></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  int writeldx = 0, aCount = 0;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  for (int i = 0; i &lt; size; ++i) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    if (s[i] != ’b’) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">      s[writeldx++] = s[i];</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    }</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    if (s[i] == ’a’) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">      ++aCount;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    }</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  }</span></div><div><font color="#41AD1C" style="font-size: 10pt;"><span style="color: rgb(65, 173, 28); font-family: &quot;Courier New&quot;; font-size: 10pt; font-weight: bold;">  // Backward iteration: replace &quot;a&quot;s with &quot;dd&quot;s starting from the end.</span></font></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  int curldx = writeldx - 1;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  writeldx = writeldx + aCount - 1;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  final int finalSize = writeldx + 1;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  while (curldx &gt;= 0) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    if (s[curldx] == 'a') {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">      s[writeldx - -] = 'd';</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">      s[writeldx - -] = 'd';</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    } else {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">      s[writeldx - -] = s[curldx];</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    }</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    --curldx;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  }</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  return finalSize;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">}</span></div><div><font style="font-size: 10pt;"><br/></font></div><div><span style="font-size: 10pt;">Complexity is O(n) without additional space.</span></div></td></tr></tbody></table><div><font style="font-size: 10pt;"><br/></font></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-size: 10pt; font-weight: bold;">Compute the spreadSheet column encoding.</span><span style="font-size: 10pt;"> </span></div><div><span style="font-size: 10pt;">Spreadsheet often use an alphabetical encoding of the successive columns. Specifically columns are identified by A, B, C, ... X, Y, Z, AA, AB ... ZZ, etc.</span></div><div><span style="font-size: 10pt;">Implement a function that converts a spreadsheet column id to the corresponding integer, with &quot;A&quot; corresponding to 1. For example return 4 for D, 27 for AA, etc. How would you test your code?</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-size: 10pt;">This problem is basically the problem of converting a string representing a base-26 number to the corresponding integer, except that A corresponds to 1 not 0. For example to convert ZZ we initialize result to 0. We add 26, multiply by 26, then add 26 again, i.e. the id is 26^2 + 26.</span></div><div><span style="font-size: 10pt;">Good test case are around boundaries e.g. A, B, Y, Z, AA, AB, ZY, ZZ, and some random string</span></div><div><font style="font-size: 10pt;"><br/></font></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">public static int ssDecodeColID(final String col) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  int result = 8;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  for (int i = 8; i &lt; col.length(); i++) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    char c = col.charAt(i);</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    result = result * 26 + c - ’A’ + 1;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  }</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  return result;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">}</span></div><div><font style="font-size: 10pt;"><br/></font></div><div><span style="font-size: 10pt;">A variant would be to solve the problem the opposite way, converting integer into strings for a spreadsheet</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-size: 10pt; font-weight: bold;">Compute all mnemonics for a phone number.</span><span style="font-size: 10pt;"> </span></div><div><span style="font-size: 10pt;">Each digit, apart from 0 and 1, in a phone keypad corresponds to one of three or four letters of the alphabet. Since words are easier to remember than numbers, it is natural to ask if a 7 or 10-digit phone number can be represented by a word. Write a program which takes as input a phone number, specified as a string of digits, and returns all possible character sequences that correspond to the phone number. The characted sequences do not have to be legal words or phrase (hint: use recursion)</span></div><div><font style="font-size: 10pt;"><br/></font></div><div><span style="font-size: 10pt;"><img src="esercizi_files/Image [2].png" type="image/png" data-filename="Image.png" width="138"/></span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-size: 10pt;">As a general rule, any such enumeration is best computed using recursion. The execution path is very similar to that of the brute-force approach, but the compiler handles the looping.</span></div><div><font style="font-size: 10pt;"><br/></font></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">public static List &lt; String &gt; phoneMnemonic(String phoneNumber) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  char[] partialMnemonic = new char[phoneNumber.length()];</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  List &lt; String &gt; mnemonics = new ArrayList &lt; &gt; ();</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  phoneMnemonicHelper(phoneNumber, 0, partialMnemonic, mnemonics);</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  return mnemonics;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">}</span></div><div><font color="#41AD1C" style="font-size: 10pt;"><span style="color: rgb(65, 173, 28); font-family: &quot;Courier New&quot;; font-size: 10pt; font-weight: bold;">// The mapping from digit to corresponding characters.</span></font></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">private static final String[] MAPPING = {  &quot;0&quot;,   &quot;1&quot;,  &quot;ABC&quot;,  &quot;DEF&quot;,  &quot;GHI&quot;,  &quot;JKL&quot;,  &quot;MNO&quot;,  &quot;PQRS&quot;,  &quot;TUV&quot;,  &quot;WXYZ&quot;};</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">private static void phoneMnemonicHelper(String phoneNumber, int digit,  char[] partialMnemonic, List &lt; String &gt; mnemonics) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  if (digit == phoneNumber.length()) {</span></div><div><font color="#41AD1C" style="font-size: 10pt;"><span style="color: rgb(65, 173, 28); font-family: &quot;Courier New&quot;; font-size: 10pt; font-weight: bold;">    // All digits are processed , so add partialMnemonic to mnemonics.</span></font></div><div><font color="#41AD1C" style="font-size: 10pt;"><span style="color: rgb(65, 173, 28); font-family: &quot;Courier New&quot;; font-size: 10pt; font-weight: bold;">    // (We add a copy since subsequent calls modify partialMnemonic.)</span></font></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    mnemonics.add(new String(partialMnemonic));</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  } else {</span></div><div><font color="#41AD1C" style="font-size: 10pt;"><span style="color: rgb(65, 173, 28); font-family: &quot;Courier New&quot;; font-size: 10pt; font-weight: bold;">    // Try all possible characters for this digit.</span></font></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    for (int i = 0; i &lt; MAPPING[phoneNumber.charAt(digit) - '0'].length();</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">      ++i) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">      char c = MAPPING[phoneNumber.charAt(digit) - '0'].charAt(i);</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">      partialMnemonic[digit] = c;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">      phoneMnemonicHelper(phoneNumber, digit + 1, partialMnemonic, mnemonics);</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    }</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  }</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">}</span></div><div><font style="font-size: 10pt;"><br/></font></div></td></tr></tbody></table><div><font style="font-size: 10pt;"><br/></font></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-size: 10pt; font-weight: bold;">Look and say problem.</span><span style="font-size: 10pt;"> </span></div><div><span style="font-size: 10pt;">The look and say sequence start with 1. Subsequent numbers are derived by describind the previous number in terms of consecutive digits. Specifically, to generate an entry of the sequence from the previous entry, read off the digits of the previous entry, counting the number of digits in groups of the same digit.</span></div><div><span style="font-size: 10pt;">For example 1; one 1; two 1s; one 2 then one 1; one 1, then one 2, then two 1s; three 1s, then two 2s then one 1. The first eight numbers in the look and say sequence are: </span><span style="font-size: 10pt; min-height: 13pt; color: rgb(1, 1, 1);">&lt;1,11,21,1211,111221,312211,13112221,</span><span style="font-size: 10pt; min-height: 13pt; color: rgb(1, 1, 1);">1113213211&gt;</span></div><div><span style="min-height: 13pt;"><span style="color: rgb(1, 1, 1); font-size: 10pt;">Write a program that takes as input an integer n and returns the nth integer in the look-and-say sequence. </span></span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-size: 10pt;">We compute the nth number by iteratively applying this rule n-1 times. Since we are counting digits, it is natural to use strings to represent the integers in the sequence. Specifically, going from the ith number to the (i+1)th number entails scanning the digits from most significant to least significant, counting the numbers of consecutive equal digits and writing these counts.</span></div><div><font style="font-size: 10pt;"><br/></font></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">public static String lookAndSay(int n) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  String s = &quot;1&quot;;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  for (int i = 1; i &lt; n; ++i) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    s = nextNumber(s);</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  }</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  return s;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">}</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">private static String nextNumber(String s) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  StringBuilder result = new StringBuilder();</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  for (int i = Q; i &lt; s.length(); ++i) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    int count = 1;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    while (i + 1 &lt; s.lengthO &lt; &amp;&amp; s.charAt(i) == s.charAt(i + 1)) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">      ++i;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">      ++count;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    }</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    result.append(count);</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    result.append(s.charAt(i));</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  }</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  return result.toString();</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">}</span></div></td></tr></tbody></table><div><font style="font-size: 10pt;"><br/></font></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-size: 10pt; font-weight: bold;">Convert from Roman to Decimal</span><span style="font-size: 10pt;">. </span></div><div><span style="font-size: 10pt;">The Roman numeral representation of positive integers uses the symbols I, V, X, L, C, D, M representing 1, 5, 10, 50, 100, 500, 1000. </span></div><div><span style="font-size: 10pt;">In this problem we give simplified rules for representing numbers in this system. Specifically, define a string over the Roman number symbols to be a valid Roman number string if symbols appear in nonincreasing order with the following exception allowed:</span></div><ul><li><div><span style="font-size: 10pt;">I can immediately preced V and X</span></div></li><li><div><span style="font-size: 10pt;">X can immediately preced L and C</span></div></li><li><div><span style="font-size: 10pt;">C can immediately precede D and M. </span></div></li></ul><div><font style="font-size: 10pt;"><br/></font></div><div><span style="font-size: 10pt;">Write a program which takes as input a valid roman number string s and returns the integer it corresponds to. </span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">public Static int romanToInteger(String s) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  Map &lt; Character, Integer &gt; T = new HashMap &lt; Character, Integer &gt; () {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">      put(’I’, 1);</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">      put(’V’, 5);</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">      put(’X\ 18);</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">      put(’L’, 58);</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">      put(’C’, 188);</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">      put(’D’, 588);</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">      put(’M’, 1888);</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    }</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  };</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  int sum = T.get(s.charAt(s.length() - 1));</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  for (int i = s.length() - 2; i &gt;= 0; --i) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    if (T.get(s.charAt(i)) &lt; T.get(s.charAt(i + 1))) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">      sum -= T.get(s.charAt(i));</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    } else {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">      sum += T.get(s.charAt(i));</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    }</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  }</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  return sum;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">}</span></div></td></tr></tbody></table><div><font style="font-size: 10pt;"><br/></font></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-size: 10pt; font-weight: bold;">Compute all valid IP addresses</span><span style="font-size: 10pt;">. </span></div><div><span style="font-size: 10pt;">Write a program that determines where to add periods to a decimal string so that the resulting string is a valid IP address. There may be more than one valid IP address corresponing to a string, in which case you should print all possibilities.</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-size: 10pt;">There are 3 periods in a valid IP address, so we can enumerate all possible placements of these periods and check whether all four corresponding substrings are between 0 and 255.</span></div><div><span style="font-size: 10pt;">For example, if the string is &quot;192116811&quot;, we could put the first period after &quot;1&quot;, &quot;19&quot; and &quot;192&quot;. If the first part is &quot;1&quot; the second part could be &quot;9&quot;, &quot;92&quot; and &quot;921&quot;. Of these &quot;921&quot; is illegal so we do not continue with it. </span></div><div><font style="font-size: 10pt;"><br/></font></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">public static List &lt; String &gt; getValidIpAddress(String s) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    List &lt; String &gt; result = ne« ArrayListoO;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    for (int i = l; i &lt; 4 &amp;&amp; i &lt; s.lengthO; ++i) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">      final String first = s.substring(0, i);</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">      if (isValidPart(first)) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">        for (int j = 1; i + j &lt; s.length() &amp;&amp; j &lt; 4; ++j) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">          final String second = s.substring(i, i + j);</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">          if (isVal idPart(second)) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">            for (int k = 1; i + j + k &lt; s.length() &amp;&amp; k &lt; 4; ++k) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">              final String third = s.substring(i + j, i + j + k);</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">              final String fourth = s.substring(i + j + k);</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">              if (isVal idPart(third) &amp;&amp; i sVal idPart(fourth)) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">                result.add(first + +second + +third + +fourth);</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">              }</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">            }</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">          }</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">        }</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">      }</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    }</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    return result;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    private static boolean isValidPart(String s) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">      if (s.lengthO &gt; 3) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">        return false;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">      }</span></div><div><font color="#41AD1C" face="Courier New" style="font-size: 10pt;"><span style="color: rgb(65, 173, 28); font-family: &quot;Courier New&quot;; font-size: 10pt; font-weight: bold;">      // ”00&quot; , ”000&quot;, &quot;01&quot;, etc. are not valid, but &quot;0&quot; is valid.</span></font></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">      if (s.startsWith(&quot;0&quot;) &amp;&amp; s.length() &gt; 1) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">        return false;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">      }</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">      int val = Integer.parselnt(s);</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">      return val &lt;= 255 &amp;&amp; val &gt;= 0;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    }</span></div></td></tr></tbody></table><div><font style="font-size: 10pt;"><br/></font></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-size: 10pt; font-weight: bold;">Write a string sinusoidally.</span><span style="font-size: 10pt;"> </span></div><div><span style="font-size: 10pt;">Define the snakestring of s to be the left-right top-to-bottom sequence in which characters appear when is is written ina sinusoidal fashon. For example, the snakestring string for Hello_world is e_lHloWrdlo. Write a program which takes as input a string s and returns the snakestring of s. </span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-size: 10pt;">We observe that the result begins with the characters s[1], s[5], s[9] followed by s[0], s[2], s[4], etc. Therefore we can create the snakestring directly with three iterations through s.</span></div><div><font style="font-size: 10pt;"><br/></font></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">public static String snakeString(String s) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  Str ingBuilder result = new StringBuilder();</span></div><div><font color="#41AD1C" style="font-size: 10pt;"><span style="color: rgb(65, 173, 28); font-family: &quot;Courier New&quot;; font-size: 10pt; font-weight: bold;">  // Outputs the first row, i.e., s[l], s[5], s[9], ...</span></font></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  for (int i = 1; i &lt; s.length(); i += 4) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    result.append(s.charAt(i));</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  }</span></div><div><font color="#41AD1C" style="font-size: 10pt;"><span style="color: rgb(65, 173, 28); font-family: &quot;Courier New&quot;; font-size: 10pt; font-weight: bold;">  // Outputs the second row, i.e., s[&lt;9], s[2], s[4], ...</span></font></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  for (int i = 0; i &lt; s.length(); i += 2) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    result.append(s.charAt(i));</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  }</span></div><div><font color="#41AD1C" style="font-size: 10pt;"><span style="color: rgb(65, 173, 28); font-family: &quot;Courier New&quot;; font-size: 10pt; font-weight: bold;">  // Outputs the third row, i.e., s[3], s[7], s[ll], ...</span></font></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  for (int i = 3; i &lt; s.length(); i += 4) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    result.append(s.charAt(i));</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  }</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  return resul t.toString();</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">}</span></div></td></tr></tbody></table><div><font style="font-size: 10pt;"><br/></font></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-size: 10pt; font-weight: bold;">Implement Run-Lenght encoding</span><span style="font-size: 10pt;">. </span></div><div><span style="font-size: 10pt;">Run lenght encoding compression offers a fast way to do efficient on-the-fly compression and decompression of strings. The idea is simple: encode successive repeated characters by the repetition count and te character. </span></div><div><span style="font-size: 10pt;">Implement RLE encoding and decoding functions. Assume the string to be encoded consist of letters of alphabet with no digits and the string to be decoded is a valid encoding. </span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">public static String decoding(String s) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  int count = 0;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  StringBuilder result = new StringBuilder();</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  for (int i = 0; i &lt; s.lengthO; i++) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    char c = s.charAt(i);</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    if (Character.isDigit(c)) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">      count = count * 10 + c - '0';</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    } else {</span> <span style="font-family: &quot;Courier New&quot;; font-size: 10pt; font-weight: bold; color: rgb(65, 173, 28);">// c is a letter of alphabet.</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">      while (count &gt; 0) {</span> <span style="font-family: &quot;Courier New&quot;; font-size: 10pt; font-weight: bold; color: rgb(65, 173, 28);">// Appends count copies of c to result.</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">        result.append(c);</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">        count--;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">      }</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    }</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  }</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  return result.toString();</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">}</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">public static String encoding(String s) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  int count = 1;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  StringBuilder ss = new StringBuilder();</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  for (int i = 1; i &lt;= s.length(); ++i) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    if (i == s.length() || s.charAt(i) != s.charAt(i - 1)) {</span></div><div><font color="#41AD1C" style="font-size: 10pt;"><span style="color: rgb(65, 173, 28); font-family: &quot;Courier New&quot;; font-size: 10pt; font-weight: bold;">      // Found new character so write the count of previous character.</span></font></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">      ss.append(count);</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">      ss.append(s.charAt(i - 1));</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">      count = 1;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    } else {</span> <span style="font-family: &quot;Courier New&quot;; font-size: 10pt; font-weight: bold; color: rgb(65, 173, 28);">// s.charAt(i) == s.charAt(i - 1).</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">      ++count;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    }</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  }</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  return ss.toString();</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">}</span></div></td></tr></tbody></table><div><font style="font-size: 10pt;"><br/></font></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-size: 10pt; font-weight: bold;">Find the first occurrence of a substring.</span><span style="font-size: 10pt;"> </span></div><div><span style="font-size: 10pt;">Given two strings s, and t, find the first occurrence of s in t</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-size: 10pt;">Intuitively, the brute-force algorithm is slow because it advances though t one char at time, and potentially does O(m) computation with each advance, wheere m is the length of s. </span></div><div><span style="font-size: 10pt;">There are three linear time string matching algorithms: KMP, Boyer-Moor and Rabin-Karp. Of these, Rabin-Karp is by far the simplest to understand and implement. </span></div><div><span style="font-size: 10pt;">The Rabin-Karp algorithm is very similar to the brute-force one, but it does not require the second loop. Instead is uses the concept of a &quot;fingerprint&quot;. Specifically, let m be the length of s. It computes hash codes of each substring whose length is m-these are the fingerprints. </span></div><div><span style="font-size: 10pt;">The key of efficiency is using an incremental hash function, such as a function with the property that the hash code of a string is an additive function of each individual chars (these are somtimes called rolling hash).</span></div><div><span style="font-size: 10pt;">For such a function, getting the hash code of a sliding window of char is very fast for each shift. But since the hash may have collision we need to check if the strings are equals after checking the hash. </span></div><div><span style="font-size: 10pt;">For this algorithm to run in linear time, we need a good hash function, to reduce the likelihood of collissions, which entail potentially time consuming string equality checks.</span></div><div><font style="font-size: 10pt;"><br/></font></div><div><span style="color: rgb(65, 173, 28); font-family: &quot;Courier New&quot;; font-weight: bold; font-size: 10pt;">// Returns the index of the first character of the substring if found , -1 </span><span style="font-size: 10pt; color: rgb(65, 173, 28); font-family: &quot;Courier New&quot;; font-weight: bold;">otherwise.</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">public static int rabinKarp(String t, String s) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  if (s.lengthO &gt; t.length()) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    return -1;</span> <span style="font-family: &quot;Courier New&quot;; font-size: 10pt; font-weight: bold; color: rgb(65, 173, 28);">// s is not a substring of t.</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  }</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  final int BASE = 26;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  int tHash = 0, sHash = 0;</span> <span style="font-family: &quot;Courier New&quot;; font-size: 10pt; font-weight: bold; color: rgb(65, 173, 28);">// Hash codes for the substring of t and s.</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  int powerS = 1;</span> <span style="font-family: &quot;Courier New&quot;; font-size: 10pt; color: rgb(65, 173, 28); font-weight: bold;">// BASEAlsl.</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  for (int i = 0; i &lt; s.lengthO; i++) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    powerS = i &gt; 0 ? powerS * BASE : 1;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    tHash = tHash * BASE + t.charAt(i);</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    sHash = sHash * BASE + s.charAt(i);</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  }</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  for (int i = s.lengthO; i &lt; t.length(); i++) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">   </span><span style="font-family: &quot;Courier New&quot;; font-size: 10pt; font-weight: bold; color: rgb(65, 173, 28);"> // Checks the two substrings are actually equal or not, to protect</span></div><div><font color="#41AD1C" face="Courier New" style="font-size: 10pt;"><span style="color: rgb(65, 173, 28); font-family: &quot;Courier New&quot;; font-size: 10pt; font-weight: bold;">    // against hash collision.</span></font></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    if (tHash == sHash &amp;&amp; t.substring(i - s.lengthO, i).equals(s)) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">      return i - s.lengthO;</span> <span style="font-family: &quot;Courier New&quot;; font-size: 10pt; color: rgb(65, 173, 28); font-weight: bold;">// Found a match.</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    }</span></div><div><font color="#41AD1C" style="font-size: 10pt;"><span style="color: rgb(65, 173, 28); font-family: &quot;Courier New&quot;; font-size: 10pt; font-weight: bold;">    // Uses rolling hash to compute the new hash code.</span></font></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    tHash -= t.charAt(i - s.lengthO) * powerS;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    tHash = tHash * BASE + t.charAt(i);</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  }</span></div><div><font color="#41AD1C" style="font-size: 10pt;"><span style="color: rgb(65, 173, 28); font-family: &quot;Courier New&quot;; font-size: 10pt; font-weight: bold;">  // Tries to match s and t.substring(t.length() - s.lengthO).</span></font></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  if (tHash == sHash &lt; &amp; &lt; &amp; t.substring(t.length() - s.length()).equals(s)) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">    return t.length() - s.lengthO;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  }</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">  return -1;</span> <span style="font-family: &quot;Courier New&quot;; font-size: 10pt; color: rgb(65, 173, 28); font-weight: bold;">// s is not a substring of t.</span></div><div><span style="font-family: &quot;Courier New&quot;; font-size: 10pt;">}</span></div><div><font style="font-size: 10pt;"><br/></font></div><div><span style="font-size: 10pt;">For a good hash function, the time complexity is O(m+n), independent of the inputs s and t, where m is the length of s and n is the length of t.</span></div><div><font style="font-size: 10pt;"><br/></font></div></td></tr></tbody></table><div><font style="font-size: 10pt;"><br/></font></div><div><font style="font-size: 10pt;"><br/></font></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-weight: bold;">Linked List Bootcamp.</span> </div><div>Implement a basic list API firs singly linked lists.</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><font face="Courier New">public static ListNode &lt; Integer &gt; search(ListNode &lt; Integer &gt; L, int key) {</font></div><div><font face="Courier New">  while (L != null &lt; &amp; &lt; &amp; L.data != key) {</font></div><div><font face="Courier New">    L = L.next;</font></div><div><font face="Courier New">  }</font></div><div><font color="#41AD1C" style="font-family: &quot;Courier New&quot;;"><b>  // If key was not present in the list, L will have become null.</b></font></div><div><font face="Courier New">  return L;</font></div><div><font face="Courier New">}</font></div><div><font face="Courier New"><br/></font></div><div><font color="#41AD1C" style="font-family: &quot;Courier New&quot;;"><b>// Insert newNode after node.</b></font></div><div><font face="Courier New">public static void insertAfter(ListNode &lt; Integer &gt; node,</font></div><div><font face="Courier New">  ListNode &lt; Integer &gt; newNode) {</font></div><div><font face="Courier New">  newNode.next = node.next;</font></div><div><font face="Courier New">  node.next = newNode;</font></div><div><font face="Courier New">}</font></div><div><font face="Courier New"><br/></font></div><div><font color="#41AD1C" style="font-family: &quot;Courier New&quot;;"><b>// Delete the node immediately following aNode. Assumes aNode is not a tail.</b></font></div><div><font face="Courier New">public static void deleteList(ListNode &lt; Integer &gt; aNode) {</font></div><div><font face="Courier New">  aNode.next = aNode.next.next;</font></div><div><font face="Courier New">}</font></div><div><br/></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><b>Merge two sorted linked lists. </b></div><div>Write a program that takes two linked lists, assumed to be sorted, and returns their merge. The only field your program can change in a node is its next field.</div><div>A variant of this problem would be to use double linked lists.</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><font face="Courier New">public static ListNode &lt; Integer &gt; mergeTwoSortedLists(ListNode &lt; Integer &gt; LI,</font></div><div><font face="Courier New">  ListNode &lt; Integer &gt; L2) {</font></div><div><font color="#41AD1C" style="font-family: &quot;Courier New&quot;;"><b>  // Creates a placeholder for the result.</b></font></div><div><font face="Courier New">  ListNode &lt; Integer &gt; dummyHead = new ListNode &lt; &gt; (0, null);</font></div><div><font face="Courier New">  ListNode &lt; Integer &gt; current = dummyHead;</font></div><div><font face="Courier New">  ListNode &lt; Integer &gt; pi = LI, p2 = L2;</font></div><div><font face="Courier New">  while (pi != null &amp;&amp; p2 != null) {</font></div><div><font face="Courier New">    if (pi.data &lt;= p2.data) {</font></div><div><font face="Courier New">      current.next = pi;</font></div><div><font face="Courier New">      pi = pi.next;</font></div><div><font face="Courier New">    } else {</font></div><div><font face="Courier New">      current.next = p2;</font></div><div><font face="Courier New">      p2 = p2.next;</font></div><div><font face="Courier New">    }</font></div><div><font face="Courier New">    current = current.next;</font></div><div><font face="Courier New">  }</font></div><div><font color="#41AD1C" style="font-family: &quot;Courier New&quot;;"><b>  // Appends the remaining nodes of pi or p2.</b></font></div><div><font face="Courier New">  current.next = pi != null ? pi : p2;</font></div><div><font face="Courier New">  return dummyHead.next;</font></div><div><font face="Courier New">}</font></div></td></tr></tbody></table><div><br/></div></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-weight: bold;">Reverse a single sublist.</span> </div><div>Write a program which takes a singly linked list L and two integers s and f as arguments, and reverse the order of the nodes from the sth node to fth node, inclusive. Do not allocate additional nodes. </div><div>Variants are:</div><ul><li><div>write a function that reverses a singly linked list without using additional storage</div></li><li><div>write a program which takes as input a singly linked list L and a nonnegative integer k and reverses the list k nodes at a time. If the number of nodes n in the list is not a multiple of k, leave the last nmodk nodes unchanges. Do not change the data stored in a node.</div></li></ul></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><font face="Courier New">public static ListNode &lt; Integer &gt; reverseSublist(ListNode &lt; Integer &gt; L, int start,</font></div><div><font face="Courier New">  int finish) {</font></div><div><font style="font-family: &quot;Courier New&quot;;">  if (start == finish) { <b><font style="color: rgb(65, 173, 28);">// No need to reverse since start == finish.</font></b></font></div><div><font face="Courier New">    return L;</font></div><div><font face="Courier New">  }</font></div><div><font face="Courier New">  ListNode&lt;Integer &gt; dummyHead = new ListNode &lt; &gt; (0, L);</font></div><div><font face="Courier New">  ListNode&lt;Integer &gt; sublistHead = dummyHead;</font></div><div><font face="Courier New">  int k = 1;</font></div><div><font face="Courier New">  while (k++ &lt; start) {</font></div><div><font face="Courier New">    sublistHead = sublistHead.next;</font></div><div><font face="Courier New">  }</font></div><div><font color="#41AD1C" style="font-family: &quot;Courier New&quot;;"><b>  // Reverse sublist.</b></font></div><div><font face="Courier New">  ListNode&lt;Integer &gt; sublistlter = sublistHead.next;</font></div><div><font face="Courier New">  while (start++ &lt; finish) {</font></div><div><font face="Courier New">    ListNode &lt; Integer &gt; temp = sublistlter.next;</font></div><div><font face="Courier New">    sublistlter.next = temp.next;</font></div><div><font face="Courier New">    temp.next = sublistHead.next;</font></div><div><font face="Courier New">    sublistHead.next = temp;</font></div><div><font face="Courier New">  }</font></div><div><font face="Courier New">  return dummyHead.next;</font></div><div><font face="Courier New">}</font></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-weight: bold;">Test for ciclicity.</span> </div><div>Write a program that takes the head of a singly linked list and returns null if there doesn't exist a cycle, and the node at the start of the cycle if the cycle is present. You don't know the length of the list in advance.</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div>This problem has several solutions. If space is not an issue the simplest approach is to explore nodes via the next field starting from the head and storing visited nodes in a hash table - a cycle will exists if and only if we visit a node already in the hash table.</div><div><br/></div><div>A brute-force approach that does not use additional storage and does not modify the list is to traverse the list in two loops - the outer loop traverses the node on-by-one and the inner loop starts from the head, and traverses as manynodes as the outer loop has gone through so far. If the node being visited by the outer loop is visited twice, a loop has been detected. This approach has O(n^2) time complexity.</div><div><br/></div><div>This idea can be made to work in linear time using 2 iterators, one slow and one fast. In each iteration advance the slow iterator by one and the fast by two. The list has a cycle if and only if the two iterators meet. The reasoning is as follows: if the fast iterator jumps over the slow iterator, the slow iterator will equal the fast iterator in the next step.</div><div><br/></div><div>Now, assuming we have detected a cycle using the above method, we can find the start of the cycle by first calculating the cycle length C. Once we know there is a cycle and we have a node on it, it is trivial to compute the cycle length. To find the first node on the cycle we use two iterators, one of which is C ahead of the other. We advance them in tandem and when they meet, that node must be the first ndoe of the cycle. The code to do this traversal is quite simple:</div><div><br/></div><div><font face="Courier New">public static ListNode &lt; Integer &gt; hasCycle(ListNode &lt; Integer &gt; head) {</font></div><div><font face="Courier New">    ListNode &lt; Integer &gt; fast = head, slow = head;</font></div><div><font face="Courier New">    while (fast != null &amp;&amp; fast.next != null) {</font></div><div><font face="Courier New">      slow = slow.next;</font></div><div><font face="Courier New">      fast = fast.next.next;</font></div><div><font face="Courier New">      if (slow == fast) {</font></div><div><font color="#41AD1C" style="font-family: &quot;Courier New&quot;;"><b>        // There is a cycle, so now let’s calculate the cycle length.</b></font></div><div><font face="Courier New">        int cycleLen = 0;</font></div><div><font face="Courier New">        do {</font></div><div><font face="Courier New">          ++cycleLen;</font></div><div><font face="Courier New">          fast = fast.next;</font></div><div><font face="Courier New">        } while (slow != fast);</font></div><div><font color="#41AD1C" style="font-family: &quot;Courier New&quot;;"><b>        // Finds the start of the cycle.</b></font></div><div><font face="Courier New">        ListNode &lt; Integer &gt; cycleLenAdvancedlter = head;</font></div><div><font color="#41AD1C" style="font-family: &quot;Courier New&quot;;"><b>        // cycleLenAdvancedlter pointer advances cycleLen first.</b></font></div><div><font face="Courier New">        while (cycleLen--&gt; 0) {</font></div><div><font face="Courier New">          cycleLenAdvancedlter = cycleLenAdvancedlter.next;</font></div><div><font face="Courier New">        }</font></div><div><font face="Courier New">        ListNode &lt; Integer &gt; iter = head;</font></div><div><font color="#41AD1C" style="font-family: &quot;Courier New&quot;;"><b>        // Both iterators advance in tandem.</b></font></div><div><font face="Courier New">        while (iter != cycleLenAdvancedlter) {</font></div><div><font face="Courier New">          iter = iter.next;</font></div><div><font face="Courier New">          cycleLenAdvancedlter = cycleLenAdvancedlter.next;</font></div><div><font face="Courier New">        }</font></div><div><font style="font-family: &quot;Courier New&quot;;">        return iter; <b><font style="color: rgb(65, 173, 28);">// iter is the start of cycle.</font></b></font></div><div><font face="Courier New">      }</font></div><div><font style="font-family: &quot;Courier New&quot;;">      return null; <b><font style="color: rgb(65, 173, 28);">// no cycle</font></b>.</font></div><div><font face="Courier New">    }</font></div><div><font face="Courier New">}</font></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-weight: bold;">Test for overlapping lists without cycles</span>. </div><div>Write a program that takes two cycle-free singly linked lists and determines if there exists a node that is common to both lists.</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div>The lists overlap if and only if both have the same tail node: once the lists converge at a node, they cannot diverge at a later node. Therefore checking for overlap amounts to finding the tail nodes for each list. To find the first ovelapping node, we compute the length of each list. The first overlapping node is determined by advancing through the longer list by the difference in lengths and then advancing through both lists in tandem, stopping at the first common node. If we reach the end of a list without finding a common node, the lists do not overlap.</div><div><br/></div><div><font face="Courier New">public static ListNode &lt; Integer &gt; overlappingNoCycleLists(</font></div><div><font face="Courier New">  ListNode &lt; Integer &gt; L1, ListNode &lt; Integer &gt; L2) {</font></div><div><font face="Courier New">  int L1Length = length(Ll), L2Length = length(L2);</font></div><div><font color="#41AD1C" style="font-family: &quot;Courier New&quot;;"><b>  // Advances the longer list to get equal length lists.</b></font></div><div><font face="Courier New">  if (L1Length &gt; L2Length) {</font></div><div><font face="Courier New">    LI = advanceListByK(L1Length - L2Length, LI);</font></div><div><font face="Courier New">  } else {</font></div><div><font face="Courier New">    L2 = advanceListByK(L2Length - L1Length, L2);</font></div><div><font face="Courier New">  }</font></div><div><font face="Courier New">  while (L1 != null &amp; &lt; &amp; L2 != null &amp; &lt; &amp; LI != L2) {</font></div><div><font face="Courier New">    L1 = L1.next;</font></div><div><font face="Courier New">    L2 = L2.next;</font></div><div><font face="Courier New">  }</font></div><div><font style="font-family: &quot;Courier New&quot;;">  return L1; <font color="#41AD1C"><b>// nullptr implies there is no overlap between LI and L2.</b></font></font></div><div><font color="#41AD1C" face="Courier New"><b>}</b></font></div><div><font face="Courier New">public static ListNode &lt; Integer &gt; advanceListByK(int k, ListNode &lt; Integer &gt; L) {</font></div><div><font face="Courier New">  while (k--&gt; 0) {</font></div><div><font face="Courier New">    L = L.next;</font></div><div><font face="Courier New">  }</font></div><div><font face="Courier New">  return L;</font></div><div><font face="Courier New">}</font></div><div><font face="Courier New">private static int length(ListNode &lt; Integer &gt; L) {</font></div><div><font face="Courier New">  int len = 0;</font></div><div><font face="Courier New">  while (L != null) {</font></div><div><font face="Courier New">    ++len;</font></div><div><font face="Courier New">    L = L.next;</font></div><div><font face="Courier New">  }</font></div><div><font face="Courier New">  return len;</font></div><div><font face="Courier New">}</font></div><div><br/></div><div>The time complexity is O(n) and the space complexity is O(1)</div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><b>Test for overlapping lists that may have cycles.</b>  </div><div>Check if two lists may overlap but considering that the lists may have cycles.</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div>This problem is easy to solve using O(n) time and space complexity, where n is the total number of nodes, using the hash table approach. We can improve space complexity by studying different cases. The easiest case is when neithr list is cyclic and we can  determine the solution as mentioned for the single case. </div><div>If one list is cyclic and the other is not, they cannot overlap so we are done.</div><div>This leaves us with the case that both lists are cyclic. In this case, if they overlap, the cycles must be identical. </div><div>There are two subcases: the paths to the cycle merge before the cycle, in whch case there is a unique first node that is common, or the paths reach the cycle at different nodes on the cycle. </div><div><br/></div><div><font face="Courier New">public static ListNode &lt;Integer&gt; overlappingLists(ListNode &lt;Integer&gt; L1,</font></div><div><font face="Courier New">  ListNode &lt;Integer&gt; L2) {</font></div><div><font color="#41AD1C" style="font-family: &quot;Courier New&quot;;"><b>  // Store the start of cycle if any.</b></font></div><div><font face="Courier New">  ListNode &lt;Integer&gt; rootl = CheckingCycle.hasCycle(L1);</font></div><div><font face="Courier New">  ListNode &lt;Integer&gt; root2 = CheckingCycle.hasCycle(L2);</font></div><div><font face="Courier New">  if (rootl == null &amp;&amp; root2 == null) {</font></div><div><font color="#41AD1C" style="font-family: &quot;Courier New&quot;;"><b>    // Both lists don’t have cycles.</b></font></div><div><font face="Courier New">    return overlappingNoCycleLists(L1, L2);</font></div><div><font face="Courier New">  } else if ((rootl != null &amp;&amp; root2 == null) ||</font></div><div><font face="Courier New">    (rootl == null &lt; &amp;&amp; root2 != null)) {</font></div><div><font color="#41AD1C" style="font-family: &quot;Courier New&quot;;"><b>    // One list has cycle, and one list has no cycle.</b></font></div><div><font face="Courier New">    return null;</font></div><div><font face="Courier New">  }</font></div><div><font color="#41AD1C" style="font-family: &quot;Courier New&quot;;"><b>  // Both lists have cycles.</b></font></div><div><font face="Courier New">  ListNodednteger &gt; temp = root2;</font></div><div><font face="Courier New">  do {</font></div><div><font face="Courier New">    temp = temp.next;</font></div><div><font face="Courier New">  } while (temp != rootl &amp;&amp; temp != root2);</font></div><div><font color="#41AD1C" style="font-family: &quot;Courier New&quot;;"><b>  // L1 and L2 do not end in the same cycle.</b></font></div><div><font face="Courier New">  if (temp != rootl) {</font></div><div><font style="font-family: &quot;Courier New&quot;;">    return null; <b><font style="color: rgb(65, 173, 28);">// Cycles are disjoint.</font></b></font></div><div><font face="Courier New">  }</font></div><div><font style="font-family: &quot;Courier New&quot;;">  <b><font color="#41AD1C">// L1 and L2 end in the same cycle, locate the overlapping node if they</font></b></font></div><div><font color="#41AD1C" face="Courier New"><b>  // first overlap before cycle starts.</b></font></div><div><font face="Courier New">  int stemlLength = distance(Ll, rootl), stem2Length = distance(L2, root2);</font></div><div><font face="Courier New">  int count = Math.abs(stemlLength - stem2Length);</font></div><div><font face="Courier New">  if (stemlLength &gt; stem2Length) {</font></div><div><font face="Courier New">    L1 = advanceListByK(stemlLength - stem2Length, L1);</font></div><div><font face="Courier New">  } else {</font></div><div><font face="Courier New">    L2 = advanceListByK(stem2Length - stemlLength, L2);</font></div><div><font face="Courier New">  }</font></div><div><font face="Courier New">  while (L1 != L2 &amp; &lt; &amp; L1 != rootl &amp;&amp; L2 != root2) {</font></div><div><font face="Courier New">    L1 = L1.next;</font></div><div><font face="Courier New">    L2 = L2.next;</font></div><div><font face="Courier New">  }</font></div><div><font style="font-family: &quot;Courier New&quot;;"> <b><font color="#41AD1C"> // If L1 == L2 before reaching rootl, it means the overlap first occurs</font></b></font></div><div><font color="#41AD1C" face="Courier New"><b>  // before the cycle starts; otherwise , the first overlapping node is not</b></font></div><div><font color="#41AD1C" face="Courier New"><b>  // unique, so we can return any node on the cycle.</b></font></div><div><font face="Courier New">  return L1 == L2 ? L1 : rootl;</font></div><div><font face="Courier New">}</font></div><div><font color="#41AD1C" style="font-family: &quot;Courier New&quot;;"><b>// Calculates the distance between a and b.</b></font></div><div><font face="Courier New">private static int distance(ListNode &lt;Integer&gt; a, ListNode &lt;Integer&gt; b) {</font></div><div><font face="Courier New">  int dis = 0;</font></div><div><font face="Courier New">  while (a != b) {</font></div><div><font face="Courier New">    a = a.next;</font></div><div><font face="Courier New">    ++dis;</font></div><div><font face="Courier New">  }</font></div><div><font face="Courier New">  return dis;</font></div><div><font face="Courier New">}</font></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-weight: bold;">Delete a node from a singly linked list.</span> </div><div>Write a program which deletes a node in a singly linked list. The input node is guaranteed not to be the tail node.</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div>Given the pointer to a node, it is impossible to delete it from the list without modifying its predecessor,2 next pointer and the only way to get to the predecessor is to traverse the list from head, which requires O(n) time. </div><div>Given a node, it is easy to delete its successor, since just requires updating the next pointer of the current node. If we copy the value part of the next node t the current node and then delete the next node, we have effectively deleted the current node. Time complexity is O(1)</div><div><br/></div><div><font color="#41AD1C" style="font-family: &quot;Courier New&quot;;"><b>// Assumes nodeToDelete is not tail.</b></font></div><div><font face="Courier New">public static void deletionFromList(ListNode &lt; Integer &gt; nodeToDelete) {</font></div><div><font face="Courier New">  nodeToDelete.data = nodeToDelete.next.data;</font></div><div><font face="Courier New">  nodeToDelete.next = nodeToDelete.next.next;</font></div><div><font face="Courier New">}</font></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><b>Remove the Kth last element from a linked list</b>. </div><div>Given a singly linked list and an integer k. write a program to remove the kth last element from the list. In particular, you can assume that it is possible to record the length of the list. </div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div>Brute-force approach is to compute the length with one pass, and then use that to determine which node to delete in a second pass. A drawback of this approach is taht it entails two passes over the data, which is slow.</div><div>We use two iterators to traverse the list. The first iterator is advanced by k steps, and then the two iterators advance in tandem. When the first iterator reaches the tail, the second iterator is at the (k+i) last node, and we can remove the kth node.</div><div><br/></div><div><font color="#41AD1C" style="font-family: &quot;Courier New&quot;;"><b>// Assumes L has at least k nodes, deletes the k-th last node in L.</b></font></div><div><font face="Courier New">public static ListNode &lt; Integer &gt; removeKthLast(ListNode &lt; Integer &gt; L, int k) {</font></div><div><font face="Courier New">  ListNode &lt; Integer &gt; dummyHead = new ListNodeo(0, L);</font></div><div><font face="Courier New">  ListNode &lt; Integer &gt; first = dummyHead.next;</font></div><div><font face="Courier New">  while (k--&gt; 0) {</font></div><div><font face="Courier New">    first = first.next;</font></div><div><font face="Courier New">  }</font></div><div><font face="Courier New">  ListNode &lt; Integer &gt; second = dummyHead;</font></div><div><font face="Courier New">  while (first != null) {</font></div><div><font face="Courier New">    second = second.next;</font></div><div><font face="Courier New">    first = first.next;</font></div><div><font face="Courier New">  }</font></div><div><font color="#41AD1C" style="font-family: &quot;Courier New&quot;;"><b>  // second points to the (k + l)-th last node, deletes its successor.</b></font></div><div><font face="Courier New">  second.next = second.next.next;</font></div><div><font face="Courier New">  return dummyHead.next;</font></div><div><font face="Courier New">}</font></div><div><br/></div><div>Compared to the brute force approach, if k is small enough that we can keep the set of nodes between the two iterators in memory, but the list is too big to fit in memory, the twoiterator approach halves the number of disc accesses.</div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><b>Remove duplicates  from a sorted list.</b> </div><div>Write a program that takes as input a singly linked list of integers in sorted order, and remove duplicates from it. The list should be sorted.</div><div>A variant would be: let m be a positive integer and L a sorted singly inked list of integers. For each integer k, if k appears more than m tiems in L, remove all nodes from L containing k.</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div>The best approach is the one seen for the int arrays. As we traverse the list, we remove all successive nodes with the same value as the current node. </div><div><br/></div><div><font face="Courier New">public static ListNode &lt; Integer &gt; removeDuplicates(ListNode &lt; Integer &gt; L) {</font></div><div><font face="Courier New">    ListNode &lt; Integer &gt; iter = L;</font></div><div><font face="Courier New">    while (iter != null) {</font></div><div><font color="#41AD1C" style="font-family: &quot;Courier New&quot;;"><b>      // Uses nextDistinct to find the next distinct value.</b></font></div><div><font face="Courier New">      ListNode &lt; Integer &gt; nextDistinct = iter.next;</font></div><div><font face="Courier New">      while (nextDistinct != null &lt; &amp;&amp; nextDistinct.data == iter.data) {</font></div><div><font face="Courier New">        nextDistinct = nextDistinct.next;</font></div><div><font face="Courier New">      }</font></div><div><font face="Courier New">      iter.next = nextDistinct;</font></div><div><font face="Courier New">      iter = nextDistinct; &gt;</font></div><div><font face="Courier New">      return L;</font></div><div><font face="Courier New">    }</font></div><div><font face="Courier New">}</font></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><b>Implement cyclic right shift for singly linked lists</b>. </div><div>Write a program that takes as input a singly linked list and a nonegative integer k, and returns the list cyclically shifted to the right by k. </div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div>A brute-force strategy is to right shift the list by one node k times. Each right shift by a single node entails finding the tail, and its predecessor. </div><div>The key to improving upon the brute-force approach is to use the fact that linked lists can be cut and the sublists reassembled very efficiently. First we find the tail node t. Sicne the successor of the tail is the original head, we update t's successor. The original head is to become the kth node from the start of the new list.Therefore, the new head is the (n-k)th node in the initial list. </div><div><br/></div><div><font face="Courier New">public static ListNode &lt; Integer &gt; cyclicallyRightShiftList(ListNodednteger &gt; L,</font><span style="font-family: &quot;Courier New&quot;;"> int k) {</span></div><div><font face="Courier New">  if (L == null) {</font></div><div><font face="Courier New">    return L;</font></div><div><font face="Courier New">  }</font></div><div><font color="#41AD1C" style="font-family: &quot;Courier New&quot;;"><b>  // Computes the length of L and the tail.</b></font></div><div><font face="Courier New">  ListNode &lt; Integer &gt; tail = L;</font></div><div><font face="Courier New">  int n = 1;</font></div><div><font face="Courier New">  while (tail.next != null) {</font></div><div><font face="Courier New">    ++n;</font></div><div><font face="Courier New">    tail = tail.next;</font></div><div><font face="Courier New">  }</font></div><div><font face="Courier New">  k % -n;</font></div><div><font face="Courier New">  if (k == 0) {</font></div><div><font face="Courier New">    return L;</font></div><div><font face="Courier New">  }</font></div><div><font style="font-family: &quot;Courier New&quot;;">  tail.next = L; <b><font style="color: rgb(65, 173, 28);">// Makes a cycle by connecting the tail to the head.</font></b></font></div><div><font face="Courier New">  int stepsToNewHead = n - k;</font></div><div><font face="Courier New">  ListNode &lt; Integer &gt; newTail = tail;</font></div><div><font face="Courier New">  while (stepsToNewHead--&gt; 0) {</font></div><div><font face="Courier New">    newTail = newTail.next;</font></div><div><font face="Courier New">  }</font></div><div><font face="Courier New">  ListNode &lt; Integer &gt; newHead = newTail.next;</font></div><div><font face="Courier New">  newTail.next = null;</font></div><div><font face="Courier New">  return newHead;</font></div><div><font face="Courier New">}</font></div><div><br/></div><div>Time complexity is O(n) while memory complexity is O(1)</div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><b>Even-odd merge. </b></div><div>Consider a singly linked list whose nodes are numbered starting at 0. Define the even-odd merge of the list to be the list consisting of the even-numbered nodes followed by the odd-numbered nodes. </div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div>The key is to avoid extra space by reusing the existing list nodes. We do this by iterating through the list and appending even elements to one list and odd elements to another list. Finally we append the odd list to the even list.</div><div><br/></div><div><font face="Courier New">public static ListNode &lt; Integer &gt; evenOddMerge(ListNode &lt; Integer &gt; L) {</font></div><div><font face="Courier New">  if (L == null) {</font></div><div><font face="Courier New">    return L;</font></div><div><font face="Courier New">  }</font></div><div><font face="Courier New">  ListNode &lt; Integer &gt; evenDummyHead = new Li stNode &lt; &gt; (0, null),</font></div><div><font face="Courier New">    oddDummyHead = new ListNode &lt; &gt; (0, null);</font></div><div><font face="Courier New">  List &lt; ListNode &lt; Integer» tails = Arrays.asList(evenDummyHead, oddDummyHead);</font></div><div><font face="Courier New">  int turn = 0;</font></div><div><font face="Courier New">  for (ListNode &lt; Integer &gt; iter = L; iter != null; iter = iter.next) {</font></div><div><font face="Courier New">    tails.get(turn).next = iter;</font></div><div><font face="Courier New">    tails.set(turn, tails.get(turn).next);</font></div><div><font face="Courier New">    turn A = 1;</font></div><div><font face="Courier New">  }</font></div><div><font face="Courier New">  tails.get(1).next = null;</font></div><div><font face="Courier New">  tails.get(0).next = oddDummyHead.next;</font></div><div><font face="Courier New">  return evenDummyHead.next;</font></div><div><font face="Courier New">}</font></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><b>Test whether a single linked list is palindromic.</b> </div><div>Write a program that tests whether a singly linked list is palindromic.</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><font face="Courier New">public static boolean isLinkedListAPalindrome(ListNode &lt;Integer&gt; L) {</font></div><div><font face="Courier New">  if (L == null) {</font></div><div><font face="Courier New">    return true;</font></div><div><font face="Courier New">  }</font></div><div><font color="#41AD1C" style="font-family: &quot;Courier New&quot;;"><b>  // Finds the second half of L.</b></font></div><div><font face="Courier New">  ListNode &lt; Integer &gt; slow = L, fast = L;</font></div><div><font face="Courier New">  while (fast != null &lt; &amp;&amp; fast.next != null) {</font></div><div><font face="Courier New">    fast = fast.next.next;</font></div><div><font face="Courier New">    slow = slow.next;</font></div><div><font face="Courier New">  }</font></div><div><font color="#41AD1C" style="font-family: &quot;Courier New&quot;;"><b>  // Compare the first half and the reversed second half lists.</b></font></div><div><font face="Courier New">  ListNode &lt; Integer &gt; firstHalflter = L;</font></div><div><font face="Courier New">  ListNode &lt; Integer &gt; secondHalfIter = ReverseLinkedListlterative.reverseLinkedList(slow);</font></div><div><font face="Courier New">  while (secondHalfIter != null &lt; &amp;&amp; firstHalflter != null) {</font></div><div><font face="Courier New">    if (secondHalflter.data != firstHalflter.data) {</font></div><div><font face="Courier New">      return false;</font></div><div><font face="Courier New">    }</font></div><div><font face="Courier New">    secondHalflter = secondHalfIter.next;</font></div><div><font face="Courier New">    firstHalflter = firstHalflter.next;</font></div><div><font face="Courier New">  }</font></div><div><font face="Courier New">  return true;</font></div><div><font face="Courier New">}</font></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><b>Implement list pivoting</b>. </div><div>Implement a function which takes as input a singly linked list and an integer k and performs a pivot of the list with respect to k. The relative ordering of nodes that appear before k, and after k, must remeain unchanges. </div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div>A key observation is that we do not really need to create new nodes for the three lists. Instead we reorganize the original list nodes into these three lists in a single traversal of the original list. Since the traversal is in order, the individual lists preserve the ordering. We combine these three lists in the final step</div><div><br/></div><div><font face="Courier New">public static ListNode &lt;Integer&gt; listPivoting(ListNode &lt;Integer&gt; L, int x) {</font></div><div><font face="Courier New">  ListNode &lt;Integer&gt; lessHead = new ListNode &lt;&gt; (0, null);</font></div><div><font face="Courier New">  ListNode &lt;Integer&gt; equalHead = new ListNode &lt;&gt; (0, null);</font></div><div><font face="Courier New">  ListNode &lt;Integer&gt; greaterHead = new ListNode &lt;&gt; (0, null);</font></div><div><font face="Courier New">  ListNode &lt;Integer&gt; lesslter = lessHead;</font></div><div><font face="Courier New">  ListNode &lt;Integer&gt; equallter = equalHead;</font></div><div><font face="Courier New">  ListNode &lt;Integer&gt; greaterlter = greaterHead;</font></div><div><font style="font-family: &quot;Courier New&quot;;"><b>  // Populates the three lists.</b></font></div><div><font face="Courier New">  ListNode &lt;Integer&gt; iter = L;</font></div><div><font face="Courier New">  while (iter != null) {</font></div><div><font face="Courier New">    if (iter.data &lt; x) {</font></div><div><font face="Courier New">      lesslter.next = iter;</font></div><div><font face="Courier New">      lesslter = iter;</font></div><div><font face="Courier New">    } else if (iter.data == x) {</font></div><div><font face="Courier New">      equallter.next = iter;</font></div><div><font face="Courier New">      equallter = iter;</font></div><div><font face="Courier New">    } else { // iter.data &gt; x.</font></div><div><font face="Courier New">      greaterlter.next = iter;</font></div><div><font face="Courier New">      greaterlter = iter;</font></div><div><font face="Courier New">    }</font></div><div><font face="Courier New">    iter = iter.next;</font></div><div><font face="Courier New">  }</font></div><div><font style="font-family: &quot;Courier New&quot;;"><b>  // Combines the three lists.</b></font></div><div><font face="Courier New">  greaterlter.next = null;</font></div><div><font face="Courier New">  equallter.next = greaterHead.next;</font></div><div><font face="Courier New">  lesslter.next = equalHead.next;</font></div><div><font face="Courier New">  return lessHead.next;</font></div><div><font face="Courier New">}</font></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><b>Add list-based integers</b>. </div><div>Write a program which takes two singly linked lists of digits and returns the list corresponding to the sum of the integers they represent. The least significant digit comes first.</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><font face="Courier New">public static ListNode &lt; Integer &gt; addTwoNumbers(ListNode &lt; Integer &gt; L1,  ListNode&lt; Integer &gt; L2) {</font></div><div><font face="Courier New">  ListNode&lt; Integer &gt; dummyHead = new L1stNode &lt; &gt; (0, null);</font></div><div><font face="Courier New">  ListNode&lt; Integer &gt; placeIter = dummyHead;</font></div><div><font face="Courier New">  int carry = 0;</font></div><div><font face="Courier New">  while (L1 != null || L2 != null) {</font></div><div><font face="Courier New">    int sum = carry;</font></div><div><font face="Courier New">    if (L1 != null) {</font></div><div><font face="Courier New">      sum += L1.data;</font></div><div><font face="Courier New">      L1 = L1.next;</font></div><div><font face="Courier New">    }</font></div><div><font face="Courier New">    if (L2 != null) {</font></div><div><font face="Courier New">      sum += L2.data;</font></div><div><font face="Courier New">      L2 = L2.next;</font></div><div><font face="Courier New">    }</font></div><div><font face="Courier New">    placeIter.next = newListNode &lt; &gt; (sum % 10, null);</font></div><div><font face="Courier New">    carry = sum / 10;</font></div><div><font face="Courier New">    placeIter = placeIter.next;</font></div><div><font face="Courier New">  }</font></div><div><font color="#41AD1C" style="font-family: &quot;Courier New&quot;;"><b>  // carry cannot exceed 1, so we never need to add more than one node.</b></font></div><div><font face="Courier New">  if (carry &gt; 0) {</font></div><div><font face="Courier New">    placeIter.next = new ListNode&lt; &gt; (carry, null);</font></div><div><font face="Courier New">  }</font></div><div><font face="Courier New">  return dummyHead.next;</font></div><div><font face="Courier New">}</font></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div>Design a <b>stack</b> that includes a <b>max operation</b>, in addition to push and pop. </div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><font face="Courier New">private static class MaxWithCount {</font></div><div><font face="Courier New">  public Integer max;</font></div><div><font face="Courier New">  public Integer count;</font></div><div><font face="Courier New">  public MaxWithCount(Integer max, Integer count) {</font></div><div><font face="Courier New">    this.max = max;</font></div><div><font face="Courier New">    this.count = count;</font></div><div><font face="Courier New">  }</font></div><div><font face="Courier New">}</font></div><div><font face="Courier New">public static class Stack {</font></div><div><font face="Courier New">  private Deque &lt; Integer &gt; element = new LinkedList &lt; &gt; ();</font></div><div><font face="Courier New">  private Deque &lt; MaxWithCount &gt; cachedMaxWithCount = new LinkedList &lt; &gt; ();</font></div><div><font face="Courier New">  public boolean empty() {</font></div><div><font face="Courier New">    return element.isEmpty();</font></div><div><font face="Courier New">  }</font></div><div><font face="Courier New">  public Integer max() {</font></div><div><font face="Courier New">    if (empty()) {</font></div><div><font face="Courier New">      throw new IllegalStateException(&quot;max(): empty stack&quot;);</font></div><div><font face="Courier New">    }</font></div><div><font face="Courier New">    return cachedMaxWithCount.peekFirst().max;</font></div><div><font face="Courier New">  }</font></div><div><font face="Courier New">  public Integer pop() {</font></div><div><font face="Courier New">    if (empty()) {</font></div><div><font face="Courier New">      throw new IllegalStateException(&quot;pop(): empty stack&quot;);</font></div><div><font face="Courier New">    }</font></div><div><font face="Courier New">    Integer popElement = element.removeFirst();</font></div><div><font face="Courier New">    if (popElement.equals(cachedMaxWithCount.peekFirst().max)) {</font></div><div><font face="Courier New">      cachedMaxWithCount.peekFirst().count = cachedMaxWithCount.peekFirst().count - 1;</font></div><div><font face="Courier New">      if (cachedMaxWithCount.peekFirst().count.equals(®)) {</font></div><div><font face="Courier New">        cachedMaxWithCount.removeFirst();</font></div><div><font face="Courier New">      }</font></div><div><font face="Courier New">    }</font></div><div><font face="Courier New">    return popElement;</font></div><div><font face="Courier New">  }</font></div><div><font face="Courier New">  public void push(Integer x) {</font></div><div><font face="Courier New">    element.addFirst(x);</font></div><div><font face="Courier New">    if (!cachedMaxWithCount.isEmpty()) {</font></div><div><font face="Courier New">      if (Integer.compare(x, cachedMaxWithCount.peekFirst().max) == ®) {</font></div><div><font face="Courier New">        cachedMaxWithCount.peekFirst().count = cachedMaxWithCount.peekFirst().count + 1;</font></div><div><font face="Courier New">      } else if (Integer.compare(x, cachedMaxWithCount.peekFirst().max) &gt; ®) {</font></div><div><font face="Courier New">        cachedMaxWithCount.addFirst(new MaxWithCount(x, 1));</font></div><div><font face="Courier New">      }</font></div><div><font face="Courier New">    } else {</font></div><div><font face="Courier New">      cachedMaxWithCount.addFirst(new MaxWithCount(x, 1));</font></div><div><font face="Courier New">    }</font></div><div><font face="Courier New">  }</font></div><div><font face="Courier New">}</font></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><b>Evaluate RPN expressions</b>. </div><div>Write a program that takes an arithmetical expression in RPN and returns the number that the expression evaluates to. </div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><font face="Courier New">public static int eval(String RPNExpression) {</font></div><div><font face="Courier New">  Deque &lt; Integer &gt; intermediateResults = new LinkedList &lt;&gt; ();</font></div><div><font face="Courier New">  String delimiter =</font></div><div><font face="Courier New">    String[] symbols = RPNExpression.split(delimiter);</font></div><div><font face="Courier New">  for (String token: symbols) {</font></div><div><font face="Courier New">    if (token.length() == 1 &amp;&amp; &quot;+-/*&quot;.contains(token)){</font></div><div><font face="Courier New">      final int y = intermediateResults.removeFirst(); final int x = intermediateResults.removeFirst();</font></div><div><font face="Courier New">      switch (token.charAt(0)) {</font></div><div><font face="Courier New">      case '+':</font></div><div><font face="Courier New">        intermediateResults.addFirst(x + y);</font></div><div><font face="Courier New">        break;</font></div><div><font face="Courier New">      case '-':</font></div><div><font face="Courier New">        intermediateResults.addFirst(x - y);</font></div><div><font face="Courier New">        break;</font></div><div><font face="Courier New">      case '*':</font></div><div><font face="Courier New">        intermediateResults.addFirst(x * y);</font></div><div><font face="Courier New">        break;</font></div><div><font face="Courier New">      case '/':</font></div><div><font face="Courier New">      intermediateResults.addFirst(x / y);</font></div><div><font face="Courier New">      break;</font></div><div><font face="Courier New">      default:</font></div><div><font face="Courier New">        throw new IllegalArgumentException(&quot;Malformed RPN at :&quot; + token);</font></div><div><font face="Courier New">      }</font></div><div><font face="Courier New">    }</font></div><div><font style="font-family: &quot;Courier New&quot;;">    else { <b><font style="color: rgb(65, 173, 28);">// token is a number.</font></b></font></div><div><font face="Courier New">      intermediateResults.addFirst(Integer.parselnt(token));</font></div><div><font face="Courier New">    }</font></div><div><font face="Courier New">  }</font></div><div><font face="Courier New">  return intermediateResults.removeFirst();</font></div><div><font face="Courier New">}</font></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><b>Test a string over [], (), {} for well-formedness.</b> </div><div>Write a program that tests if a string made up of the chars (, ), [, ], {, } is well-formed</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><font face="Courier New">public static boolean isWellFormed(String s) {</font></div><div><font face="Courier New">  Deque &lt; Character &gt; leftChars = new LinkedList &lt; &gt; ();</font></div><div><font face="Courier New">  for (int i = 0; i &lt; s.length(); ++i) {</font></div><div><font face="Courier New">    if (s.charAt(i) == '(' || s.charAt(i) == '{' || s.charAt(i) == '[') {</font></div><div><font face="Courier New">      leftChars.addFirst(s.charAt(i));</font></div><div><font face="Courier New">    } else {</font></div><div><font face="Courier New">      if (leftChars.isEmpty()) {</font></div><div><font style="font-family: &quot;Courier New&quot;;">        return false; <b><font style="color: rgb(65, 173, 28);">// Unmatched right char.</font></b></font></div><div><font face="Courier New">      }</font></div><div><font face="Courier New">      if ((s.charAt(i) == ')' &amp;&amp; leftChars.peekFirst() != '(') ||</font></div><div><font face="Courier New">        (s.charAt(i) == &amp;&amp; leftChars.peekFirst() != '{') ||</font></div><div><font face="Courier New">        (s.charAt(i) == ']' &lt; &amp; &lt; &amp; leftChars.peekFirst() != '[')) {</font></div><div><font style="font-family: &quot;Courier New&quot;;">        return false; <font style="color: rgb(65, 173, 28);">// Mismatched chars.</font></font></div><div><font face="Courier New">      }</font></div><div><font face="Courier New">      leftChars.removeFirst();</font></div><div><font face="Courier New">    }</font></div><div><font face="Courier New">  }</font></div><div><font face="Courier New">  return leftChars.isEmpty();</font></div><div><font face="Courier New">}</font></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><b>Normalized pathnames.</b> </div><div>Write a program which takes a path name and returns the shortest equivalent pathname. Assume individual directories and files have names that use only alphanumeric chars. Subdirectory names may be combined using forward slashes (/), the current directory (.) and parent directory (..)</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><font face="Courier New">public static String shortestEquivalentPath(String path) {</font></div><div><font face="Courier New">    if (path.equals(&quot;&quot;)) {</font></div><div><font face="Courier New">      throw new IllegalArgumentException(&quot;Empty string is not a legal path.&quot;);</font></div><div><font face="Courier New">    }</font></div><div><font face="Courier New">    Deque &lt; String &gt; pathNames = new LinkedList &lt; &gt; ();</font></div><div><font color="#41AD1C" style="font-family: &quot;Courier New&quot;;"><b>    // Special case: starts with which is an absolute path.</b></font></div><div><font face="Courier New">    if (path.startsWith(&quot;/&quot;)) {</font></div><div><font face="Courier New">      pathNames.addFirst(&quot;/&quot;);</font></div><div><font face="Courier New">    }</font></div><div><font face="Courier New">    for (String token: path.split(&quot;/&quot;)) {</font></div><div><font face="Courier New">      if (token.equals(&quot;..&quot;)) {</font></div><div><font face="Courier New">        if (pathNames.isEmpty() || pathNames.peekFirst().equals(&quot;..&quot;)) {</font></div><div><font face="Courier New">          pathNames.addFirst(token);</font></div><div><font face="Courier New">        } else {</font></div><div><font face="Courier New">          if (pathNames.peekFirst().equals(&quot;/&quot;)) {</font></div><div><font face="Courier New">            throw new IllegalArgumentException(</font></div><div><font face="Courier New">              &quot;Path error, trying to go up root &quot; + path);</font></div><div><font face="Courier New">          }</font></div><div><font face="Courier New">          pathNames.removeFirst();</font></div><div><font face="Courier New">        }</font></div><div><font face="Courier New">      } else if (!token.equals(&quot;.&quot;) &amp;&amp; !token.isEmpty()) { // Must be a name.</font></div><div><font face="Courier New">        pathNames.addFirst(token);</font></div><div><font face="Courier New">      }</font></div><div><font face="Courier New">      StringBuilder result = new StringBuilder();</font></div><div><font face="Courier New">      if (!pathNames.isEmpty()) {</font></div><div><font face="Courier New">        Iterator &lt; String &gt; it = pathNames.descendinglterator();</font></div><div><font face="Courier New">        String prev = it.next();</font></div><div><font face="Courier New">        result.append(prev);</font></div><div><font face="Courier New">        while (it.hasNext()) {</font></div><div><font face="Courier New">          if (!prev.equals(&quot;/&quot;)) {</font></div><div><font face="Courier New">            result.append(&quot;/&quot;);</font></div><div><font face="Courier New">          }</font></div><div><font face="Courier New">          prev = it.next();</font></div><div><font face="Courier New">          result.append(prev);</font></div><div><font face="Courier New">        }</font></div><div><font face="Courier New">      }</font></div><div><font face="Courier New">      return result.toString();</font></div><div><font face="Courier New">    }</font></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><b>Search a posting list.</b> </div><div>A posting list is a singly linked list with an additional &quot;jump&quot; field at each node. The jum field points to any other node. One way to enumerate the nodes in a posting list is to iteratively follow the next field. Another is to always first follow the jump field if it leads to a node that has not been explored previously, and then search from the next node. Call the order in which these nodes are traversed the jump-first order. </div><div>Write recursive and iterative routines that take a posting list, and compute the jump-first order. Assume each node has an integer valued field that holds the order, and is initialized to -1</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div>The recursive algorithm directly follows the specification. If the current node is unvisited update the current node's order, visit its jump node then visit the next node.</div><div><br/></div><div><font face="Courier New">public static void setJumpOrder(PostingListNode L) {</font></div><div><font face="Courier New">  setJumpOrderHelper(L, 0);</font></div><div><font face="Courier New">}</font></div><div><font face="Courier New">private static int setJumpOrderHelper(PostingListNode L, int order) {</font></div><div><font face="Courier New">  if (L != null &amp;&amp; L.order == -1) {</font></div><div><font face="Courier New">    L.order = order++;</font></div><div><font face="Courier New">    order = setJumpOrderHelper(L.jump, order);</font></div><div><font face="Courier New">    order = setJumpOrderHelper(L.next, order);</font></div><div><font face="Courier New">  }</font></div><div><font face="Courier New">  return order;</font></div><div><font face="Courier New">}</font></div><div><br/></div><div>The iterative solution uses a stack to simulate the recursive algorithm. The key insight is that for every node, we want to visit its next node after visiting its jump node. A stack works well because of its last-in, first-out semantics. Specifically, when processing a node, we push its next node on to the stack and then we push its jump node on to the stack. This way we process the jump node before the next node.</div><div><br/></div><div><font face="Courier New">public static void setJumpOrder(PostingListNode L) {</font></div><div><font face="Courier New">  Deque &lt; PostingListNode &gt; s = new LinkedList &lt; &gt; ();</font></div><div><font face="Courier New">  int order = 0;</font></div><div><font face="Courier New">  s.addFirst(L);</font></div><div><font face="Courier New">  while (!s.isEmpty()) {</font></div><div><font face="Courier New">    PostingListNode curr = s.removeFirst();</font></div><div><font face="Courier New">    if (curr != null &amp;&amp; curr.order == -1) {</font></div><div><font face="Courier New">      curr.order = order++;</font></div><div><font style="font-family: &quot;Courier New&quot;;">      <b><font color="#41AD1C">// Stack is last-in, first -out, and we want to process</font></b></font></div><div><font color="#41AD1C" face="Courier New"><b>      // the jump node first, so push next, then push jump.</b></font></div><div><font face="Courier New">      s.addFirst(curr.next);</font></div><div><font face="Courier New">      s.addFirst(curr.jump);</font></div><div><font face="Courier New">    }</font></div><div><font face="Courier New">  }</font></div><div><font face="Courier New">}</font></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><b>Compute buildings with a sunset view</b>. </div><div>You are given with a series of buildings that have windows facing west. The buildings are in a straight line and any building which is to the east of a building of equal or greater height cannot view the sunset. </div><div>Design an algorithm that processes buildings in east-to-west order and returns the set of buildings which view the sunset. Each building is specified by its height.</div><div>Variant: solve the problem when buildings are presented in west-to-east order</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><font face="Courier New">private static class BuildingWithHeight {</font></div><div><font face="Courier New">  public Integer id;</font></div><div><font face="Courier New">  public Integer height;</font></div><div><font face="Courier New">  public BuildingWithHeight(Integer id, Integer height) {</font></div><div><font face="Courier New">    this.id = id;</font></div><div><font face="Courier New">    this.height = height; </font></div><div><font face="Courier New">  }</font></div><div><font face="Courier New">  public static Deque &lt; BuildingWithHeight &gt; examineBuildingsWithSunset(</font></div><div><font face="Courier New">    Iterator &lt; Integer &gt; sequence) {</font></div><div><font face="Courier New">    int buildingldx = 0;</font></div><div><font face="Courier New">    Deque &lt; BuildingWithHeight &gt; buildingsWithSunset = new LinkedListoO;</font></div><div><font face="Courier New">    while (sequence.hasNext()) {</font></div><div><font face="Courier New">      Integer buildingHeight = sequence.next();</font></div><div><font face="Courier New">      while (!buildingsWithSunset.isEmpty() &amp;&amp;(Integer.compare(buildingHeight, buildingsWithSunset.getLast().height) &gt;= 0)) {</font></div><div><font face="Courier New">        buildingsWithSunset.removeLast();</font></div><div><font face="Courier New">      }</font></div><div><font face="Courier New">      buildingsWithSunset.addLast(</font></div><div><font face="Courier New">        new BuildingWithHeight(buildingldx++, buildingHeight));</font></div><div><font face="Courier New">    }</font></div><div><font face="Courier New">    return buildingsWithSunset;</font></div><div><font face="Courier New">  }</font></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><b>Compute binary tree nodes in order of increasing depth</b>. </div><div>Given a binary tree, return an array consisting of the keys at the same level. Keys should appear in the order of the corresponding nodes depths, breaking ties from left to right. </div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div>Intuitively, since nodes are already presented ina  somewhat ordered fashion in the tree, it should be possible to avoid a sort, thereby reducing time complexity. Furthermore, by processing nodes in order of depth, we do not need to lavel every node with its depth.</div><div>In the following we use a queue of nodes to store nodes at depth i and a queue of nodes at depth i+1. After all nodes at depth i are processed we are done with that queue and can start processing the queue with nodes at depth i+1, putting the depth i+2 nodes in a new queu</div><div><font face="Courier New"><br/></font></div><div><font face="Courier New">public static List &lt; List &lt; Integer &gt; binaryTreeDepthOrder(</font></div><div><font face="Courier New">  BinaryTreeNode &lt; Integer &gt; tree) {</font></div><div><font face="Courier New">  Queue &lt; BinaryTreeNode &lt; Integer &gt; currDepthNodes = new LinkedList &lt; &gt; ();</font></div><div><font face="Courier New">  currDepthNodes.add(tree);</font></div><div><font face="Courier New">  List &lt; List &lt; Integer &gt;&gt; result = new ArrayList &lt; &gt; ();</font></div><div><font face="Courier New">  while (!currDepthNodes.isEmpty()) {</font></div><div><font face="Courier New">    Queue &lt; BinaryTreeNode &lt; Integer &gt; nextDepthNodes = new LinkedList &lt; &gt; ();</font></div><div><font face="Courier New">    Listdnteger &gt; thisLevel = new ArrayList &lt; &gt; ();</font></div><div><font face="Courier New">    while (!currDepthNodes.isEmpty()) {</font></div><div><font face="Courier New">      BinaryTreeNode &lt; Integer &gt; curr = currDepthNodes.poll();</font></div><div><font face="Courier New">      if (curr != null) {</font></div><div><font face="Courier New">        thisLevel.add(curr.data);</font></div><div><font color="#41AD1C" style="font-family: &quot;Courier New&quot;;"><b>        // Defer the null checks to the null test above.</b></font></div><div><font face="Courier New">        nextDepthNodes.add(curr.left);</font></div><div><font face="Courier New">        nextDepthNodes.add(curr.right);</font></div><div><font face="Courier New">      }</font></div><div><font face="Courier New">    }</font></div><div><font face="Courier New">    if (!thisLevel.isEmpty()) {</font></div><div><font face="Courier New">      result.add(thisLevel);</font></div><div><font face="Courier New">    }</font></div><div><font face="Courier New">    currDepthNodes = nextDepthNodes;</font></div><div><font face="Courier New">  }</font></div><div><font face="Courier New">  return result;</font></div><div><font face="Courier New">}</font></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><b>Implement a circualr queue.</b> </div><div>Implement a queue API using an array for storing elements. Your API should include a constructor function, which takes as argument the initial capacity of the queue, enqueue and dequeue functions, and a function which returns the number of elements stored. Implement dynamic resizing to support storing an arbitrarily large number of elements. </div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><font face="Courier New">public static class Queue {</font></div><div><font face="Courier New">  private int head = 0, tail = 0, numQueueElements = 0;</font></div><div><font face="Courier New">  private static final int SCALE_FACTOR = 2;</font></div><div><font face="Courier New">  private Integer[] entries;</font></div><div><font face="Courier New">  public Queue(int capacity) {</font></div><div><font face="Courier New">    entries = new Integer[capacity];</font></div><div><font face="Courier New">  }</font></div><div><font face="Courier New">  public void enqueue(Integer x) {</font></div><div><font style="font-family: &quot;Courier New&quot;;">    if (numQueueElements == entries.length) { <b><font style="color: rgb(65, 173, 28);">// Need to resize.</font></b></font></div><div><font face="Courier New">      // Makes the queue elements appear consecutively.</font></div><div><font face="Courier New">      Collections.rotate(Arrays.asList(entries), -head);</font></div><div><font color="#41AD1C" style="font-family: &quot;Courier New&quot;;"><b>      // Resets head and tail.</b></font></div><div><font face="Courier New">      head = 0;</font></div><div><font face="Courier New">      tail = numQueueElements;</font></div><div><font face="Courier New">      entries = Arrays.copyOf(entries, numQueueElements * SCALE_FACTOR);</font></div><div><font face="Courier New">    }</font></div><div><font face="Courier New">    entries[tail] = x;</font></div><div><font face="Courier New">    tail = (tail + 1) % entries.length;</font></div><div><font face="Courier New">    ++numQueueElements;</font></div><div><font face="Courier New">    public Integer dequeue() {</font></div><div><font face="Courier New">      if (numQueueElements != 0) {</font></div><div><font face="Courier New">        --numQueueElements;</font></div><div><font face="Courier New">        Integer ret = entries[head];</font></div><div><font face="Courier New">        head = (head + 1) % entries.length;</font></div><div><font face="Courier New">        return ret;</font></div><div><font face="Courier New">      }</font></div><div><font face="Courier New">      throw new NoSuchElementException(&quot;Dequeue called on an empty queue.&quot;);</font></div><div><font face="Courier New">    }</font></div><div><font face="Courier New">    public int size() {</font></div><div><font face="Courier New">      return numQueueElements;</font></div><div><font face="Courier New">    }</font></div><div><font face="Courier New">  </font>}</div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><b>Implement a queue using stacks.</b>  </div><div>How would you implement a queue given a library implementing stacks?</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><font face="Courier New">public static class Queue {</font></div><div><font face="Courier New">  private Deque &lt; Integer &gt; enq = new LinkedList &lt; &gt; ();</font></div><div><font face="Courier New">  private Deque &lt; Integer &gt; deq = new LinkedList &lt; &gt; ();</font></div><div><font face="Courier New">  public void enqueue(Integer x) {</font></div><div><font face="Courier New">    enq.addFirst(x);</font></div><div><font face="Courier New">  }</font></div><div><font face="Courier New">  public Integer dequeue() {</font></div><div><font face="Courier New">    if (deq.isEmpty()) {</font></div><div><font face="Courier New">      // Transfers the elements from enq to deq.</font></div><div><font face="Courier New">      while (!enq.isEmpty()) {</font></div><div><font face="Courier New">        deq.addFirst(enq.removeFirst());</font></div><div><font face="Courier New">      }</font></div><div><font face="Courier New">    }</font></div><div><font face="Courier New">    if (!deq.isEmpty()) {</font></div><div><font face="Courier New">      return deq.removeFirst();</font></div><div><font face="Courier New">    }</font></div><div><font face="Courier New">    throw new NoSuchElementException(&quot;Cannot pop empty queue&quot;);</font></div><div><font face="Courier New">  }</font></div><div><font face="Courier New">}</font></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><b>Implement a queue with max API.</b> </div><div>Implement a queue only using stacks with the max operation that returns the maximum element currently stored in the queue.</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><font face="Courier New">public static class QueueWithMax &lt; T extends Comparable &lt; T &gt;&gt; {</font></div><div><font face="Courier New">    private Queue &lt; T &gt; entries = new LinkedList &lt; &gt; ();</font></div><div><font face="Courier New">    private Deque &lt; T &gt; candidatesForMax = new LinkedList &lt; &gt; ();</font></div><div><font face="Courier New">    public void enqueue(T x) {</font></div><div><font face="Courier New">      entries.add(x);</font></div><div><font face="Courier New">      while (!candidatesForMax.isEmpty()) {</font></div><div><font face="Courier New">        // Eliminate dominated elements in candidatesForMax.</font></div><div><font face="Courier New">        if (candidatesForMax.getLast().compareTo(x) &gt;= 0) {</font></div><div><font face="Courier New">          break;</font></div><div><font face="Courier New">        }</font></div><div><font face="Courier New">        candidatesForMax.removeLast();</font></div><div><font face="Courier New">      }</font></div><div><font face="Courier New">      candidatesForMax.addLast(x);</font></div><div><font face="Courier New">    }</font></div><div><font face="Courier New">    public T dequeue() {</font></div><div><font face="Courier New">      if (!entries.isEmpty()) {</font></div><div><font face="Courier New">        T result = entries.remove();</font></div><div><font face="Courier New">        if (result.equals(candidatesForMax.getFirst())) {</font></div><div><font face="Courier New">          candidatesForMax.removeFirst();</font></div><div><font face="Courier New">        }</font></div><div><font face="Courier New">        return result;</font></div><div><font face="Courier New">      }</font></div><div><font face="Courier New">      throw new NoSuchElementException(&quot;Called dequeue on empty queue.&quot;);</font></div><div><font face="Courier New">      public T max() {</font></div><div><font face="Courier New">        if (!candidatesForMax.isEmpty()) {</font></div><div><font face="Courier New">          return candidatesForMax.getFirst();</font></div><div><font face="Courier New">        }</font></div><div><font face="Courier New">        throw new NoSuchElementException(&quot;empty queue&quot;);</font></div><div><font face="Courier New">      }</font></div><div><font face="Courier New">    }</font></div></td></tr></tbody></table><div><br/></div></div><div><br/></div></span>
</div></body></html> 