<html>
<head>
  <title>Evernote Export</title>
  <basefont face="Segoe UI" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/308816 (it-IT, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: Segoe UI;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="544"/>

<div>
<span><div><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">ONSIDER A BUILDER WHEN FACED WITH MANY CONSTRUCTOR PARAMETERS</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">Static factories and constructors share a limitation: they do not scale well to large numbers of optional parameters.</span></div><div><span style="color: rgb(51, 51, 51);">A second alternative when you’re faced with many optional parameters in a constructor is the </span><span style="font-style: italic; color: rgb(51, 51, 51);">JavaBeans</span><span style="color: rgb(51, 51, 51);"> pattern, in which you call a parameterless constructor to create the object and then call setter methods to set each required parameter and each optional parameter of interest.</span></div><div><span style="color: rgb(51, 51, 51);">Unfortunately, the JavaBeans pattern has serious disadvantages of its own. Because construction is split across multiple calls, </span><span style="font-weight: bold; color: rgb(51, 51, 51);">a JavaBean may be in an inconsistent state partway through its construction.</span><span style="color: rgb(51, 51, 51);"> </span></div><div><span style="color: rgb(51, 51, 51);">Luckily, there is a third alternative that combines the safety of the telescoping constructor pattern with the readability of the JavaBeans pattern. It is a form of the </span><span style="font-style: italic; color: rgb(51, 51, 51);">Builder</span><span style="color: rgb(51, 51, 51);"> pattern [</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ref.xhtml#rGamma95" style="color: rgb(7, 7, 7);">Gamma95</a><span style="color: rgb(51, 51, 51);">]. Instead of making the desired object directly, the client calls a constructor (or static factory) with all of the required parameters and gets a </span><span style="font-style: italic; color: rgb(51, 51, 51);">builder object</span><span style="color: rgb(51, 51, 51);">. Then the client calls setter-like methods on the builder object to set each optional parameter of interest. Finally, the client calls a parameterless build method to generate the object, which is typically immutable.</span></div><div><br/></div><div>The Builder pattern is well suited to class hierarchies. Use a parallel hierarchy of builders, each nested in the corresponding class. Abstract classes have abstract builders; concrete classes have concrete builders. <span style="color: rgb(51, 51, 51);">For example, consider an abstract class at the root of a hierarchy representing various kinds of pizza:</span></div><div><br/></div><div><img src="effective java_files/Image.jpg" type="image/jpeg" data-filename="Image.jpg" alt="Image" width="514.902774810791"/></div><div><br/></div><div><img src="effective java_files/Image [1].jpg" type="image/jpeg" data-filename="Image.jpg" alt="Image" width="548.3361239380253"/></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Note that the build method in each subclass’s builder is declared to return the correct subclass: the build method of NyPizza.Builder returns NyPizza, while the one in Calzone.Builder returns Calzone. This technique, wherein a subclass method is declared to return a subtype of the return type declared in the super-class, is known as </span><span style="font-style: italic; color: rgb(51, 51, 51);">covariant return typing</span><span style="color: rgb(51, 51, 51);">. It allows clients to use these builders without the need for casting.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">A minor advantage of builders over constructors is that builders can have multiple varargs parameters because each parameter is specified in its own method. Alternatively, builders can aggregate the parameters passed into multiple calls to a method into a single field, as demonstrated in the addTopping method earlier.</span></div><div><span style="color: rgb(51, 51, 51);">The Builder pattern is quite flexible. A single builder can be used repeatedly to build multiple objects. The parameters of the builder can be tweaked between invocations of the build method to vary the objects that are created. A builder can fill in some fields automatically upon object creation, such as a serial number that increases each time an object is created.</span></div><div><span style="color: rgb(51, 51, 51);">The Builder pattern has disadvantages as well. In order to create an object, you must first create its builder. While the cost of creating this builder is unlikely to be noticeable in practice, it could be a problem in performance-critical situations. Also, the Builder pattern is more verbose than the telescoping constructor pattern, so it should be used only if there are enough parameters to make it worthwhile, say four or more.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">ENFORCE THE SINGLETON PROPERTY WITH A PRIVATE CONSTRUCTOR OR AN ENUM TYPE</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">A </span><span style="font-style: italic; color: rgb(51, 51, 51);">singleton</span><span style="color: rgb(51, 51, 51);"> is simply a class that is instantiated exactly once [</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ref.xhtml#rGamma95" style="color: rgb(7, 7, 7);">Gamma95</a><span style="color: rgb(51, 51, 51);">]. Singletons typically represent either a stateless object such as a function (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch4.xhtml#lev24" style="color: rgb(7, 7, 7);">Item 24</a><span style="color: rgb(51, 51, 51);">) or a system component that is intrinsically unique. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Making a class a singleton can make it difficult to test its clients</span><span style="color: rgb(51, 51, 51);"> because it’s impossible to substitute a mock implementation for a singleton unless it implements an interface that serves as its type.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">There are two common ways to implement singletons. Both are based on keeping the constructor private and exporting a public static member to provide access to the sole instance. In one approach, the member is a final field.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Nothing that a client does can change this, with one caveat: a privileged client can invoke the private constructor reflectively (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch9.xhtml#lev65" style="color: rgb(7, 7, 7);">Item 65</a><span style="color: rgb(51, 51, 51);">) with the aid of the AccessibleObject.setAccessible method. If you need to defend against this attack, modify the constructor to make it throw an exception if it’s asked to create a second instance.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">In the second approach to implementing singletons, the public member is a static factory method.</span></div><div><span style="color: rgb(51, 51, 51);">One advantage of the static factory approach is that it gives you the flexibility to change your mind about whether the class is a singleton without changing its API. The factory method returns the sole instance, but it could be modified to return, say, a separate instance for each thread that invokes it. A second advantage is that you can write a </span><span style="font-style: italic; color: rgb(51, 51, 51);">generic singleton factory</span><span style="color: rgb(51, 51, 51);"> if your application requires it (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch5.xhtml#lev30" style="color: rgb(7, 7, 7);">Item 30</a><span style="color: rgb(51, 51, 51);">). A final advantage of using a static factory is that a </span><span style="font-style: italic; color: rgb(51, 51, 51);">method reference</span><span style="color: rgb(51, 51, 51);"> can be used as a supplier, for example Elvis::instance is a Supplier&lt;Elvis&gt;. Unless one of these advantages is relevant, the public field approach is preferable.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">To make a singleton class that uses either of these approaches </span><span style="font-style: italic; color: rgb(51, 51, 51);">serializable</span><span style="color: rgb(51, 51, 51);"> (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch12.xhtml#ch12" style="color: rgb(7, 7, 7);">Chapter 12</a><span style="color: rgb(51, 51, 51);">), it is not sufficient merely to add implements Serializable to its declaration. To maintain the singleton guarantee, declare all instance fields transient and provide a readResolve method (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch12.xhtml#lev89" style="color: rgb(7, 7, 7);">Item 89</a><span style="color: rgb(51, 51, 51);">). Otherwise, each time a serialized instance is deserialized, a new instance will be created, leading, in the case of our example, to spurious Elvis sightings. To prevent this from happening, add this readResolve method to the Elvis class</span></div><div><br/></div><div><img src="effective java_files/Image [2].jpg" type="image/jpeg" data-filename="Image.jpg" alt="Image" width="509.902774810791"/></div><div><br/></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">A third way to implement a singleton is to declare a single-element enum</span></div><div><br/></div><div><img src="effective java_files/Image [3].jpg" type="image/jpeg" data-filename="Image.jpg" alt="Image" width="324.902774810791"/></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">This approach is similar to the public field approach, but it is more concise, provides the serialization machinery for free, and provides an ironclad guarantee against multiple instantiation, even in the face of sophisticated serialization or reflection attacks. This approach may feel a bit unnatural, but </span><span style="font-weight: bold; color: rgb(51, 51, 51);">a single-element enum type is often the best way to implement a singleton</span><span style="color: rgb(51, 51, 51);">. Note that you can’t use this approach if your singleton must extend a superclass other than Enum (though you </span><span style="font-style: italic; color: rgb(51, 51, 51);">can</span><span style="color: rgb(51, 51, 51);"> declare an enum to implement interfaces).</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">ENFORCE NONINSTANTIABILITY WITH A PRIVATE CONSTRUCTOR</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">Occasionally you’ll want to write a class that is just a grouping of static methods and static fields. Such classes have acquired a bad reputation because some people abuse them to avoid thinking in terms of objects, but they do have valid uses.</span></div><div><span style="color: rgb(51, 51, 51);">Such </span><span style="font-style: italic; color: rgb(51, 51, 51);">utility classes</span><span style="color: rgb(51, 51, 51);"> were not designed to be instantiated: an instance would be nonsensical. In the absence of explicit constructors, however, the compiler provides a public, parameterless </span><span style="font-style: italic; color: rgb(51, 51, 51);">default constructor</span><span style="color: rgb(51, 51, 51);">. To a user, this constructor is indistinguishable from any other. It is not uncommon to see unintentionally instantiable classes in published APIs.</span></div><div><span style="font-weight: bold; color: rgb(51, 51, 51);">Attempting to enforce noninstantiability by making a class abstract does not work.</span><span style="color: rgb(51, 51, 51);"> The class can be subclassed and the subclass instantiated. Furthermore, it misleads the user into thinking the class was designed for inheritance (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch4.xhtml#lev19" style="color: rgb(7, 7, 7);">Item 19</a>). There is, however, a simple idiom to ensure noninstantiability. A default constructor is generated only if a class contains no explicit constructors, so <span style="font-weight: bold;">a class can be made noninstantiable by including a private constructor</span>:</div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">PREFER DEPENDENCY INJECTION TO HARDWIRING RESOURCES</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">A simple pattern that satisfies this requirement is to </span><span style="font-weight: bold; color: rgb(51, 51, 51);">pass the resource into the constructor when creating a new instance</span><span style="color: rgb(51, 51, 51);">. This is one form of </span><span style="font-style: italic; color: rgb(51, 51, 51);">dependency injection.</span></div><div><span style="color: rgb(51, 51, 51);">Dependency injection is equally applicable to constructors, static factories (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch2.xhtml#lev1" style="color: rgb(7, 7, 7);">Item 1</a><span style="color: rgb(51, 51, 51);">), and builders (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch2.xhtml#lev2" style="color: rgb(7, 7, 7);">Item 2</a><span style="color: rgb(51, 51, 51);">).</span></div><div>A useful variant of the pattern is to pass a resource factory to the constructor. A factory is an object that can be called repeatedly to create instances of a type. Such factories embody the Factory Method pattern [Gamma95]. The Supplier&lt;T&gt; interface, introduced in Java 8, is perfect for representing factories. Methods that take a Supplier&lt;T&gt; on input should typically constrain the factory’s type parameter using a bounded wildcard type (Item 31) to allow the client to pass in a factory that creates any subtype of a specified type.</div><div><br/></div><div><img src="effective java_files/Image [4].jpg" type="image/jpeg" data-filename="Image.jpg" alt="Image" width="540.902774810791"/></div><div><br/></div><div>In summary, do not use a singleton or static utility class to implement a class that depends on one or more underlying resources whose behavior affects that of the class, and do not have the class create these resources directly. Instead, pass the resources, or factories to create them, into the constructor (or static factory or builder). This practice, known as dependency injection, will greatly enhance the flexibility, reusability, and testability of a class.</div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">AVOID CREATING UNNECESSARY OBJECTS</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">It is often appropriate to reuse a single object instead of creating a new functionally equivalent object each time it is needed. Reuse can be both faster and more stylish. An object can always be reused if it is immutable.</span></div><div><br/></div><div>Some object creations are much more expensive than others. If you’re going to need such an “expensive object” repeatedly, it may be advisable to cache it for reuse. Unfortunately, it’s not always obvious when you’re creating such an object. Suppose you want to write a method to determine whether a string is a valid Roman numeral. Here’s the easiest way to do this using a regular expression:</div><div><br/></div><div><img src="effective java_files/Image [5].jpg" type="image/jpeg" data-filename="Image.jpg" alt="Image" width="415.902774810791"/></div><div><br/></div><div>The problem with this implementation is that it relies on the String.matches method. While String.matches is the easiest way to check if a string matches a regular expression, it’s not suitable for repeated use in performance-critical situations. The problem is that it internally creates a Pattern instance for the regular expression and uses it only once, after which it becomes eligible for garbage collection. Creating a Pattern instance is expensive because it requires compiling the regular expression into a finite state machine.To improve the performance, explicitly compile the regular expression into a Pattern instance (which is immutable) as part of class initialization, cache it, and reuse the same instance for every invocation of the isRomanNumeral method:</div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/023pro01.jpg" width="461.902774810791"></img></div><div><br/></div><div>The improved version of isRomanNumeral provides significant performance gains if invoked frequently.</div><div><br/></div><div>When an object is immutable, it is obvious it can be reused safely, but there are other situations where it is far less obvious, even counterintuitive. Consider the case of adapters [Gamma95], also known as views. An adapter is an object that delegates to a backing object, providing an alternative interface. Because an adapter has no state beyond that of its backing object, there’s no need to create more than one instance of a given adapter to a given object.For example, the keySet method of the Map interface returns a Set view of the Map object, consisting of all the keys in the map. Naively, it would seem that every call to keySet would have to create a new Set instance, but every call to keySet on a given Map object may return the same Set instance. Although the returned Set instance is typically mutable, all of the returned objects are functionally identical: when one of the returned objects changes, so do all the others, because they’re all backed by the same Map instance. While it is largely harmless to create multiple instances of the keySet view object, it is unnecessary and has no benefits.</div><div><br/></div><div>Another way to create unnecessary objects is autoboxing, which allows the programmer to mix primitive and boxed primitive types, boxing and unboxing automatically as needed. Autoboxing blurs but does not erase the distinction between primitive and boxed primitive types. Always <span style="font-weight: bold; color: rgb(51, 51, 51);">prefer primitives to boxed primitives, and watch out for unintentional autoboxing.</span></div><div><br/></div><div>Conversely, avoiding object creation by maintaining your own object pool is a bad idea unless the objects in the pool are extremely heavyweight. The classic example of an object that does justify an object pool is a database connection. The cost of establishing the connection is sufficiently high that it makes sense to reuse these objects. Generally speaking, however, maintaining your own object pools clutters your code, increases memory footprint, and harms performance. Modern JVM implementations have highly optimized garbage collectors that easily outperform such object pools on lightweight object</div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">ELIMINATE OBSOLETE OBJECT REFERENCES</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">Memory leaks in garbage-collected languages (more properly known as </span><span style="font-style: italic; color: rgb(51, 51, 51);">unintentional object retentions</span><span style="color: rgb(51, 51, 51);">) are insidious. If an object reference is unintentionally retained, not only is that object excluded from garbage collection, but so too are any objects referenced by that object, and so on. Even if only a few object references are unintentionally retained, many, many objects may be prevented from being garbage collected, with potentially large effects on performance.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The fix for this sort of problem is simple: null out references once they become obsolete. In the case of our Stack class, the reference to an item becomes obsolete as soon as it’s popped off the stack.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">When programmers are first stung by this problem, they may overcompensate by nulling out every object reference as soon as the program is finished using it. This is neither necessary nor desirable; it clutters up the program unnecessarily. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Nulling out object references should be the exception rather than the norm.</span><span style="color: rgb(51, 51, 51);"> The best way to eliminate an obsolete reference is to let the variable that contained the reference fall out of scope. This occurs naturally if you define each variable in the narrowest possible scope</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Generally speaking, </span><span style="font-weight: bold; color: rgb(51, 51, 51);">whenever a class manages its own memory, the programmer should be alert for memory leaks</span><span style="color: rgb(51, 51, 51);">. Whenever an element is freed, any object references contained in the element should be nulled out.</span></div><div><br/></div><div><span style="font-weight: bold; color: rgb(51, 51, 51);">Another common source of memory leaks is caches.</span><span style="color: rgb(51, 51, 51);"> Once you put an object reference into a cache, it’s easy to forget that it’s there and leave it in the cache long after it becomes irrelevant. There are several solutions to this problem. If you’re lucky enough to implement a cache for which an entry is relevant exactly so long as there are references to its key outside of the cache, represent the cache as a WeakHashMap; entries will be removed automatically after they become obsolete. Remember that WeakHashMap is useful only if the desired lifetime of cache entries is determined by external references to the key, not the value.</span></div><div><br/></div><div><span style="font-weight: bold; color: rgb(51, 51, 51);">A third common source of memory leaks is listeners and other callbacks.</span><span style="color: rgb(51, 51, 51);"> If you implement an API where clients register callbacks but don’t deregister them explicitly, they will accumulate unless you take some action. One way to ensure that callbacks are garbage collected promptly is to store only </span><span style="font-style: italic; color: rgb(51, 51, 51);">weak references</span><span style="color: rgb(51, 51, 51);"> to them, for instance, by storing them only as keys in a WeakHashMap.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">AVOID FINALIZERS AND CLEANERS</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-weight: bold; color: rgb(51, 51, 51);">Finalizers are unpredictable, often dangerous, and generally unnecessary.</span><span style="color: rgb(51, 51, 51);"> Their use can cause erratic behavior, poor performance, and portability problems. Finalizers have a few valid uses, which we’ll cover later in this item, but as a rule, you should avoid them. As of Java 9, finalizers have been deprecated, but they are still being used by the Java libraries. The Java 9 replacement for finalizers is </span><span style="font-style: italic; color: rgb(51, 51, 51);">cleaners</span><span style="color: rgb(51, 51, 51);">. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Cleaners are less dangerous than finalizers, but still unpredictable, slow, and generally unnecessary.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Just </span><span style="font-weight: bold; color: rgb(51, 51, 51);">have your class implement</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">AutoCloseable,</span><span style="color: rgb(51, 51, 51);"> and require its clients to invoke the close method on each instance when it is no longer needed, typically using try-with-resources to ensure termination even in the face of exceptions (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch2.xhtml#lev9" style="color: rgb(7, 7, 7);">Item 9</a><span style="color: rgb(51, 51, 51);">). One detail worth mentioning is that the instance must keep track of whether it has been closed: the close method must record in a field that the object is no longer valid, and other methods must check this field and throw an IllegalStateException if they are called after the object has been closed.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">So what, if anything, are cleaners and finalizers good for? They have perhaps two legitimate uses. One is to act as a safety net in case the owner of a resource neglects to call its close method. While there’s no guarantee that the cleaner or finalizer will run promptly (or at all), it is better to free the resource late than never if the client fails to do so. If you’re considering writing such a safety-net finalizer, think long and hard about whether the protection is worth the cost. Some Java library classes, such as FileInputStream, FileOutputStream, ThreadPoolExecutor, and java.sql.Connection, have finalizers that serve as safety nets.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">A second legitimate use of cleaners concerns objects with </span><span style="font-style: italic; color: rgb(51, 51, 51);">native peers</span><span style="color: rgb(51, 51, 51);">. A native peer is a native (non-Java) object to which a normal object delegates via native methods. Because a native peer is not a normal object, the garbage collector doesn’t know about it and can’t reclaim it when its Java peer is reclaimed. A cleaner or finalizer may be an appropriate vehicle for this task, assuming the performance is acceptable and the native peer holds no critical resources. If the performance is unacceptable or the native peer holds resources that must be reclaimed promptly, the class should have a close method, as described earlier.</span></div><div><br/></div><div><br/></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">PREFER</span><span style="color: rgb(64, 64, 64);"> </span><span style="font-weight: bold; color: rgb(64, 64, 64);">TRY-WITH-RESOURCES TO</span><span style="color: rgb(64, 64, 64);"> </span><span style="font-weight: bold; color: rgb(64, 64, 64);">TRY-FINALLY</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div>Always use try-with-resources in preference to try-finally when working with resources that must be closed. The resulting code is shorter and clearer, and the exceptions that it generates are more useful. The try-with-resources statement makes it easy to write correct code using resources that must be closed, which was practically impossible using try-finally.</div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">OBEY THE GENERAL CONTRACT WHEN OVERRIDING</span><span style="color: rgb(64, 64, 64);"> </span><span style="font-weight: bold; color: rgb(64, 64, 64);">EQUALS</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">So when is it appropriate to override equals? It is when a class has a notion of </span><span style="font-style: italic; color: rgb(51, 51, 51);">logical equality</span><span style="color: rgb(51, 51, 51);"> that differs from mere object identity and a superclass has not already overridden equals. This is generally the case for </span><span style="font-style: italic; color: rgb(51, 51, 51);">value classes.</span><span style="color: rgb(51, 51, 51);"> A value class is simply a class that represents a value, such as Integer or String. A programmer who compares references to value objects using the equals method expects to find out whether they are logically equivalent, not whether they refer to the same object. Not only is overriding the equals method necessary to satisfy programmer expectations, it enables instances to serve as map keys or set elements with predictable, desirable behavior.</span></div><div><span style="color: rgb(51, 51, 51);">One kind of value class that does </span><span style="font-style: italic; color: rgb(51, 51, 51);">not</span><span style="color: rgb(51, 51, 51);"> require the equals method to be overridden is a class that uses instance control (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch2.xhtml#lev1" style="color: rgb(7, 7, 7);">Item 1</a>) to ensure that at most one object exists with each value. Enum types (<a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch6.xhtml#lev34" style="color: rgb(7, 7, 7);">Item 34</a>) fall into this category. For these classes, logical equality is the same as object identity, so Object’s equals method functions as a logical equals method.</div><div><span style="color: rgb(51, 51, 51);">When you override the equals method, you must adhere to its general contract. Here is the contract, from the specification for Object :</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The equals method implements an </span><span style="font-style: italic; color: rgb(51, 51, 51);">equivalence relation.</span><span style="color: rgb(51, 51, 51);"> It has these properties:</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">• </span><span style="font-style: italic; color: rgb(51, 51, 51);">Reflexive</span><span style="color: rgb(51, 51, 51);">: For any non-null reference value x, x.equals(x) must return true.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">• </span><span style="font-style: italic; color: rgb(51, 51, 51);">Symmetric</span><span style="color: rgb(51, 51, 51);">: For any non-null reference values x and y, x.equals(y) must return true if and only if y.equals(x) returns true.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">• </span><span style="font-style: italic; color: rgb(51, 51, 51);">Transitive</span><span style="color: rgb(51, 51, 51);">: For any non-null reference values x, y, z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) must return true.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">• </span><span style="font-style: italic; color: rgb(51, 51, 51);">Consistent</span><span style="color: rgb(51, 51, 51);">: For any non-null reference values x and y, multiple invocations of x.equals(y) must consistently return true or consistently return false, provided no information used in equals comparisons is modified.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">• For any non-null reference value x, x.equals(null) must return false.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Putting it all together, here’s a recipe for a high-quality equals method:</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">1. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Use the</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">==</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">operator to check if the argument is a reference to this object.</span><span style="color: rgb(51, 51, 51);"> If so, return true. This is just a performance optimization but one that is worth doing if the comparison is potentially expensive.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">2. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Use the</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">instanceof</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">operator to check if the argument has the correct type.</span><span style="color: rgb(51, 51, 51);"> If not, return false. Typically, the correct type is the class in which the method occurs. Occasionally, it is some interface implemented by this class. Use an interface if the class implements an interface that refines the equals contract to permit comparisons across classes that implement the interface. Collection interfaces such as Set, List, Map, and Map.Entry have this property.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">3. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Cast the argument to the correct type.</span><span style="color: rgb(51, 51, 51);"> Because this cast was preceded by an instanceof test, it is guaranteed to succeed.</span></div><div><br/></div><div style="margin-bottom:13px;"><span style="color: rgb(51, 51, 51);">4. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">For each “significant” field in the class, check if that field of the argument matches the corresponding field of this object.</span><span style="color: rgb(51, 51, 51);"> If all these tests succeed, return true; otherwise, return false. If the type in Step 2 is an interface, you must access the argument’s fields via interface methods; if the type is a class, you may be able to access the fields directly, depending on their accessibility.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">ALWAYS OVERRIDE</span><span style="color: rgb(64, 64, 64);"> </span><span style="font-weight: bold; color: rgb(64, 64, 64);">HASHCODE</span><span style="color: rgb(64, 64, 64);"> </span><span style="font-weight: bold; color: rgb(64, 64, 64);">WHEN YOU OVERRIDE</span><span style="color: rgb(64, 64, 64);"> </span><span style="font-weight: bold; color: rgb(64, 64, 64);">EQUALS</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-weight: bold; color: rgb(51, 51, 51);">You must override</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">hashCode</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">in every class that overrides</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">equals.</span><span style="color: rgb(51, 51, 51);"> If you fail to do so, your class will violate the general contract for hashCode, which will prevent it from functioning properly in collections such as HashMap and HashSet. Here is the contract, adapted from the Object specification :</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">• When the hashCode method is invoked on an object repeatedly during an execution of an application, it must consistently return the same value, provided no information used in equals comparisons is modified. This value need not remain consistent from one execution of an application to another.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">• If two objects are equal according to the equals(Object) method, then calling hashCode on the two objects must produce the same integer result.</span></div><div><br/></div><div style="margin-bottom:9px;"><span style="color: rgb(51, 51, 51);">• If two objects are unequal according to the equals(Object) method, it is </span><span style="font-style: italic; color: rgb(51, 51, 51);">not</span><span style="color: rgb(51, 51, 51);"> required that calling hashCode on each of the objects must produce distinct results. However, the programmer should be aware that producing distinct results for unequal objects may improve the performance of hash tables.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);"> ALWAYS OVERRIDE</span><span style="color: rgb(64, 64, 64);"> </span><span style="font-weight: bold; color: rgb(64, 64, 64);">TOSTRING</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">While it isn’t as critical as obeying the equals and hashCode contracts (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch3.xhtml#lev10" style="color: rgb(7, 7, 7);">Items 10</a><span style="color: rgb(51, 51, 51);"> and </span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch3.xhtml#lev11" style="color: rgb(7, 7, 7);">11</a><span style="color: rgb(51, 51, 51);">), </span><span style="font-weight: bold; color: rgb(51, 51, 51);">providing a good</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">toString</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">implementation makes your class much more pleasant to use and makes systems using the class easier to debug</span><span style="color: rgb(51, 51, 51);">. The toString method is automatically invoked when an object is passed to println, printf, the string concatenation operator, or assert, or is printed by a debugger. Even if you never call toString on an object, others may. For example, a component that has a reference to your object may include the string representation of the object in a logged error message. If you fail to override toString, the message may be all but useless.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">OVERRIDE</span><span style="color: rgb(64, 64, 64);"> </span><span style="font-weight: bold; color: rgb(64, 64, 64);">CLONE</span><span style="color: rgb(64, 64, 64);"> </span><span style="font-weight: bold; color: rgb(64, 64, 64);">JUDICIOUSLY</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div>Though the specification doesn’t say it, in practice, a class implementing Cloneable is expected to provide a properly functioning public clone method. In order to achieve this, the class and all of its superclasses must obey a complex, unenforceable, thinly documented protocol. The resulting mechanism is fragile, dangerous, and extralinguistic: it creates objects without calling a constructor.The general contract for the clone method is weak. Here it is, copied from the Object specification :Creates and returns a copy of this object. The precise meaning of “copy” may depend on the class of the object.</div><div><br/></div><div><span style="color: rgb(51, 51, 51);">If you extend a class that already implements Cloneable, you have little choice but to implement a well-behaved clone method. Otherwise, you are usually better off providing an alternative means of object copying. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">A better approach to object copying is to provide a</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; font-style: italic; color: rgb(51, 51, 51);">copy constructor</span><span style="color: rgb(51, 51, 51);"> or </span><span style="font-weight: bold; font-style: italic; color: rgb(51, 51, 51);">copy factory</span><span style="font-weight: bold; color: rgb(51, 51, 51);">.</span><span style="color: rgb(51, 51, 51);"> A copy constructor is simply a constructor that takes a single argument whose type is the class containing the constructor.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">CONSIDER IMPLEMENTING</span><span style="color: rgb(64, 64, 64);"> </span><span style="font-weight: bold; color: rgb(64, 64, 64);">COMPARABLE</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">By implementing Comparable, you allow your class to interoperate with all of the many generic algorithms and collection implementations that depend on this interface. You gain a tremendous amount of power for a small amount of effort. Virtually all of the value classes in the Java platform libraries, as well as all enum types (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch6.xhtml#lev34" style="color: rgb(7, 7, 7);">Item 34</a><span style="color: rgb(51, 51, 51);">), implement Comparable. If you are writing a value class with an obvious natural ordering, such as alphabetical order, numerical order, or chronological order, you should implement the Comparable interface:</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/066pro02.jpg" width="250.90277481079102"></img></div><div><br/></div><div>Don’t be put off by the mathematical nature of this contract. Like the equals contract (Item 10), this contract isn’t as complicated as it looks. Unlike the equals method, which imposes a global equivalence relation on all objects, compareTo doesn’t have to work across objects of different types: when confronted with objects of different types, compareTo is permitted to throw ClassCastException. Usually, that is exactly what it does. The contract does permit intertype comparisons, which are typically defined in an interface implemented by the objects being compared.</div><div><br/></div><div>In Java 8, the Comparator interface was outfitted with a set of comparator construction methods, which enable fluent construction of comparators. These comparators can then be used to implement a compareTo method, as required by the Comparable interface. Many programmers prefer the conciseness of this approach, though it does come at a modest performance cost: sorting arrays of PhoneNumber instances is about 10% slower on my machine. When using this approach, consider using Java’s static import facility so you can refer to static comparator construction methods by their simple names for clarity and brevity</div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/070pro01.jpg" width="484.902774810791"></img></div><div><br/></div><div><br/></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">MINIMIZE THE ACCESSIBILITY OF CLASSES AND MEMBERS</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">The single most important factor that distinguishes a well-designed component from a poorly designed one is the degree to which the component hides its internal data and other implementation details from other components. A well-designed component hides all its implementation details, cleanly separating its API from its implementation. Components then communicate only through their APIs and are oblivious to each others’ inner workings. This concept, known as </span><span style="font-style: italic; color: rgb(51, 51, 51);">information hiding</span><span style="color: rgb(51, 51, 51);"> or </span><span style="font-style: italic; color: rgb(51, 51, 51);">encapsulation</span><span style="color: rgb(51, 51, 51);">, is a fundamental tenet of software design.</span></div><div><br/></div><div>Information hiding is important for many reasons, most of which stem from the fact that it decouples the components that comprise a system, allowing them to be developed, tested, optimized, used, understood, and modified in isolation. This speeds up system development because components can be developed in parallel. It eases the burden of maintenance because components can be understood more quickly and debugged or replaced with little fear of harming other components.</div><div><br/></div><div>To facilitate testing your code, you may be tempted to make a class, interface, or member more accessible than otherwise necessary. This is fine up to a point. It is acceptable to make a private member of a public class package-private in order to test it, but it is not acceptable to raise the accessibility any higher. In other words, it is not acceptable to make a class, interface, or member a part of a pack-age’s exported API to facilitate testing. Luckily, it isn’t necessary either because tests can be made to run as part of the package being tested, thus gaining access to its package-private elements.</div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">IN PUBLIC CLASSES, USE ACCESSOR METHODS, NOT PUBLIC FIELDS</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">Certainly, the hard-liners are correct when it comes to public classes: </span><span style="font-weight: bold; color: rgb(51, 51, 51);">if a class is accessible outside its package, provide accessor methods</span><span style="color: rgb(51, 51, 51);"> to preserve the flexibility to change the class’s internal representation. If a public class exposes its data fields, all hope of changing its representation is lost because client code can be distributed far and wide.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">While it’s never a good idea for a public class to expose fields directly, it is less harmful if the fields are immutable. You can’t change the representation of such a class without changing its API, and you can’t take auxiliary actions when a field is read, but you can enforce invariants. For example, this class guarantees that each instance represents a valid time.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">MINIMIZE MUTABILITY</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">To make a class immutable, follow these five rules:</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">1. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Don’t provide methods that modify the object’s state</span><span style="color: rgb(51, 51, 51);"> (known as </span><span style="font-style: italic; color: rgb(51, 51, 51);">mutators</span><span style="color: rgb(51, 51, 51);">).</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">2. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Ensure that the class can’t be extended.</span><span style="color: rgb(51, 51, 51);"> This prevents careless or malicious subclasses from compromising the immutable behavior of the class by behaving as if the object’s state has changed. Preventing subclassing is generally accomplished by making the class final, but there is an alternative that we’ll discuss later.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">3. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Make all fields final.</span><span style="color: rgb(51, 51, 51);"> This clearly expresses your intent in a manner that is enforced by the system. Also, it is necessary to ensure correct behavior if a reference to a newly created instance is passed from one thread to another without synchronization, as spelled out in the </span><span style="font-style: italic; color: rgb(51, 51, 51);">memory model</span><span style="color: rgb(51, 51, 51);"> [JLS, 17.5; Goetz06, 16].</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">4. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Make all fields private.</span><span style="color: rgb(51, 51, 51);"> This prevents clients from obtaining access to mutable objects referred to by fields and modifying these objects directly. While it is technically permissible for immutable classes to have public final fields containing primitive values or references to immutable objects, it is not recommended because it precludes changing the internal representation in a later release (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch4.xhtml#lev15" style="color: rgb(7, 7, 7);">Items 15</a> and <a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch4.xhtml#lev16" style="color: rgb(7, 7, 7);">16</a>).</div><div><br/></div><div><span style="color: rgb(51, 51, 51);">5. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Ensure exclusive access to any mutable components.</span><span style="color: rgb(51, 51, 51);"> If your class has any fields that refer to mutable objects, ensure that clients of the class cannot obtain references to these objects. Never initialize such a field to a client-provided object reference or return the field from an accessor. Make </span><span style="font-style: italic; color: rgb(51, 51, 51);">defensive copies</span><span style="color: rgb(51, 51, 51);"> (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch8.xhtml#lev50" style="color: rgb(7, 7, 7);">Item 50</a>) in constructors, accessors, and readObject methods.</div><div><br/></div><div><span style="font-weight: bold; color: rgb(51, 51, 51);">Immutable objects are inherently thread-safe; they require no synchronization.</span><span style="color: rgb(51, 51, 51);"> They cannot be corrupted by multiple threads accessing them concurrently. This is far and away the easiest approach to achieve thread safety. Since no thread can ever observe any effect of another thread on an immutable object, </span><span style="font-weight: bold; color: rgb(51, 51, 51);">immutable objects can be shared freely.</span><span style="color: rgb(51, 51, 51);"> Immutable classes should therefore encourage clients to reuse existing instances wherever possible. One easy way to do this is to provide public static final constants for commonly used values. For example, the Complex class might provide these constants</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Now that you know how to make an immutable class and you understand the pros and cons of immutability, let’s discuss a few design alternatives. Recall that to guarantee immutability, a class must not permit itself to be subclassed. This can be done by making the class final, but there is another, more flexible alternative. Instead of making an immutable class final, you can make all of its constructors private or package-private and add public static factories in place of the public constructors (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch2.xhtml#lev1" style="color: rgb(7, 7, 7);">Item 1</a><span style="color: rgb(51, 51, 51);">). To make this concrete, here’s how Complex would look if you took this approach:</span></div><div><br/></div><div><img src="effective java_files/Image [6].jpg" type="image/jpeg" data-filename="Image.jpg" alt="Image" width="516.902774810791"/></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">This approach is often the best alternative. It is the most flexible because it allows the use of multiple package-private implementation classes. To its clients that reside outside its package, the immutable class is effectively final because it is impossible to extend a class that comes from another package and that lacks a public or protected constructor. Besides allowing the flexibility of multiple implementation classes, this approach makes it possible to tune the performance of the class in subsequent releases by improving the object-caching capabilities of the static factories.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">There are some classes for which immutability is impractical. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">If a class cannot be made immutable, limit its mutability as much as possible.</span><span style="color: rgb(51, 51, 51);"> Reducing the number of states in which an object can exist makes it easier to reason about the object and reduces the likelihood of errors. Therefore, make every field final unless there is a compelling reason to make it nonfinal. Combining the advice of this item with that of </span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch4.xhtml#lev15" style="color: rgb(7, 7, 7);">Item 15</a><span style="color: rgb(51, 51, 51);">, your natural inclination should be to </span><span style="font-weight: bold; color: rgb(51, 51, 51);">declare every field</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">private final</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">unless there’s a good reason to do otherwise.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">FAVOR COMPOSITION OVER INHERITANCE</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-weight: bold; color: rgb(51, 51, 51);">Unlike method invocation, inheritance violates encapsulation</span><span style="color: rgb(51, 51, 51);"> [</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ref.xhtml#rSnyder86" style="color: rgb(7, 7, 7);">Snyder86</a><span style="color: rgb(51, 51, 51);">]. In other words, a subclass depends on the implementation details of its superclass for its proper function. The superclass’s implementation may change from release to release, and if it does, the subclass may break, even though its code has not been touched. As a consequence, a subclass must evolve in tandem with its superclass, unless the superclass’s authors have designed and documented it specifically for the purpose of being extended.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">A related cause of fragility in subclasses is that their superclass can acquire new methods in subsequent releases. Suppose a program depends for its security on the fact that all elements inserted into some collection satisfy some predicate. This can be guaranteed by subclassing the collection and overriding each method capable of adding an element to ensure that the predicate is satisfied before adding the element. This works fine until a new method capable of inserting an element is added to the superclass in a subsequent release. Once this happens, it becomes possible to add an “illegal” element merely by invoking the new method, which is not overridden in the subclass. This is not a purely theoretical problem. Several security holes of this nature had to be fixed when Hashtable and Vector were retrofitted to participate in the Collections Framework.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Luckily, there is a way to avoid all of the problems described above. Instead of extending an existing class, give your new class a private field that references an instance of the existing class. This design is called </span><span style="font-style: italic; color: rgb(51, 51, 51);">composition</span><span style="color: rgb(51, 51, 51);"> because the existing class becomes a component of the new one. Each instance method in the new class invokes the corresponding method on the contained instance of the existing class and returns the results. This is known as </span><span style="font-style: italic; color: rgb(51, 51, 51);">forwarding</span><span style="color: rgb(51, 51, 51);">, and the methods in the new class are known as </span><span style="font-style: italic; color: rgb(51, 51, 51);">forwarding methods</span><span style="color: rgb(51, 51, 51);">. The resulting class will be rock solid, with no dependencies on the implementation details of the existing class. Even adding new methods to the existing class will have no impact on the new class. To make this concrete, here’s a replacement for InstrumentedHashSet that uses the composition-and-forwarding approach. Note that the implementation is broken into two pieces, the class itself and a reusable </span><span style="font-style: italic; color: rgb(51, 51, 51);">forwarding class,</span><span style="color: rgb(51, 51, 51);"> which contains all of the forwarding methods and nothing else:</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/090pro01.jpg" width="561.749973662912"></img></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The design of the InstrumentedSet class is enabled by the existence of the Set interface, which captures the functionality of the HashSet class. Besides being robust, this design is extremely flexible. The InstrumentedSet class implements the Set interface and has a single constructor whose argument is also of type Set. In essence, the class transforms one Set into another, adding the instrumentation functionality. Unlike the inheritance-based approach, which works only for a single concrete class and requires a separate constructor for each supported constructor in the superclass, the wrapper class can be used to instrument any Set implementation and will work in conjunction with any preexisting constructor:</span></div><div><br/></div><div><img src="effective java_files/Image [7].jpg" type="image/jpeg" data-filename="Image.jpg" alt="Image" width="567.902774810791"/></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The InstrumentedSet class can even be used to temporarily instrument a set instance that has already been used without instrumentation:</span></div><div><br/></div><div><img src="effective java_files/Image [8].jpg" type="image/jpeg" data-filename="Image.jpg" alt="Image" width="544.902774810791"/></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The InstrumentedSet class is known as a </span><span style="font-style: italic; color: rgb(51, 51, 51);">wrapper</span><span style="color: rgb(51, 51, 51);"> class because each InstrumentedSet instance contains (“wraps”) another Set instance. This is also known as the </span><span style="font-style: italic; color: rgb(51, 51, 51);">Decorator</span><span style="color: rgb(51, 51, 51);"> pattern [</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ref.xhtml#rGamma95" style="color: rgb(7, 7, 7);">Gamma95</a><span style="color: rgb(51, 51, 51);">] because the InstrumentedSet class “decorates” a set by adding instrumentation. Sometimes the combination of composition and forwarding is loosely referred to as </span><span style="font-style: italic; color: rgb(51, 51, 51);">delegation.</span><span style="color: rgb(51, 51, 51);"> Technically it’s not delegation unless the wrapper object passes itself to the wrapped object.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The disadvantages of wrapper classes are few. One caveat is that wrapper classes are not suited for use in </span><span style="font-style: italic; color: rgb(51, 51, 51);">callback frameworks</span><span style="color: rgb(51, 51, 51);">, wherein objects pass self-references to other objects for subsequent invocations (“callbacks”). Because a wrapped object doesn’t know of its wrapper, it passes a reference to itself (this) and callbacks elude the wrapper. This is known as the </span><span style="font-style: italic; color: rgb(51, 51, 51);">SELF problem</span><span style="color: rgb(51, 51, 51);"> [</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ref.xhtml#rLieberman86" style="color: rgb(7, 7, 7);">Lieberman86</a><span style="color: rgb(51, 51, 51);">]. Some people worry about the performance impact of forwarding method invocations or the memory footprint impact of wrapper objects. Neither turn out to have much impact in practice. It’s tedious to write forwarding methods, but you have to write the reusable forwarding class for each interface only once, and forwarding classes may be provided for you. For example, Guava provides forwarding classes for all of the collection interfaces [</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ref.xhtml#rGuava" style="color: rgb(7, 7, 7);">Guava</a><span style="color: rgb(51, 51, 51);">].</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The disadvantages of wrapper classes are few. One caveat is that wrapper classes are not suited for use in </span><span style="font-style: italic; color: rgb(51, 51, 51);">callback frameworks</span><span style="color: rgb(51, 51, 51);">, wherein objects pass self-references to other objects for subsequent invocations (“callbacks”). Because a wrapped object doesn’t know of its wrapper, it passes a reference to itself (this) and callbacks elude the wrapper. This is known as the </span><span style="font-style: italic; color: rgb(51, 51, 51);">SELF problem</span><span style="color: rgb(51, 51, 51);"> [</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ref.xhtml#rLieberman86" style="color: rgb(7, 7, 7);">Lieberman86</a><span style="color: rgb(51, 51, 51);">]. Some people worry about the performance impact of forwarding method invocations or the memory footprint impact of wrapper objects. Neither turn out to have much impact in practice. It’s tedious to write forwarding methods, but you have to write the reusable forwarding class for each interface only once, and forwarding classes may be provided for you. For example, Guava provides forwarding classes for all of the collection interfaces [</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ref.xhtml#rGuava" style="color: rgb(7, 7, 7);">Guava</a><span style="color: rgb(51, 51, 51);">].</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">DESIGN AND DOCUMENT FOR INHERITANCE OR ELSE PROHIBIT IT</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">First, the class must document precisely the effects of overriding any method. In other words, </span><span style="font-weight: bold; color: rgb(51, 51, 51);">the class must document its</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; font-style: italic; color: rgb(51, 51, 51);">self-use</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">of overridable methods.</span><span style="color: rgb(51, 51, 51);"> For each public or protected method, the documentation must indicate which overridable methods the method invokes, in what sequence, and how the results of each invocation affect subsequent processing. (By </span><span style="font-style: italic; color: rgb(51, 51, 51);">overridable</span><span style="color: rgb(51, 51, 51);">, we mean nonfinal and either public or protected.) More generally, a class must document any circumstances under which it might invoke an overridable method. For example, invocations might come from background threads or static initializers.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The @implSpec tag was added in Java 8 and used heavily in Java 9. This tag should be enabled by default, but as of Java 9, the Javadoc utility still ignores it unless you pass the command line switch -tag &quot;apiNote:a:API Note:&quot;.</span></div><div><span style="color: rgb(51, 51, 51);">Designing for inheritance involves more than just documenting patterns of self-use. To allow programmers to write efficient subclasses without undue pain, </span><span style="font-weight: bold; color: rgb(51, 51, 51);">a class may have to provide hooks into its internal workings in the form of judiciously chosen protected methods</span><span style="color: rgb(51, 51, 51);"> or, in rare instances, protected fields</span></div><div><br/></div><div><span style="font-weight: bold; color: rgb(51, 51, 51);">The</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; font-style: italic; color: rgb(51, 51, 51);">only</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">way to test a class designed for inheritance is to write subclasses.</span><span style="color: rgb(51, 51, 51);"> If you omit a crucial protected member, trying to write a subclass will make the omission painfully obvious. Conversely, if several subclasses are written and none uses a protected member, you should probably make it private. Experience shows that three subclasses are usually sufficient to test an extendable class. One or more of these subclasses should be written by someone other than the superclass author.</span></div><div><span style="color: rgb(51, 51, 51);">When you design for inheritance a class that is likely to achieve wide use, realize that you are committing </span><span style="font-style: italic; color: rgb(51, 51, 51);">forever</span><span style="color: rgb(51, 51, 51);"> to the self-use patterns that you document and to the implementation decisions implicit in its protected methods and fields. These commitments can make it difficult or impossible to improve the performance or functionality of the class in a subsequent release. Therefore, </span><span style="font-weight: bold; color: rgb(51, 51, 51);">you must test your class by writing subclasses</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; font-style: italic; color: rgb(51, 51, 51);">before</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">you release it.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">There are a few more restrictions that a class must obey to allow inheritance. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Constructors must not invoke overridable methods,</span><span style="color: rgb(51, 51, 51);"> directly or indirectly. If you violate this rule, program failure will result. The superclass constructor runs before the subclass constructor, so the overriding method in the subclass will get invoked before the subclass constructor has run. If the overriding method depends on any initialization performed by the subclass constructor, the method will not behave as expected. To make this concrete, here’s a class that violates this rule:</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/095pro01.jpg" width="453.902774810791"></img></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Here’s a subclass that overrides the overrideMe method, which is erroneously invoked by Super’s sole constructor:</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/096pro01.jpg" width="504.902774810791"></img></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">You might expect this program to print out the instant twice, but it prints out null the first time because overrideMe is invoked by the Super constructor before the Sub constructor has a chance to initialize the instant field. Note that this program observes a final field in two different states! Note also that if overrideMe had invoked any method on instant, it would have thrown a NullPointerException when the Super constructor invoked overrideMe. The only reason this program doesn’t throw a NullPointerException as it stands is that the println method tolerates null parameters.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Note that it </span><span style="font-style: italic; color: rgb(51, 51, 51);">is</span><span style="color: rgb(51, 51, 51);"> safe to invoke private methods, final methods, and static methods, none of which are overridable, from a constructor.</span></div><div><span style="color: rgb(51, 51, 51);">The Cloneable and Serializable interfaces present special difficulties when designing for inheritance. It is generally not a good idea for a class designed for inheritance to implement either of these interfaces because they place a substantial burden on programmers who extend the class. There are, however, special actions that you can take to allow subclasses to implement these interfaces without mandating that they do so.</span></div><div><br/></div><div><span style="font-weight: bold; color: rgb(51, 51, 51);">The best solution to this problem is to prohibit subclassing in classes that are not designed and documented to be safely subclassed.</span><span style="color: rgb(51, 51, 51);"> There are two ways to prohibit subclassing. The easier of the two is to declare the class final. The alternative is to make all the constructors private or package-private and to add public static factories in place of the constructors. This alternative, which provides the flexibility to use subclasses internally, is discussed in </span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch4.xhtml#lev17" style="color: rgb(7, 7, 7);">Item 17</a>. Either approach is acceptable.</div><div><br/></div><div><span style="color: rgb(51, 51, 51);">This advice may be somewhat controversial because many programmers have grown accustomed to subclassing ordinary concrete classes to add facilities such as instrumentation, notification, and synchronization or to limit functionality. If a class implements some interface that captures its essence, such as Set, List, or Map, then you should feel no compunction about prohibiting subclassing. The </span><span style="font-style: italic; color: rgb(51, 51, 51);">wrapper class</span><span style="color: rgb(51, 51, 51);"> pattern, described in </span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch4.xhtml#lev18" style="color: rgb(7, 7, 7);">Item 18</a>, provides a superior alternative to inheritance for augmenting the functionality.</div><div><br/></div><div><span style="color: rgb(51, 51, 51);">In summary, designing a class for inheritance is hard work. You must document all of its self-use patterns, and once you’ve documented them, you must commit to them for the life of the class. If you fail to do this, subclasses may become dependent on implementation details of the superclass and may break if the implementation of the superclass changes. To allow others to write </span><span style="font-style: italic; color: rgb(51, 51, 51);">efficient</span><span style="color: rgb(51, 51, 51);"> subclasses, you may also have to export one or more protected methods. Unless you know there is a real need for subclasses, you are probably better off prohibiting inheritance by declaring your class final or ensuring that there are no accessible constructors.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">PREFER INTERFACES TO ABSTRACT CLASSES</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">Java has two mechanisms to define a type that permits multiple implementations: interfaces and abstract classes. Since the introduction of </span><span style="font-style: italic; color: rgb(51, 51, 51);">default methods</span><span style="color: rgb(51, 51, 51);"> for interfaces in Java 8 [</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ref.xhtml#rJLS" style="color: rgb(7, 7, 7);">JLS 9.4.3</a><span style="color: rgb(51, 51, 51);">], both mechanisms allow you to provide implementations for some instance methods. A major difference is that to implement the type defined by an abstract class, a class must be a subclass of the abstract class. Because Java permits only single inheritance, this restriction on abstract classes severely constrains their use as type definitions. Any class that defines all the required methods and obeys the general contract is permitted to implement an interface, regardless of where the class resides in the class hierarchy.</span></div><div><br/></div><div><span style="font-weight: bold; color: rgb(51, 51, 51);">Existing classes can easily be retrofitted to implement a new interface.</span><span style="color: rgb(51, 51, 51);"> All you have to do is to add the required methods, if they don’t yet exist, and to add an implements clause to the class declaration.If you want to have two classes extend the same abstract class, you have to place it high up in the type hierarchy where it is an ancestor of both classes. Unfortunately, this can cause great collateral damage to the type hierarchy, forcing all descendants of the new abstract class to subclass it, whether or not it is appropriate.</span></div><div><br/></div><div><span style="font-weight: bold; color: rgb(51, 51, 51);">Interfaces are ideal for defining mixins.</span><span style="color: rgb(51, 51, 51);"> Loosely speaking, a </span><span style="font-style: italic; color: rgb(51, 51, 51);">mixin</span><span style="color: rgb(51, 51, 51);"> is a type that a class can implement in addition to its “primary type,” to declare that it provides some optional behavior. For example, Comparable is a mixin interface that allows a class to declare that its instances are ordered with respect to other mutually comparable objects. Such an interface is called a mixin because it allows the optional functionality to be “mixed in” to the type’s primary functionality. Abstract classes can’t be used to define mixins for the same reason that they can’t be retrofitted onto existing classes: a class cannot have more than one parent, and there is no reasonable place in the class hierarchy to insert a mixin.</span></div><div><br/></div><div><span style="font-weight: bold; color: rgb(51, 51, 51);">Interfaces allow for the construction of nonhierarchical type frameworks.</span><span style="color: rgb(51, 51, 51);"> Type hierarchies are great for organizing some things, but other things don’t fall neatly into a rigid hierarchy. </span></div><div><br/></div><div><span style="font-weight: bold; color: rgb(51, 51, 51);">Interfaces enable safe, powerful functionality enhancements</span><span style="color: rgb(51, 51, 51);"> via the </span><span style="font-style: italic; color: rgb(51, 51, 51);">wrapper class</span><span style="color: rgb(51, 51, 51);"> idiom (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch4.xhtml#lev18" style="color: rgb(7, 7, 7);">Item 18</a><span style="color: rgb(51, 51, 51);">). If you use abstract classes to define types, you leave the programmer who wants to add functionality with no alternative but inheritance. The resulting classes are less powerful and more fragile than wrapper classes.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">You can, however, combine the advantages of interfaces and abstract classes by providing an abstract </span><span style="font-style: italic; color: rgb(51, 51, 51);">skeletal implementation class</span><span style="color: rgb(51, 51, 51);"> to go with an interface. The interface defines the type, perhaps providing some default methods, while the skeletal implementation class implements the remaining non-primitive interface methods atop the primitive interface methods. Extending a skeletal implementation takes most of the work out of implementing an interface. This is the </span><span style="font-style: italic; color: rgb(51, 51, 51);">Template Method</span><span style="color: rgb(51, 51, 51);"> pattern</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The beauty of skeletal implementation classes is that they provide all of the implementation assistance of abstract classes without imposing the severe constraints that abstract classes impose when they serve as type definitions. For most implementors of an interface with a skeletal implementation class, extending this class is the obvious choice, but it is strictly optional. If a class cannot be made to extend the skeletal implementation, the class can always implement the interface directly. The class still benefits from any default methods present on the interface itself. Furthermore, the skeletal implementation can still aid the implementor’s task. The class implementing the interface can forward invocations of interface methods to a contained instance of a private inner class that extends the skeletal implementation. This technique, known as </span><span style="font-style: italic; color: rgb(51, 51, 51);">simulated multiple inheritance</span><span style="color: rgb(51, 51, 51);">, is closely related to the wrapper class idiom discussed in </span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch4.xhtml#lev18" style="color: rgb(7, 7, 7);">Item 18</a><span style="color: rgb(51, 51, 51);">. It provides many of the benefits of multiple inheritance, while avoiding the pitfalls.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Because skeletal implementations are designed for inheritance, you should follow all of the design and documentation guidelines in </span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch4.xhtml#lev19" style="color: rgb(7, 7, 7);">Item 19</a><span style="color: rgb(51, 51, 51);">. For brevity’s sake, the documentation comments were omitted from the previous example, but </span><span style="font-weight: bold; color: rgb(51, 51, 51);">good documentation is absolutely essential in a skeletal implementation,</span><span style="color: rgb(51, 51, 51);"> whether it consists of default methods on an interface or a separate abstract class.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);"> DESIGN INTERFACES FOR POSTERITY</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">The declaration for a default method includes a </span><span style="font-style: italic; color: rgb(51, 51, 51);">default implementation</span><span style="color: rgb(51, 51, 51);"> that is used by all classes that implement the interface but do not implement the default method. While the addition of default methods to Java makes it possible to add methods to an existing interface, there is no guarantee that these methods will work in all preexisting implementations. Default methods are “injected” into existing implementations without the knowledge or consent of their implementors. Before Java 8, these implementations were written with the tacit understanding that their interfaces would </span><span style="font-style: italic; color: rgb(51, 51, 51);">never</span><span style="color: rgb(51, 51, 51);"> acquire any new methods.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Many new default methods were added to the core collection interfaces in Java 8, primarily to facilitate the use of lambdas (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch6.xhtml#ch6" style="color: rgb(7, 7, 7);">Chapter 6</a>). The Java libraries’ default methods are high-quality general-purpose implementations, and in most cases, they work fine. But <span style="font-weight: bold;">it is not always possible to write a default method that maintains all invariants of every conceivable implementation.</span></div><div><br/></div><div><span style="font-weight: bold; color: rgb(51, 51, 51);">In the presence of default methods, existing implementations of an interface may compile without error or warning but fail at runtime.</span><span style="color: rgb(51, 51, 51);"> While not terribly common, this problem is not an isolated incident either. A handful of the methods added to the collections interfaces in Java 8 are known to be susceptible, and a handful of existing implementations are known to be affected.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Using default methods to add new methods to existing interfaces should be avoided unless the need is critical, in which case you should think long and hard about whether an existing interface implementation might be broken by your default method implementation. Default methods are, however, extremely useful for providing standard method implementations when an interface is created, to ease the task of implementing the interface</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The moral is clear. Even though default methods are now a part of the Java platform, </span><span style="font-weight: bold; color: rgb(51, 51, 51);">it is still of the utmost importance to design interfaces with great care.</span><span style="color: rgb(51, 51, 51);"> While default methods make it </span><span style="font-style: italic; color: rgb(51, 51, 51);">possible</span><span style="color: rgb(51, 51, 51);"> to add methods to existing interfaces, there is great risk in doing so. If an interface contains a minor flaw, it may irritate its users forever; if an interface is severely deficient, it may doom the API that contains it.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">USE INTERFACES ONLY TO DEFINE TYPES</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">When a class implements an interface, the interface serves as a </span><span style="font-style: italic; color: rgb(51, 51, 51);">type</span><span style="color: rgb(51, 51, 51);"> that can be used to refer to instances of the class. That a class implements an interface should therefore say something about what a client can do with instances of the class. It is inappropriate to define an interface for any other purpose.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">One kind of interface that fails this test is the so-called </span><span style="font-style: italic; color: rgb(51, 51, 51);">constant interface</span><span style="color: rgb(51, 51, 51);">. Such an interface contains no methods; it consists solely of static final fields, each exporting a constant. Classes using these constants implement the interface to avoid the need to qualify constant names with a class name. </span></div><div><br/></div><div><span style="font-weight: bold; color: rgb(51, 51, 51);">The constant interface pattern is a poor use of interfaces.</span><span style="color: rgb(51, 51, 51);"> That a class uses some constants internally is an implementation detail. Implementing a constant interface causes this implementation detail to leak into the class’s exported API. It is of no consequence to the users of a class that the class implements a constant interface. In fact, it may even confuse them. Worse, it represents a commitment: if in a future release the class is modified so that it no longer needs to use the constants, it still must implement the interface to ensure binary compatibility. If a nonfinal class implements a constant interface, all of its subclasses will have their namespaces polluted by the constants in the interface.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">PREFER CLASS HIERARCHIES TO TAGGED CLASSES</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">To transform a tagged class into a class hierarchy, first define an abstract class containing an abstract method for each method in the tagged class whose behavior depends on the tag value. In the Figure class, there is only one such method, which is area. This abstract class is the root of the class hierarchy. If there are any methods whose behavior does not depend on the value of the tag, put them in this class. Similarly, if there are any data fields used by all the flavors, put them in this class. There are no such flavor-independent methods or fields in the Figure class. Next, define a concrete subclass of the root class for each flavor of the original tagged class. </span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">FAVOR STATIC MEMBER CLASSES OVER NONSTATIC</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">A static member class is the simplest kind of nested class. It is best thought of as an ordinary class that happens to be declared inside another class and has access to all of the enclosing class’s members, even those declared private. A static member class is a static member of its enclosing class and obeys the same accessibility rules as other static members. If it is declared private, it is accessible only within the enclosing class, and so forth.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">One common use of a static member class is as a public helper class, useful only in conjunction with its outer class. For example, consider an enum describing the operations supported by a calculator (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch6.xhtml#lev34" style="color: rgb(7, 7, 7);">Item 34</a>). The Operation enum should be a public static member class of the Calculator class. Clients of Calculator could then refer to operations using names like Calculator.Operation.PLUS and Calculator.Operation.MINUS.</div><div><br/></div><div><span style="color: rgb(51, 51, 51);">One common use of a nonstatic member class is to define an </span><span style="font-style: italic; color: rgb(51, 51, 51);">Adapter</span><span style="color: rgb(51, 51, 51);"> [</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ref.xhtml#rGamma95" style="color: rgb(7, 7, 7);">Gamma95</a><span style="color: rgb(51, 51, 51);">] that allows an instance of the outer class to be viewed as an instance of some unrelated class. For example, implementations of the Map interface typically use nonstatic member classes to implement their </span><span style="font-style: italic; color: rgb(51, 51, 51);">collection views</span><span style="color: rgb(51, 51, 51);">, which are returned by Map’s keySet, entrySet, and values methods. Similarly, implementations of the collection interfaces, such as Set and List, typically use nonstatic member classes to implement their iterators:</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/113pro01.jpg" width="398.902774810791"></img></div><div><br/></div><div><span style="font-weight: bold; color: rgb(51, 51, 51);">If you declare a member class that does not require access to an enclosing instance,</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; font-style: italic; color: rgb(51, 51, 51);">always</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">put the</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">static</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">modifier in its declaration,</span><span style="color: rgb(51, 51, 51);"> making it a static rather than a nonstatic member class. If you omit this modifier, each instance will have a hidden extraneous reference to its enclosing instance. As previously mentioned, storing this reference takes time and space. More seriously, it can result in the enclosing instance being retained when it would otherwise be eligible for garbage collection (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch2.xhtml#lev7" style="color: rgb(7, 7, 7);">Item 7</a><span style="color: rgb(51, 51, 51);">). The resulting memory leak can be catastrophic. It is often difficult to detect because the reference is invisible.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">A common use of private static member classes is to represent components of the object represented by their enclosing class. For example, consider a Map instance, which associates keys with values. Many Map implementations have an internal Entry object for each key-value pair in the map. While each entry is associated with a map, the methods on an entry (getKey, getValue, and setValue) do not need access to the map. Therefore, it would be wasteful to use a nonstatic member class to represent entries: a private static member class is best. If you accidentally omit the static modifier in the entry declaration, the map will still work, but each entry will contain a superfluous reference to the map, which wastes space and time.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">To recap, there are four different kinds of nested classes, and each has its place. If a nested class needs to be visible outside of a single method or is too long to fit comfortably inside a method, use a member class. If each instance of a member class needs a reference to its enclosing instance, make it nonstatic; otherwise, make it static. Assuming the class belongs inside a method, if you need to create instances from only one location and there is a preexisting type that characterizes the class, make it an anonymous class; otherwise, make it a local class.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">LIMIT SOURCE FILES TO A SINGLE TOP-LEVEL CLASS</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">While the Java compiler lets you define multiple top-level classes in a single source file, there are no benefits associated with doing so, and there are significant risks. The risks stem from the fact that defining multiple top-level classes in a source file makes it possible to provide multiple definitions for a class. Which definition gets used is affected by the order in which the source files are passed to the compiler.</span></div><div><br/></div><div><span style="font-weight: bold; color: rgb(51, 51, 51);">Never put multiple top-level classes or interfaces in a single source file.</span><span style="color: rgb(51, 51, 51);"> Following this rule guarantees that you can’t have multiple definitions for a single class at compile time. This in turn guarantees that the class files generated by compilation, and the behavior of the resulting program, are independent of the order in which the source files are passed to the compiler.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">DON’T USE RAW TYPES</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">Before generics were added to Java, this would have been an exemplary collection declaration. As of Java 9, it is still legal, but far from exemplary:</span></div><div><br/></div><div><img src="effective java_files/Image [9].jpg" type="image/jpeg" data-filename="Image.jpg" alt="Image" width="453.902774810791"/></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">it is legal to use raw types (generic types without their type parameters), but you should never do it. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">If you use raw types, you lose all the safety and expressiveness benefits of generics.</span><span style="color: rgb(51, 51, 51);"> Given that you shouldn’t use them, why did the language designers permit raw types in the first place? For compatibility. Java was about to enter its second decade when generics were added, and there was an enormous amount of code in existence that did not use generics. It was deemed critical that all of this code remain legal and interoperate with newer code that does use generics. It had to be legal to pass instances of parameterized types to methods that were designed for use with raw types, and vice versa. This requirement, known as </span><span style="font-style: italic; color: rgb(51, 51, 51);">migration compatibility</span><span style="color: rgb(51, 51, 51);">, drove the decisions to support raw types and to implement generics using </span><span style="font-style: italic; color: rgb(51, 51, 51);">erasure</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The safe alternative is to use </span><span style="font-style: italic; color: rgb(51, 51, 51);">unbounded wildcard types</span><span style="color: rgb(51, 51, 51);">. If you want to use a generic type but you don’t know or care what the actual type parameter is, you can use a question mark instead. For example, the unbounded wildcard type for the generic type Set&lt;E&gt; is Set&lt;?&gt; (read “set of some type”). It is the most general parameterized Set type, capable of holding </span><span style="font-style: italic; color: rgb(51, 51, 51);">any</span><span style="color: rgb(51, 51, 51);"> set. Here is how the numElementsInCommon declaration looks with unbounded wildcard types:</span></div><div><br/></div><div><img src="effective java_files/Image [10].jpg" type="image/jpeg" data-filename="Image.jpg" alt="Image" width="551.902774810791"/></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">What is the difference between the unbounded wildcard type Set&lt;?&gt; and the raw type Set? Does the question mark really buy you anything? Not to belabor the point, but the wildcard type is safe and the raw type isn’t. You can put </span><span style="font-style: italic; color: rgb(51, 51, 51);">any</span><span style="color: rgb(51, 51, 51);"> element into a collection with a raw type, easily corrupting the collection’s type invariant (as demonstrated by the unsafeAdd method on page 119); </span><span style="font-weight: bold; color: rgb(51, 51, 51);">you can’t put any element (other than</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">null) into a</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Collection&lt;?&gt;.</span><span style="color: rgb(51, 51, 51);"> </span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">There are a few minor exceptions to the rule that you should not use raw types. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">You must use raw types in class literals.</span><span style="color: rgb(51, 51, 51);"> The specification does not permit the use of parameterized types (though it does permit array types and primitive types) [JLS, 15.8.2]. In other words, List.class, String[].class, and int.class are all legal, but List&lt;String&gt;.class and List&lt;?&gt;.class are not.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">A second exception to the rule concerns the instanceof operator. Because generic type information is erased at runtime, it is illegal to use the instanceof operator on parameterized types other than unbounded wildcard types. The use of unbounded wildcard types in place of raw types does not affect the behavior of the instanceof operator in any way. In this case, the angle brackets and question marks are just noise. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">This is the preferred way to use the</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">instanceof</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">operator with generic types:</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/121pro02.jpg" width="450.902774810791"></img></div><div><br/></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">ELIMINATE UNCHECKED WARNINGS</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">When you program with generics, you will see many compiler warnings: unchecked cast warnings, unchecked method invocation warnings, unchecked parameterized vararg type warnings, and unchecked conversion warnings. The more experience you acquire with generics, the fewer warnings you’ll get, but don’t expect newly written code to compile cleanly.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">You can then make the indicated correction, causing the warning to disappear. Note that you don’t actually have to specify the type parameter, merely to indicate that it’s present with the </span><span style="font-style: italic; color: rgb(51, 51, 51);">diamond operator</span><span style="color: rgb(51, 51, 51);"> (&lt;&gt;), introduced in Java 7. The compiler will then </span><span style="font-style: italic; color: rgb(51, 51, 51);">infer</span><span style="color: rgb(51, 51, 51);"> the correct actual type parameter</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Some warnings will be </span><span style="font-style: italic; color: rgb(51, 51, 51);">much</span><span style="color: rgb(51, 51, 51);"> more difficult to eliminate. This chapter is filled with examples of such warnings. When you get warnings that require some thought, persevere! </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Eliminate every unchecked warning that you can.</span><span style="color: rgb(51, 51, 51);"> If you eliminate all warnings, you are assured that your code is typesafe, which is a very good thing. It means that you won’t get a ClassCastException at runtime, and it increases your confidence that your program will behave as you intended.</span></div><div><br/></div><div><span style="font-weight: bold; color: rgb(51, 51, 51);">If you can’t eliminate a warning, but you can prove that the code that provoked the warning is typesafe, then (and only then) suppress the warning with an</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">@SuppressWarnings(&quot;unchecked&quot;)</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">annotation.</span><span style="color: rgb(51, 51, 51);"> If you suppress warnings without first proving that the code is typesafe, you are giving yourself a false sense of security. The code may compile without emitting any warnings, but it can still throw a ClassCastException at runtime.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The SuppressWarnings annotation can be used on any declaration, from an individual local variable declaration to an entire class. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Always use the</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">SuppressWarnings</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">annotation on the smallest scope possible.</span><span style="color: rgb(51, 51, 51);"> Typically this will be a variable declaration or a very short method or constructor. Never use SuppressWarnings on an entire class. Doing so could mask critical warnings.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">PREFER LISTS TO ARRAYS</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">rrays differ from generic types in two important ways. First, arrays are </span><span style="font-style: italic; color: rgb(51, 51, 51);">covariant</span><span style="color: rgb(51, 51, 51);">. This scary-sounding word means simply that if Sub is a subtype of Super, then the array type Sub[] is a subtype of the array type Super[]. Generics, by contrast, are </span><span style="font-style: italic; color: rgb(51, 51, 51);">invariant</span><span style="color: rgb(51, 51, 51);">: for any two distinct types Type1 and Type2, List&lt;Type1&gt; is neither a subtype nor a supertype of List&lt;Type2&gt; [JLS, 4.10; Naftalin07, 2.5]. You might think this means that generics are deficient, but arguably it is arrays that are deficient.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The second major difference between arrays and generics is that arrays are </span><span style="font-style: italic; color: rgb(51, 51, 51);">reified</span><span style="color: rgb(51, 51, 51);"> [JLS, 4.7]. This means that arrays know and enforce their element type at runtime. As noted earlier, if you try to put a String into an array of Long, you’ll get an ArrayStoreException. Generics, by contrast, are implemented by </span><span style="font-style: italic; color: rgb(51, 51, 51);">erasure</span><span style="color: rgb(51, 51, 51);"> [JLS, 4.6]. This means that they enforce their type constraints only at compile time and discard (or </span><span style="font-style: italic; color: rgb(51, 51, 51);">erase</span><span style="color: rgb(51, 51, 51);">) their element type information at runtime. Erasure is what allowed generic types to interoperate freely with legacy code that didn’t use generics (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch5.xhtml#lev26" style="color: rgb(7, 7, 7);">Item 26</a>), ensuring a smooth transition to generics in Java 5.</div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Because of these fundamental differences, arrays and generics do not mix well. For example, it is illegal to create an array of a generic type, a parameterized type, or a type parameter. Therefore, none of these array creation expressions are legal: new List&lt;E&gt;[], new List&lt;String&gt;[], new E[]. All will result in </span><span style="font-style: italic; color: rgb(51, 51, 51);">generic array creation</span><span style="color: rgb(51, 51, 51);"> errors at compile time.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">In summary, arrays and generics have very different type rules. Arrays are covariant and reified; generics are invariant and erased. As a consequence, arrays provide runtime type safety but not compile-time type safety, and vice versa for generics. As a rule, arrays and generics don’t mix well. If you find yourself mixing them and getting compile-time errors or warnings, your first impulse should be to replace the arrays with lists.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">FAVOR GENERIC TYPES</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">The first step in generifying a class is to add one or more type parameters to its declaration. In this case there is one type parameter, representing the element type of the stack, and the conventional name for this type parameter is E (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch9.xhtml#lev68" style="color: rgb(7, 7, 7);">Item 68</a>).</div><div><span style="color: rgb(51, 51, 51);">The next step is to replace all the uses of the type Object with the appropriate type parameter and then try to compile the resulting program:</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/131pro01.jpg" width="571.902774810791"></img></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">You’ll generally get at least one error or warning, and this class is no exception. Luckily, this class generates only one error:</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/131pro02.jpg" width="469.902774810791"></img></div><div><span style="color: rgb(51, 51, 51);">As explained in </span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch5.xhtml#lev28" style="color: rgb(7, 7, 7);">Item 28</a><span style="color: rgb(51, 51, 51);">, you can’t create an array of a non-reifiable type, such as E. This problem arises every time you write a generic type that is backed by an array. There are two reasonable ways to solve it. The first solution directly circumvents the prohibition on generic array creation: create an array of Object and cast it to the generic array type. Now in place of an error, the compiler will emit a warning. This usage is legal, but it’s not (in general) typesafe:</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/132pro01.jpg" width="540.902774810791"></img></div><div><span style="color: rgb(51, 51, 51);">The compiler may not be able to prove that your program is typesafe, but you can. You must convince yourself that the unchecked cast will not compromise the type safety of the program. The array in question (elements) is stored in a private field and never returned to the client or passed to any other method. The only elements stored in the array are those passed to the push method, which are of type E, so the unchecked cast can do no harm.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Once you’ve proved that an unchecked cast is safe, suppress the warning in as narrow a scope as possible (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch5.xhtml#lev27" style="color: rgb(7, 7, 7);">Item 27</a>). In this case, the constructor contains only the unchecked array creation, so it’s appropriate to suppress the warning in the entire constructor. With the addition of an annotation to do this, Stack compiles cleanly, and you can use it without explicit casts or fear of a ClassCastException.</div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The second way to eliminate the generic array creation error in Stack is to change the type of the field elements from E[] to Object[]. If you do this, you’ll get a different error:</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/132pro03.jpg" width="327.902774810791"></img></div><div><br/></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">You can change this error into a warning by casting the element retrieved from the array to E, but you will get a warning:</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/132pro04.jpg" width="469.902774810791"></img></div><div><span style="color: rgb(51, 51, 51);">Because E is a non-reifiable type, there’s no way the compiler can check the cast at runtime. Again, you can easily prove to yourself that the unchecked cast is safe, so it’s appropriate to suppress the warning. In line with the advice of </span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch5.xhtml#lev27" style="color: rgb(7, 7, 7);">Item 27</a><span style="color: rgb(51, 51, 51);">, we suppress the warning only on the assignment that contains the unchecked cast.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">In summary, generic types are safer and easier to use than types that require casts in client code. When you design new types, make sure that they can be used without such casts. This will often mean making the types generic. If you have any existing types that should be generic but aren’t, generify them. This will make life easier for new users of these types without breaking existing clients (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch5.xhtml#lev26" style="color: rgb(7, 7, 7);">Item 26</a><span style="color: rgb(51, 51, 51);">).</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">FAVOR GENERIC METHODS</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">Just as classes can be generic, so can methods. Static utility methods that operate on parameterized types are usually generic. All of the “algorithm” methods in Collections (such as binarySearch and sort) are generic.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">On occasion, you will need to create an object that is immutable but applicable to many different types. Because generics are implemented by erasure (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch5.xhtml#lev28" style="color: rgb(7, 7, 7);">Item 28</a><span style="color: rgb(51, 51, 51);">), you can use a single object for all required type parameterizations, but you need to write a static factory method to repeatedly dole out the object for each requested type parameterization. This pattern, called the </span><span style="font-style: italic; color: rgb(51, 51, 51);">generic singleton factory</span><span style="color: rgb(51, 51, 51);">, is used for function objects (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch7.xhtml#lev42" style="color: rgb(7, 7, 7);">Item 42</a><span style="color: rgb(51, 51, 51);">) such as Collections.reverseOrder, and occasionally for collections such as Collections.emptySet.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">It is permissible, though relatively rare, for a type parameter to be bounded by some expression involving that type parameter itself. This is what’s known as a </span><span style="font-style: italic; color: rgb(51, 51, 51);">recursive type bound</span><span style="color: rgb(51, 51, 51);">. A common use of recursive type bounds is in connection with the Comparable interface, which defines a type’s natural ordering (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch3.xhtml#lev14" style="color: rgb(7, 7, 7);">Item 14</a><span style="color: rgb(51, 51, 51);">). This interface is shown here:</span></div><div><br/></div><div><img src="effective java_files/Image [11].jpg" type="image/jpeg" data-filename="Image.jpg" alt="Image" width="296.902774810791"/></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The type parameter T defines the type to which elements of the type implementing Comparable&lt;T&gt; can be compared. In practice, nearly all types can be compared only to elements of their own type. So, for example, String implements Comparable&lt;String&gt;, Integer implements Comparable&lt;Integer&gt;, and so on.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Many methods take a collection of elements implementing Comparable to sort it, search within it, calculate its minimum or maximum, and the like. To do these things, it is required that every element in the collection be comparable to every other element in it, in other words, that the elements of the list be </span><span style="font-style: italic; color: rgb(51, 51, 51);">mutually comparable</span><span style="color: rgb(51, 51, 51);">. Here is how to express that constraint:</span></div><div><br/></div><div><img src="effective java_files/Image [12].jpg" type="image/jpeg" data-filename="Image.jpg" alt="Image" width="554.902774810791"/></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The type bound &lt;E extends Comparable&lt;E&gt;&gt; may be read as “any type E that can be compared to itself,” which corresponds more or less precisely to the notion of mutual comparability.</span></div><div><span style="color: rgb(51, 51, 51);">Here is a method to go with the previous declaration. It calculates the maximum value in a collection according to its elements’ natural order, and it compiles without errors or warnings:</span></div><div><br/></div><div><img src="effective java_files/Image [13].jpg" type="image/jpeg" data-filename="Image.jpg" alt="Image" width="549.902774810791"/></div><div><br/></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Note that this method throws IllegalArgumentException if the list is empty. A better alternative would be to return an Optional&lt;E&gt; (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch8.xhtml#lev55" style="color: rgb(7, 7, 7);">Item 55</a><span style="color: rgb(51, 51, 51);">).</span></div><div><br/></div><div><img src="effective java_files/Image [14].jpg" type="image/jpeg" data-filename="Image.jpg" alt="Image" width="559.902774810791"/></div><div><br/></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Recursive type bounds can get much more complex, but luckily they rarely do. If you understand this idiom, its wildcard variant (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch5.xhtml#lev31" style="color: rgb(7, 7, 7);">Item 31</a>), and the <span style="font-style: italic;">simulated self-type</span> idiom (<a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch2.xhtml#lev2" style="color: rgb(7, 7, 7);">Item 2</a>), you’ll be able to deal with most of the recursive type bounds you encounter in practice.</div><div><br/></div><div><span style="color: rgb(51, 51, 51);">In summary, generic methods, like generic types, are safer and easier to use than methods requiring their clients to put explicit casts on input parameters and return values. Like types, you should make sure that your methods can be used without casts, which often means making them generic. And like types, you should generify existing methods whose use requires casts. This makes life easier for new users without breaking existing clients (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch5.xhtml#lev26" style="color: rgb(7, 7, 7);">Item 26</a>).</div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">USE BOUNDED WILDCARDS TO INCREASE API FLEXIBILITY</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">Sometimes you need more flexibility than invariant typing can provide. Consider the Stack class from </span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch5.xhtml#lev29" style="color: rgb(7, 7, 7);">Item 29</a><span style="color: rgb(51, 51, 51);">. To refresh your memory, here is its public API:</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/139pro01.jpg" width="235.90277481079102"></img></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Suppose we want to add a method that takes a sequence of elements and pushes them all onto the stack. Here’s a first attempt:</span></div><div><br/></div><div><img src="effective java_files/Image [15].jpg" type="image/jpeg" data-filename="Image.jpg" alt="Image" width="459.902774810791"/></div><div><br/></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">This method compiles cleanly, but it isn’t entirely satisfactory. If the element type of the Iterable src exactly matches that of the stack, it works fine. But suppose you have a Stack&lt;Number&gt; and you invoke push(intVal), where intVal is of type Integer. This works because Integer is a subtype of Number. So logically, it seems that this should work, too:</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/139pro03.jpg" width="399.902774810791"></img></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">If you try it, however, you’ll get this error message because parameterized types are invariant:</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/139pro04.jpg" width="577.902774810791"></img></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Luckily, there’s a way out. The language provides a special kind of parameterized type call a </span><span style="font-style: italic; color: rgb(51, 51, 51);">bounded wildcard type</span><span style="color: rgb(51, 51, 51);"> to deal with situations like this. The type of the input parameter to pushAll should not be “Iterable of E” but “Iterable of some subtype of E,” and there is a wildcard type that means precisely that: Iterable&lt;? extends E&gt;. (The use of the keyword extends is slightly misleading: recall from </span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch5.xhtml#lev29" style="color: rgb(7, 7, 7);">Item 29</a><span style="color: rgb(51, 51, 51);"> that </span><span style="font-style: italic; color: rgb(51, 51, 51);">subtype</span><span style="color: rgb(51, 51, 51);"> is defined so that every type is a subtype of itself, even though it does not extend itself.) Let’s modify pushAll to use this type:</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/140pro01.jpg" width="537.902774810791"></img></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">With this change, not only does Stack compile cleanly, but so does the client code that wouldn’t compile with the original pushAll declaration. Because Stack and its client compile cleanly, you know that everything is typesafe.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The lesson is clear. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">For maximum flexibility, use wildcard types on input parameters that represent producers or consumers.</span><span style="color: rgb(51, 51, 51);"> If an input parameter is both a producer and a consumer, then wildcard types will do you no good: you need an exact type match, which is what you get without any wildcards.</span></div><div><span style="color: rgb(51, 51, 51);">Here is a mnemonic to help you remember which wildcard type to use:</span></div><div><br/></div><div><span style="font-weight: bold; color: rgb(51, 51, 51);">PECS stands for producer-extends, consumer-super.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">In other words, if a parameterized type represents a T producer, use &lt;? extends T&gt;; if it represents a T consumer, use &lt;? super T&gt;. In our Stack example, pushAll’s src parameter produces E instances for use by the Stack, so the appropriate type for src is Iterable&lt;? extends E&gt;; popAll’s dst parameter consumes E instances from the Stack, so the appropriate type for dst is Collection&lt;? super E&gt;. The PECS mnemonic captures the fundamental principle that guides the use of wild-card types. Naftalin and Wadler call it the </span><span style="font-style: italic; color: rgb(51, 51, 51);">Get and Put Principle</span><span style="color: rgb(51, 51, 51);"> [Naftalin07, 2.4].</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">In summary, using wildcard types in your APIs, while tricky, makes the APIs far more flexible. If you write a library that will be widely used, the proper use of wildcard types should be considered mandatory. Remember the basic rule: producer-extends, consumer-super (PECS). Also remember that all comparables and comparators are consumers.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">COMBINE GENERICS AND VARARGS JUDICIOUSLY</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">Varargs methods (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch8.xhtml#lev53" style="color: rgb(7, 7, 7);">Item 53</a><span style="color: rgb(51, 51, 51);">) and generics were both added to the platform in Java 5, so you might expect them to interact gracefully; sadly, they do not. The purpose of varargs is to allow clients to pass a variable number of arguments to a method, but it is a </span><span style="font-style: italic; color: rgb(51, 51, 51);">leaky abstraction</span><span style="color: rgb(51, 51, 51);">: when you invoke a varargs method, an array is created to hold the varargs parameters; that array, which should be an implementation detail, is visible. As a consequence, you get confusing compiler warnings when varargs parameters have generic or parameterized types.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Recall from </span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch5.xhtml#lev28" style="color: rgb(7, 7, 7);">Item 28</a><span style="color: rgb(51, 51, 51);"> that a non-reifiable type is one whose runtime representation has less information than its compile-time representation, and that nearly all generic and parameterized types are non-reifiable. If a method declares its varargs parameter to be of a non-reifiable type, the compiler generates a warning on the declaration. If the method is invoked on varargs parameters whose inferred type is non-reifiable, the compiler generates a warning on the invocation too. The warnings look something like this:</span></div><div><br/></div><div><img src="effective java_files/Image [16].jpg" type="image/jpeg" data-filename="Image.jpg" alt="Image" width="413.902774810791"/></div><div><br/></div><div><span style="font-style: italic; color: rgb(51, 51, 51);">Heap pollution</span><span style="color: rgb(51, 51, 51);"> occurs when a variable of a parameterized type refers to an object that is not of that type [JLS, 4.12.2]. It can cause the compiler’s automatically generated casts to fail, violating the fundamental guarantee of the generic type system.</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/146pro02.jpg" width="535.902774810791"></img></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">This method has no visible casts yet throws a ClassCastException when invoked with one or more arguments. Its last line has an invisible cast that is generated by the compiler. This cast fails, demonstrating that type safety has been compromised, and </span><span style="font-weight: bold; color: rgb(51, 51, 51);">it is unsafe to store a value in a generic varargs array parameter.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">In Java 7, the SafeVarargs annotation was added to the platform, to allow the author of a method with a generic varargs parameter to suppress client warnings automatically. In essence, </span><span style="font-weight: bold; color: rgb(51, 51, 51);">the</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">SafeVarargs</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">annotation constitutes a promise by the author of a method that it is typesafe.</span><span style="color: rgb(51, 51, 51);"> In exchange for this promise, the compiler agrees not to warn the users of the method that calls may be unsafe.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">It is worth noting that you can violate type safety without ever storing anything in the varargs parameter array. Consider the following generic varargs method, which returns an array containing its parameters. At first glance, it may look like a handy little utility:</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/147pro01.jpg" width="546.902774810791"></img></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">This method simply returns its varargs parameter array. The method may not look dangerous, but it is! The type of this array is determined by the compile-time types of the arguments passed in to the method, and the compiler may not have enough information to make an accurate determination. Because this method returns its varargs parameter array, it can propagate heap pollution up the call stack.</span></div><div><span style="color: rgb(51, 51, 51);">To make this concrete, consider the following generic method, which takes three arguments of type T and returns an array containing two of the arguments, chosen at random:</span></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/148pro01.jpg" width="463.2361474197902"></img></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">This method is not, in and of itself, dangerous and would not generate a warning except that it invokes the toArray method, which has a generic varargs parameter.</span></div><div><span style="color: rgb(51, 51, 51);">When compiling this method, the compiler generates code to create a varargs parameter array in which to pass two T instances to toArray. This code allocates an array of type Object[], which is the most specific type that is guaranteed to hold these instances, no matter what types of objects are passed to pickTwo at the call site. The toArray method simply returns this array to pickTwo, which in turn returns it to its caller, so pickTwo will always return an array of type Object[].</span></div><div><span style="color: rgb(51, 51, 51);">Now consider this main method, which exercises pickTwo:</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/148pro02.jpg" width="516.902774810791"></img></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">There is nothing at all wrong with this method, so it compiles without generating any warnings. But when you run it, it throws a ClassCastException, though it contains no visible casts. What you don’t see is that the compiler has generated a hidden cast to String[] on the value returned by pickTwo so that it can be stored in attributes. The cast fails, because Object[] is not a subtype of String[]. This failure is quite disconcerting because it is two levels removed from the method that actually causes the heap pollution (toArray), and the varargs parameter array is not modified after the actual parameters are stored in it.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">This example is meant to drive home the point that </span><span style="font-weight: bold; color: rgb(51, 51, 51);">it is unsafe to give another method access to a generic varargs parameter array,</span><span style="color: rgb(51, 51, 51);"> with two exceptions: it is safe to pass the array to another varargs method that is correctly annotated with @SafeVarargs, and it is safe to pass the array to a non-varargs method that merely computes some function of the contents of the array.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Here is a typical example of a safe use of a generic varargs parameter. This method takes an arbitrary number of lists as arguments and returns a single list containing the elements of all of the input lists in sequence. Because the method is annotated with @SafeVarargs, it doesn’t generate any warnings, on the declaration or at its call sites:</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/149pro01.jpg" width="491.5360817212737"></img></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The rule for deciding when to use the SafeVarargs annotation is simple: </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Use</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">@SafeVarargs</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">on every method with a varargs parameter of a generic or parameterized type,</span><span style="color: rgb(51, 51, 51);"> so its users won’t be burdened by needless and confusing compiler warnings. This implies that you should </span><span style="font-style: italic; color: rgb(51, 51, 51);">never</span><span style="color: rgb(51, 51, 51);"> write unsafe varargs methods like dangerous or toArray. Every time the compiler warns you of possible heap pollution from a generic varargs parameter in a method you control, check that the method is safe. As a reminder, a generic varargs methods is safe if:</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">1. it doesn’t store anything in the varargs parameter array, and</span></div><div><span style="color: rgb(51, 51, 51);">2. it doesn’t make the array (or a clone) visible to untrusted code. If either of these prohibitions is violated, fix it.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Note that the SafeVarargs annotation is legal only on methods that can’t be overridden, because it is impossible to guarantee that every possible overriding method will be safe. In Java 8, the annotation was legal only on static methods and final instance methods; in Java 9, it became legal on private instance methods as well.</span></div><div><span style="color: rgb(51, 51, 51);">An alternative to using the SafeVarargs annotation is to take the advice of </span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch5.xhtml#lev28" style="color: rgb(7, 7, 7);">Item 28</a> and replace the varargs parameter (which is an array in disguise) with a List parameter. Here’s how this approach looks when applied to our flatten method. Note that only the parameter declaration has changed:</div><div><br/></div><div><img src="effective java_files/Image [17].jpg" type="image/jpeg" data-filename="Image.jpg" alt="Image" width="568.902774810791"/></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">This method can then be used in conjunction with the static factory method List.of to allow for a variable number of arguments. Note that this approach relies on the fact that the List.of declaration is annotated with @SafeVarargs:</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/150pro01.jpg" width="531.902774810791"></img></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The advantage of this approach is that the compiler can </span><span style="font-style: italic; color: rgb(51, 51, 51);">prove</span><span style="color: rgb(51, 51, 51);"> that the method is typesafe. You don’t have to vouch for its safety with a SafeVarargs annotation, and you don’t have worry that you might have erred in determining that it was safe. The main disadvantage is that the client code is a bit more verbose and may be a bit slower.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">This trick can also be used in situations where it is impossible to write a safe varargs method, as is the case with the toArray method on page 147. Its List analogue </span><span style="font-style: italic; color: rgb(51, 51, 51);">is</span><span style="color: rgb(51, 51, 51);"> the List.of method, so we don’t even have to write it; the Java libraries authors have done the work for us. The pickTwo method then becomes this:</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/150pro02.jpg" width="348.902774810791"></img></div><div><br/></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">CONSIDER TYPESAFE HETEROGENEOUS CONTAINERS</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">Common uses of generics include collections, such as Set&lt;E&gt; and Map&lt;K,V&gt;, and single-element containers, such as ThreadLocal&lt;T&gt; and AtomicReference&lt;T&gt;. In all of these uses, it is the container that is parameterized. This limits you to a fixed number of type parameters per container. Normally that is exactly what you want. A Set has a single type parameter, representing its element type; a Map has two, representing its key and value types; and so forth.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Sometimes, however, you need more flexibility. For example, a database row can have arbitrarily many columns, and it would be nice to be able to access all of them in a typesafe manner. Luckily, there is an easy way to achieve this effect. The idea is to parameterize the </span><span style="font-style: italic; color: rgb(51, 51, 51);">key</span><span style="color: rgb(51, 51, 51);"> instead of the </span><span style="font-style: italic; color: rgb(51, 51, 51);">container</span><span style="color: rgb(51, 51, 51);">. Then present the parameterized key to the container to insert or retrieve a value. The generic type system is used to guarantee that the type of the value agrees with its key.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">As a simple example of this approach, consider a Favorites class that allows its clients to store and retrieve a favorite instance of arbitrarily many types. The Class object for the type will play the part of the parameterized key. The reason this works is that class Class is generic. The type of a class literal is not simply Class, but Class&lt;T&gt;. For example, String.class is of type Class&lt;String&gt;, and Integer.class is of type Class&lt;Integer&gt;. When a class literal is passed among methods to communicate both compile-time and runtime type information, it is called a </span><span style="font-style: italic; color: rgb(51, 51, 51);">type token</span><span style="color: rgb(51, 51, 51);"> [</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ref.xhtml#rBracha04" style="color: rgb(7, 7, 7);">Bracha04</a>].</div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The API for the Favorites class is simple. It looks just like a simple map, except that the key is parameterized instead of the map. The client presents a Class object when setting and getting favorites. Here is the API:</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/151pro01.jpg" width="505.902774810791"></img></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">A Favorites instance is </span><span style="font-style: italic; color: rgb(51, 51, 51);">typesafe</span><span style="color: rgb(51, 51, 51);">: it will never return an Integer when you ask it for a String. It is also </span><span style="font-style: italic; color: rgb(51, 51, 51);">heterogeneous</span><span style="color: rgb(51, 51, 51);">: unlike an ordinary map, all the keys are of different types. Therefore, we call Favorites a </span><span style="font-style: italic; color: rgb(51, 51, 51);">typesafe heterogeneous container</span><span style="color: rgb(51, 51, 51);">. The implementation of Favorites is surprisingly tiny. Here it is, in its entirety:</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/152pro02.jpg" width="516.902774810791"></img></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">There are a few subtle things going on here. Each Favorites instance is backed by a private Map&lt;Class&lt;?&gt;, Object&gt; called favorites. You might think that you couldn’t put anything into this Map because of the unbounded wildcard type, but the truth is quite the opposite. The thing to notice is that the wildcard type is nested: it’s not the type of the map that’s a wildcard type but the type of its key. This means that every key can have a </span><span style="font-style: italic; color: rgb(51, 51, 51);">different</span><span style="color: rgb(51, 51, 51);"> parameterized type: one can be Class&lt;String&gt;, the next Class&lt;Integer&gt;, and so on. That’s where the heterogeneity comes from.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The next thing to notice is that the value type of the favorites Map is simply Object. In other words, the Map does not guarantee the type relationship between keys and values, which is that every value is of the type represented by its key. In fact, Java’s type system is not powerful enough to express this. But we know that it’s true, and we take advantage of it when the time comes to retrieve a favorite.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The putFavorite implementation is trivial: it simply puts into favorites a mapping from the given Class object to the given favorite instance. As noted, this discards the “type linkage” between the key and the value; it loses the knowledge that the value is an instance of the key. But that’s OK, because the getFavorites method can and does reestablish this linkage.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The implementation of getFavorite is trickier than that of putFavorite. First, it gets from the favorites map the value corresponding to the given Class object. This is the correct object reference to return, but it has the wrong compile-time type: it is Object (the value type of the favorites map) and we need to return a T. So, the getFavorite implementation </span><span style="font-style: italic; color: rgb(51, 51, 51);">dynamically casts</span><span style="color: rgb(51, 51, 51);"> the object reference to the type represented by the Class object, using Class’s cast method.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The cast method is the dynamic analogue of Java’s cast operator. It simply checks that its argument is an instance of the type represented by the Class object. If so, it returns the argument; otherwise it throws a ClassCastException. We know that the cast invocation in getFavorite won’t throw ClassCastException, assuming the client code compiled cleanly. That is to say, we know that the values in the favorites map always match the types of their keys.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">So what does the cast method do for us, given that it simply returns its argument? The signature of the cast method takes full advantage of the fact that class Class is generic. Its return type is the type parameter of the Class object:</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/153pro01.jpg" width="200.90277481079102"></img></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">This is precisely what’s needed by the getFavorite method. It is what allows us to make Favorites typesafe without resorting to an unchecked cast to T.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">There are two limitations to the Favorites class that are worth noting. First, a malicious client could easily corrupt the type safety of a Favorites instance, by using a Class object in its raw form. But the resulting client code would generate an unchecked warning when it was compiled. This is no different from a normal collection implementations such as HashSet and HashMap. You can easily put a String into a HashSet&lt;Integer&gt; by using the raw type HashSet (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch5.xhtml#lev26" style="color: rgb(7, 7, 7);">Item 26</a><span style="color: rgb(51, 51, 51);">). That said, you can have runtime type safety if you’re willing to pay for it. The way to ensure that Favorites never violates its type invariant is to have the putFavorite method check that instance is actually an instance of the type represented by type, and we already know how to do this. Just use a dynamic cast:</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The second limitation of the Favorites class is that it cannot be used on a non-reifiable type (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch5.xhtml#lev28" style="color: rgb(7, 7, 7);">Item 28</a><span style="color: rgb(51, 51, 51);">). In other words, you can store your favorite String or String[], but not your favorite List&lt;String&gt;. If you try to store your favorite List&lt;String&gt;, your program won’t compile. The reason is that you can’t get a Class object for List&lt;String&gt;. The class literal List&lt;String&gt;.class is a syntax error, and it’s a good thing, too. List&lt;String&gt; and List&lt;Integer&gt; share a single Class object, which is List.class. It would wreak havoc with the internals of a Favorites object if the “type literals” List&lt;String&gt;.class and List&lt;Integer&gt;.class were legal and returned the same object reference. There is no entirely satisfactory workaround for this limitation.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">In summary, the normal use of generics, exemplified by the collections APIs, restricts you to a fixed number of type parameters per container. You can get around this restriction by placing the type parameter on the key rather than the container. You can use Class objects as keys for such typesafe heterogeneous containers. A Class object used in this fashion is called a type token. You can also use a custom key type. For example, you could have a DatabaseRow type representing a database row (the container), and a generic type Column&lt;T&gt; as its key.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">USE ENUMS INSTEAD OF</span><span style="color: rgb(64, 64, 64);"> </span><span style="font-weight: bold; color: rgb(64, 64, 64);">INT</span><span style="color: rgb(64, 64, 64);"> </span><span style="font-weight: bold; color: rgb(64, 64, 64);">CONSTANTS</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">An </span><span style="font-style: italic; color: rgb(51, 51, 51);">enumerated type</span><span style="color: rgb(51, 51, 51);"> is a type whose legal values consist of a fixed set of constants, such as the seasons of the year, the planets in the solar system, or the suits in a deck of playing cards. Before enum types were added to the language, a common pattern for representing enumerated types was to declare a group of named int constants, one for each member of the type.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Programs that use int enums are brittle. Because int enums are </span><span style="font-style: italic; color: rgb(51, 51, 51);">constant variables</span><span style="color: rgb(51, 51, 51);"> [JLS, 4.12.4], their int values are compiled into the clients that use them [JLS, 13.1]. If the value associated with an int enum is changed, its clients must be recompiled. If not, the clients will still run, but their behavior will be incorrect. You may encounter a variant of this pattern in which String constants are used in place of int constants. This variant, known as the </span><span style="font-style: italic; color: rgb(51, 51, 51);">String</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-style: italic; color: rgb(51, 51, 51);">enum pattern</span><span style="color: rgb(51, 51, 51);">, is even less desirable. While it does provide printable strings for its constants, it can lead naive users to hard-code string constants into client code instead of using field names.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Luckily, Java provides an alternative that avoids all the shortcomings of the int and string enum patterns and provides many added benefits. It is the </span><span style="font-style: italic; color: rgb(51, 51, 51);">enum type.</span></div><div><span style="color: rgb(51, 51, 51);">The basic idea behind Java’s enum types is simple: they are classes that export one instance for each enumeration constant via a public static final field. Enum types are effectively final, by virtue of having no accessible constructors. Because clients can neither create instances of an enum type nor extend it, there can be no instances but the declared enum constants. In other words, enum types are instance-controlled (page 6). They are a generalization of singletons (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch2.xhtml#lev3" style="color: rgb(7, 7, 7);">Item 3</a><span style="color: rgb(51, 51, 51);">), which are essentially single-element enums.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">It is easy to write a rich enum type such as Planet. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">To associate data with enum constants, declare instance fields and write a constructor that takes the data and stores it in the fields.</span><span style="color: rgb(51, 51, 51);"> Enums are by their nature immutable, so all fields should be final (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch4.xhtml#lev17" style="color: rgb(7, 7, 7);">Item 17</a><span style="color: rgb(51, 51, 51);">). Fields can be public, but it is better to make them private and provide public accessors.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">So when should you use enums? </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Use enums any time you need a set of constants whose members are known at compile time.</span><span style="color: rgb(51, 51, 51);"> Of course, this includes “natural enumerated types,” such as the planets, the days of the week, and the chess pieces. But it also includes other sets for which you know all the possible values at compile time, such as choices on a menu, operation codes, and command line flags. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">It is not necessary that the set of constants in an enum type stay fixed for all time.</span><span style="color: rgb(51, 51, 51);"> The enum feature was specifically designed to allow for binary compatible evolution of enum types.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">In summary, the advantages of enum types over int constants are compelling. Enums are more readable, safer, and more powerful. Many enums require no explicit constructors or members, but others benefit from associating data with each constant and providing methods whose behavior is affected by this data. Fewer enums benefit from associating multiple behaviors with a single method. In this relatively rare case, prefer constant-specific methods to enums that switch on their own values.</span> <span style="font-weight: bold; color: rgb(51, 51, 51);">Consider the strategy enum pattern if some, but not all, enum constants share common behaviors.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">USE INSTANCE FIELDS INSTEAD OF ORDINALS</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-weight: bold; color: rgb(51, 51, 51);">Never derive a value associated with an enum from its ordinal; store it in an instance field instead.</span> <span style="color: rgb(51, 51, 51);">The Enum specification has this to say about ordinal: “Most programmers will have no use for this method. It is designed for use by general-purpose enum-based data structures such as EnumSet and EnumMap.” Unless you are writing code with this character, you are best off avoiding the ordinal method entirely.</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/169pro01.jpg" width="540.902774810791"></img></div><div><br/></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">USE</span><span style="color: rgb(64, 64, 64);"> </span><span style="font-weight: bold; color: rgb(64, 64, 64);">ENUMSET</span><span style="color: rgb(64, 64, 64);"> </span><span style="font-weight: bold; color: rgb(64, 64, 64);">INSTEAD OF BIT FIELDS</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">If the elements of an enumerated type are used primarily in sets, it is traditional to use the int enum pattern (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch6.xhtml#lev34" style="color: rgb(7, 7, 7);">Item 34</a><span style="color: rgb(51, 51, 51);">), assigning a different power of 2 to each constant:</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/169pro01.jpg" width="537.902774810791"></img></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">This representation lets you use the bitwise OR operation to combine several constants into a set, known as a </span><span style="font-style: italic; color: rgb(51, 51, 51);">bit field</span><span style="color: rgb(51, 51, 51);">:</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/169pro02.jpg" width="374.902774810791"></img></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The bit field representation also lets you perform set operations such as union and intersection efficiently using bitwise arithmetic. But bit fields have all the disadvantages of int enum constants and more. It is even harder to interpret a bit field than a simple int enum constant when it is printed as a number. There is no easy way to iterate over all of the elements represented by a bit field. Finally, you have to predict the maximum number of bits you’ll ever need at the time you’re writing the API and choose a type for the bit field (typically int or long) accordingly. Once you’ve picked a type, you can’t exceed its width (32 or 64 bits) without changing the API.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Some programmers who use enums in preference to int constants still cling to the use of bit fields when they need to pass around sets of constants. There is no reason to do this, because a better alternative exists. The java.util package provides the EnumSet class to efficiently represent sets of values drawn from a single enum type. This class implements the Set interface, providing all of the richness, type safety, and interoperability you get with any other Set implementation. But internally, each EnumSet is represented as a bit vector. If the underlying enum type has sixty-four or fewer elements—and most do—the entire EnumSet is represented with a single long, so its performance is comparable to that of a bit field. Bulk operations, such as removeAll and retainAll, are implemented using bitwise arithmetic, just as you’d do manually for bit fields. But you are insulated from the ugliness and error-proneness of manual bit twiddling: the EnumSet does the hard work for you.</span></div><div><span style="color: rgb(51, 51, 51);">Here is how the previous example looks when modified to use enums and enum sets instead of bit fields. It is shorter, clearer, and safer:</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/170pro01.jpg" width="574.902774810791"></img></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Here is client code that passes an EnumSet instance to the applyStyles method. The EnumSet class provides a rich set of static factories for easy set creation, one of which is illustrated in this code:</span></div><div><br/></div><div><img src="effective java_files/Image [18].jpg" type="image/jpeg" data-filename="Image.jpg" alt="Image" width="473.902774810791"/></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Note that the applyStyles method takes a Set&lt;Style&gt; rather than an EnumSet&lt;Style&gt;. While it seems likely that all clients would pass an EnumSet to the method, it is generally good practice to accept the interface type rather than the implementation type (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch9.xhtml#lev64" style="color: rgb(7, 7, 7);">Item 64</a><span style="color: rgb(51, 51, 51);">). This allows for the possibility of an unusual client to pass in some other Set implementation.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">In summary, </span><span style="font-weight: bold; color: rgb(51, 51, 51);">just because an enumerated type will be used in sets, there is no reason to represent it with bit fields.</span><span style="color: rgb(51, 51, 51);"> The EnumSet class combines the conciseness and performance of bit fields with all the many advantages of enum types described in </span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch6.xhtml#lev34" style="color: rgb(7, 7, 7);">Item 34</a><span style="color: rgb(51, 51, 51);">. The one real disadvantage of EnumSet is that it is not, as of Java 9, possible to create an immutable EnumSet, but this will likely be remedied in an upcoming release. In the meantime, you can wrap an EnumSet with Collections.unmodifiableSet, but conciseness and performance will suffer.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">USE</span><span style="color: rgb(64, 64, 64);"> </span><span style="font-weight: bold; color: rgb(64, 64, 64);">ENUMMAP</span><span style="color: rgb(64, 64, 64);"> </span><span style="font-weight: bold; color: rgb(64, 64, 64);">INSTEAD OF ORDINAL INDEXING</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">there is a very fast Map implementation designed for use with enum keys, known as java.util.EnumMap. Here is how the program looks when it is rewritten to use EnumMap:</span></div><div><br/></div><div><img src="effective java_files/Image [19].jpg" type="image/jpeg" data-filename="Image.jpg" alt="Image" width="468.0884044796395"/></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">This program is shorter, clearer, safer, and comparable in speed to the original version. There is no unsafe cast; no need to label the output manually because the map keys are enums that know how to translate themselves to printable strings; and no possibility for error in computing array indices. The reason that EnumMap is comparable in speed to an ordinal-indexed array is that EnumMap uses such an array internally, but it hides this implementation detail from the programmer, combining the richness and type safety of a Map with the speed of an array. Note that the EnumMap constructor takes the Class object of the key type: this is a </span><span style="font-style: italic; color: rgb(51, 51, 51);">bounded type token</span><span style="color: rgb(51, 51, 51);">, which provides runtime generic type information (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch5.xhtml#lev33" style="color: rgb(7, 7, 7);">Item 33</a><span style="color: rgb(51, 51, 51);">).</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The previous program can be further shortened by using a stream (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch7.xhtml#lev45" style="color: rgb(7, 7, 7);">Item 45</a><span style="color: rgb(51, 51, 51);">) to manage the map. Here is the simplest stream-based code that largely duplicates the behavior of the previous example:</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/173pro01.jpg" width="525.902774810791"></img></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">This optimization would not be worth doing in a toy program like this one but could be critical in a program that made heavy use of the map.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">In summary, </span><span style="font-weight: bold; color: rgb(51, 51, 51);">it is rarely appropriate to use ordinals to index into arrays: use</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">EnumMap</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">instead.</span><span style="color: rgb(51, 51, 51);"> If the relationship you are representing is multidimensional, use EnumMap&lt;..., EnumMap&lt;...&gt;&gt;. This is a special case of the general principle that application programmers should rarely, if ever, use Enum.ordinal (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch6.xhtml#lev35" style="color: rgb(7, 7, 7);">Item 35</a><span style="color: rgb(51, 51, 51);">).</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">EMULATE EXTENSIBLE ENUMS WITH INTERFACES</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">In almost all respects, enum types are superior to the typesafe enum pattern described in the first edition of this book [</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ref.xhtml#rBloch01" style="color: rgb(7, 7, 7);">Bloch01</a>]. On the face of it, one exception concerns extensibility, which was possible under the original pattern but is not supported by the language construct. In other words, using the pattern, it was possible to have one enumerated type extend another; using the language feature, it is not. This is no accident. For the most part, extensibility of enums turns out to be a bad idea. It is confusing that elements of an extension type are instances of the base type and not vice versa. There is no good way to enumerate over all of the elements of a base type and its extensions. Finally, extensibility would complicate many aspects of the design and implementation.</div><div><br/></div><div><span style="color: rgb(51, 51, 51);">That said, there is at least one compelling use case for extensible enumerated types, which is </span><span style="font-style: italic; color: rgb(51, 51, 51);">operation codes,</span><span style="color: rgb(51, 51, 51);"> also known as </span><span style="font-style: italic; color: rgb(51, 51, 51);">opcodes.</span><span style="color: rgb(51, 51, 51);"> An opcode is an enumerated type whose elements represent operations on some machine, such as the Operation type in </span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch6.xhtml#lev34" style="color: rgb(7, 7, 7);">Item 34</a>, which represents the functions on a simple calculator. Sometimes it is desirable to let the users of an API provide their own operations, effectively extending the set of operations provided by the API.</div><div><br/></div><div><span style="color: rgb(51, 51, 51);">While the enum type (BasicOperation) is not extensible, the interface type (Operation) is, and it is the interface type that is used to represent operations in APIs. You can define another enum type that implements this interface and use instances of this new type in place of the base type. For example, suppose you want to define an extension to the operation type shown earlier, consisting of the exponentiation and remainder operations. All you have to do is write an enum type that implements the Operation interface.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">In summary, </span><span style="font-weight: bold; color: rgb(51, 51, 51);">while you cannot write an extensible enum type, you can emulate it by writing an interface to accompany a basic enum type that implements the interface.</span><span style="color: rgb(51, 51, 51);"> This allows clients to write their own enums (or other types) that implement the interface. Instances of these types can then be used wherever instances of the basic enum type can be used, assuming APIs are written in terms of the interface.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">PREFER ANNOTATIONS TO NAMING PATTERNS</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">Historically, it was common to use </span><span style="font-style: italic; color: rgb(51, 51, 51);">naming patterns</span><span style="color: rgb(51, 51, 51);"> to indicate that some program elements demanded special treatment by a tool or framework. For example, prior to release 4, the JUnit testing framework required its users to designate test methods by beginning their names with the characters test [</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ref.xhtml#rBeck04" style="color: rgb(7, 7, 7);">Beck04</a><span style="color: rgb(51, 51, 51);">]. This technique works, but it has several big disadvantages. First, typographical errors result in silent failures. For example, suppose you accidentally named a test method tsetSafetyOverride instead of testSafetyOverride. JUnit 3 wouldn’t complain, but it wouldn’t execute the test either, leading to a false sense of security.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Annotations [JLS, 9.7] solve all of these problems nicely, and JUnit adopted them starting with release 4. In this item, we’ll write our own toy testing framework to show how annotations work. Suppose you want to define an annotation type to designate simple tests that are run automatically and fail if they throw an exception. Here’s how such an annotation type, named Test, might look:</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/180pro01.jpg" width="457.902774810791"></img></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The declaration for the Test annotation type is itself annotated with Retention and Target annotations. Such annotations on annotation type declarations are known as </span><span style="font-style: italic; color: rgb(51, 51, 51);">meta-annotations</span><span style="color: rgb(51, 51, 51);">. The @Retention(RetentionPolicy.RUNTIME) meta-annotation indicates that Test annotations should be retained at runtime. Without it, Test annotations would be invisible to the test tool. The @Target.get(ElementType.METHOD) meta-annotation indicates that the Test annotation is legal only on method declarations: it cannot be applied to class declarations, field declarations, or other program elements.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Taking our exception testing example one step further, it is possible to envision a test that passes if it throws any one of several specified exceptions. The annotation mechanism has a facility that makes it easy to support this usage. Suppose we change the parameter type of the ExceptionTest annotation to be an array of Class objects:</span></div><div><br/></div><div><img src="effective java_files/Image [20].jpg" type="image/jpeg" data-filename="Image.jpg" alt="Image" width="386.902774810791"/></div><div><br/></div><div><br/></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">CONSISTENTLY USE THE</span><span style="color: rgb(64, 64, 64);"> </span><span style="font-weight: bold; color: rgb(64, 64, 64);">OVERRIDE</span><span style="color: rgb(64, 64, 64);"> </span><span style="font-weight: bold; color: rgb(64, 64, 64);">ANNOTATION</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div>The Java libraries contain several annotation types. For the typical programmer, the most important of these is @Override. This annotation can be used only on method declarations, and it indicates that the annotated method declaration overrides a declaration in a supertype. If you consistently use this annotation, it will protect you from a large class of nefarious bugs.</div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Therefore, you should </span><span style="font-weight: bold; color: rgb(51, 51, 51);">use the</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Override</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">annotation on every method declaration that you believe to override a superclass declaration.</span><span style="color: rgb(51, 51, 51);"> There is one minor exception to this rule. If you are writing a class that is not labeled abstract and you believe that it overrides an abstract method in its superclass, you needn’t bother putting the Override annotation on that method. In a class that is not declared abstract, the compiler will emit an error message if you fail to override an abstract superclass method. However, you might wish to draw attention to all of the methods in your class that override superclass methods, in which case you should feel free to annotate these methods too. Most IDEs can be set to insert Override annotations automatically when you elect to override a method.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">USE MARKER INTERFACES TO DEFINE TYPES</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">A </span><span style="font-style: italic; color: rgb(51, 51, 51);">marker interface</span><span style="color: rgb(51, 51, 51);"> is an interface that contains no method declarations but merely designates (or “marks”) a class that implements the interface as having some property. For example, consider the Serializable interface (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch12.xhtml#ch12" style="color: rgb(7, 7, 7);">Chapter 12</a><span style="color: rgb(51, 51, 51);">). By implementing this interface, a class indicates that its instances can be written to an ObjectOutputStream (or “serialized”).</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">You may hear it said that marker annotations (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch6.xhtml#lev39" style="color: rgb(7, 7, 7);">Item 39</a><span style="color: rgb(51, 51, 51);">) make marker interfaces obsolete. This assertion is incorrect. Marker interfaces have two advantages over marker annotations. First and foremost, </span><span style="font-weight: bold; color: rgb(51, 51, 51);">marker interfaces define a type that is implemented by instances of the marked class; marker annotations do not.</span><span style="color: rgb(51, 51, 51);"> The existence of a marker interface type allows you to catch errors at compile time that you couldn’t catch until runtime if you used a marker annotation</span></div><div><br/></div><div><span style="font-weight: bold; color: rgb(51, 51, 51);">Another advantage of marker interfaces over marker annotations is that they can be targeted more precisely.</span><span style="color: rgb(51, 51, 51);"> If an annotation type is declared with target ElementType.TYPE, it can be applied to </span><span style="font-style: italic; color: rgb(51, 51, 51);">any</span><span style="color: rgb(51, 51, 51);"> class or interface. Suppose you have a marker that is applicable only to implementations of a particular interface. If you define it as a marker interface, you can have it extend the sole interface to which it is applicable, guaranteeing that all marked types are also subtypes of the sole interface to which it is applicable.</span></div><div><br/></div><div><span style="font-weight: bold; color: rgb(51, 51, 51);">The chief advantage of marker annotations over marker interfaces is that they are part of the larger annotation facility.</span><span style="color: rgb(51, 51, 51);"> Therefore, marker annotations allow for consistency in annotation-based frameworks.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">In summary, marker interfaces and marker annotations both have their uses. If you want to define a type that does not have any new methods associated with it, a marker interface is the way to go. If you want to mark program elements other than classes and interfaces or to fit the marker into a framework that already makes heavy use of annotation types, then a marker annotation is the correct choice. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">If you find yourself writing a marker annotation type whose target is</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">ElementType.TYPE, take the time to figure out whether it really should be an annotation type or whether a marker interface would be more appropriate.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">PREFER LAMBDAS TO ANONYMOUS CLASSES</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">lambdas are by far the best way to represent small function objects. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Don’t use anonymous classes for function objects unless you have to create instances of types that aren’t functional interfaces.</span><span style="color: rgb(51, 51, 51);"> Also, remember that lambdas make it so easy to represent small function objects that it opens the door to functional programming techniques that were not previously practical in Java.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">PREFER METHOD REFERENCES TO LAMBDAS</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">method references often provide a more succinct alternative to lambdas. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Where method references are shorter and clearer, use them; where they aren’t, stick with lambdas</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">FAVOR THE USE OF STANDARD FUNCTIONAL INTERFACES</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">Now that Java has lambdas, best practices for writing APIs have changed considerably. For example, the </span><span style="font-style: italic; color: rgb(51, 51, 51);">Template Method</span><span style="color: rgb(51, 51, 51);"> pattern [</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ref.xhtml#rGamma95" style="color: rgb(7, 7, 7);">Gamma95</a><span style="color: rgb(51, 51, 51);">], wherein a subclass overrides a </span><span style="font-style: italic; color: rgb(51, 51, 51);">primitive method</span><span style="color: rgb(51, 51, 51);"> to specialize the behavior of its superclass, is far less attractive. The modern alternative is to provide a static factory or constructor that accepts a function object to achieve the same effect. More generally, you’ll be writing more constructors and methods that take function objects as parameters. Choosing the right functional parameter type demands care.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The java.util.function package provides a large collection of standard functional interfaces for your use. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">If one of the standard functional interfaces does the job, you should generally use it in preference to a purpose-built functional interface.</span><span style="color: rgb(51, 51, 51);"> This will make your API easier to learn, by reducing its conceptual surface area, and will provide significant interoperability benefits, as many of the standard functional interfaces provide useful default methods</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Most of the standard functional interfaces exist only to provide support for primitive types. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Don’t be tempted to use basic functional interfaces with boxed primitives instead of primitive functional interfaces.</span><span style="color: rgb(51, 51, 51);"> While it works, it violates the advice of </span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch9.xhtml#lev61" style="color: rgb(7, 7, 7);">Item 61</a><span style="color: rgb(51, 51, 51);">, “prefer primitive types to boxed primitives.” The performance consequences of using boxed primitives for bulk operations can be deadly.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Notice that the custom interface  is labeled with the @FunctionalInterface annotation. This annotation type is similar in spirit to @Override. It is a statement of programmer intent that serves three purposes: it tells readers of the class and its documentation that the interface was designed to enable lambdas; it keeps you honest because the interface won’t compile unless it has exactly one abstract method; and it prevents maintainers from accidentally adding abstract methods to the interface as it evolves. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Always annotate your functional interfaces with the</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">@FunctionalInterface</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">annotation</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">A final point should be made concerning the use of functional interfaces in APIs. Do not provide a method with multiple overloadings that take different functional interfaces in the same argument position if it could create a possible ambiguity in the client. This is not just a theoretical problem. The submit method of ExecutorService can take either a Callable&lt;T&gt; or a Runnable, and it is possible to write a client program that requires a cast to indicate the correct overloading (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch8.xhtml#lev52" style="color: rgb(7, 7, 7);">Item 52</a><span style="color: rgb(51, 51, 51);">). The easiest way to avoid this problem is not to write overloadings that take different functional interfaces in the same argument position. This is a special case of the advice in </span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch8.xhtml#lev52" style="color: rgb(7, 7, 7);">Item 52</a><span style="color: rgb(51, 51, 51);">, “use overloading judiciously.”</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">USE STREAMS JUDICIOUSLY</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">The streams API is sufficiently versatile that practically any computation can be performed using streams, but just because you can doesn’t mean you should. When used appropriately, streams can make programs shorter and clearer; when used inappropriately, they can make programs difficult to read and maintain. There are no hard and fast rules for when to use streams, but there are heuristics.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Note that the lambda parameter names were chosen carefully. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">In the absence of explicit types, careful naming of lambda parameters is essential to the readability of stream pipelines.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Note also that word alphabetization is done in a separate alphabetize method. This enhances readability by providing a name for the operation and keeping implementation details out of the main program. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Using helper methods is even more important for readability in stream pipelines than in iterative code</span><span style="color: rgb(51, 51, 51);"> because pipelines lack explicit type information and named temporary variables.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">One thing that is hard to do with streams is to access corresponding elements from multiple stages of a pipeline simultaneously: once you map a value to some other value, the original value is lost. One workaround is to map each value to a </span><span style="font-style: italic; color: rgb(51, 51, 51);">pair object</span><span style="color: rgb(51, 51, 51);"> containing the original value and the new value, but this is not a satisfying solution, especially if the pair objects are required for multiple stages of a pipeline. The resulting code is messy and verbose, which defeats a primary purpose of streams. When it is applicable, a better workaround is to invert the mapping when you need access to the earlier-stage value.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">PREFER SIDE-EFFECT-FREE FUNCTIONS IN STREAMS</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">The most important part of the streams paradigm is to structure your computation as a sequence of transformations where the result of each stage is as close as possible to a </span><span style="font-style: italic; color: rgb(51, 51, 51);">pure function</span><span style="color: rgb(51, 51, 51);"> of the result of the previous stage. A pure function is one whose result depends only on its input: it does not depend on any mutable state, nor does it update any state. In order to achieve this, any function objects that you pass into stream operations, both intermediate and terminal, should be free of side-effects.</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/210pro01.jpg" width="498.902774810791"></img></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">What’s wrong with this code? After all, it uses streams, lambdas, and method references, and gets the right answer. Simply put, it’s not streams code at all; it’s iterative code masquerading as streams code. It derives no benefits from the streams API, and it’s (a bit) longer, harder to read, and less maintainable than the corresponding iterative code. The problem stems from the fact that this code is doing all its work in a terminal forEach operation, using a lambda that mutates external state (the frequency table). A forEach operation that does anything more than present the result of the computation performed by a stream is a “bad smell in code,” as is a lambda that mutates state. So how should this code look?</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/210pro02.jpg" width="533.902774810791"></img></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">This snippet does the same thing as the previous one but makes proper use of the streams API. It’s shorter and clearer. So why would anyone write it the other way? Because it uses tools they’re already familiar with. Java programmers know how to use for-each loops, and the forEach terminal operation is similar. But the forEach operation is among the least powerful of the terminal operations and the least stream-friendly. It’s explicitly iterative, and hence not amenable to parallelization. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">The</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">forEach</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">operation should be used only to report the result of a stream computation, not to perform the computation.</span><span style="color: rgb(51, 51, 51);"> Occasionally, it makes sense to use forEach for some other purpose, such as adding the results of a stream computation to a preexisting collection.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">PREFER COLLECTION TO STREAM AS A RETURN TYPE</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">Many methods return sequences of elements. Prior to Java 8, the obvious return types for such methods were the collection interfaces Collection, Set, and List; Iterable; and the array types. Usually, it was easy to decide which of these types to return. The norm was a collection interface. If the method existed solely to enable for-each loops or the returned sequence couldn’t be made to implement some Collection method (typically, contains(Object)), the Iterable interface was used. If the returned elements were primitive values or there were stringent performance requirements, arrays were used. In Java 8, streams were added to the platform, substantially complicating the task of choosing the appropriate return type for a sequence-returning method.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">If the sequence you’re returning is large but can be represented concisely, consider implementing a special-purpose collection. For example, suppose you want to return the </span><span style="font-style: italic; color: rgb(51, 51, 51);">power set</span><span style="color: rgb(51, 51, 51);"> of a given set, which consists of all of its subsets. The power set of {</span><span style="font-style: italic; color: rgb(51, 51, 51);">a</span><span style="color: rgb(51, 51, 51);">, </span><span style="font-style: italic; color: rgb(51, 51, 51);">b</span><span style="color: rgb(51, 51, 51);">, </span><span style="font-style: italic; color: rgb(51, 51, 51);">c</span><span style="color: rgb(51, 51, 51);">} is {{}, {</span><span style="font-style: italic; color: rgb(51, 51, 51);">a</span><span style="color: rgb(51, 51, 51);">}, {</span><span style="font-style: italic; color: rgb(51, 51, 51);">b</span><span style="color: rgb(51, 51, 51);">}, {</span><span style="font-style: italic; color: rgb(51, 51, 51);">c</span><span style="color: rgb(51, 51, 51);">}, {</span><span style="font-style: italic; color: rgb(51, 51, 51);">a</span><span style="color: rgb(51, 51, 51);">, </span><span style="font-style: italic; color: rgb(51, 51, 51);">b</span><span style="color: rgb(51, 51, 51);">}, {</span><span style="font-style: italic; color: rgb(51, 51, 51);">a, c</span><span style="color: rgb(51, 51, 51);">}, {</span><span style="font-style: italic; color: rgb(51, 51, 51);">b</span><span style="color: rgb(51, 51, 51);">, </span><span style="font-style: italic; color: rgb(51, 51, 51);">c</span><span style="color: rgb(51, 51, 51);">}, {</span><span style="font-style: italic; color: rgb(51, 51, 51);">a</span><span style="color: rgb(51, 51, 51);">, </span><span style="font-style: italic; color: rgb(51, 51, 51);">b</span><span style="color: rgb(51, 51, 51);">, </span><span style="font-style: italic; color: rgb(51, 51, 51);">c</span><span style="color: rgb(51, 51, 51);">}}. If a set has </span><span style="font-style: italic; color: rgb(51, 51, 51);">n</span><span style="color: rgb(51, 51, 51);"> elements, its power set has 2</span><span style="font-style: italic; vertical-align: super; color: rgb(102, 102, 102);">n</span>. Therefore, you shouldn’t even consider storing the power set in a standard collection implementation. It is, however, easy to implement a custom collection for the job with the help of AbstractList.</div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The trick is to use the index of each element in the power set as a bit vector, where the </span><span style="font-style: italic; color: rgb(51, 51, 51);">n</span><span style="color: rgb(51, 51, 51);">th bit in the index indicates the presence or absence of the </span><span style="font-style: italic; color: rgb(51, 51, 51);">n</span><span style="color: rgb(51, 51, 51);">th element from the source set. In essence, there is a natural mapping between the binary numbers from 0 to 2</span><span style="font-style: italic; vertical-align: super; color: rgb(102, 102, 102);">n</span> − 1 and the power set of an <span style="font-style: italic;">n</span>-element set. Here’s the code:</div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/218pro01.jpg" width="534.6266642676459"></img></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Note that PowerSet.of throws an exception if the input set has more than 30 elements. This highlights a disadvantage of using Collection as a return type rather than Stream or Iterable: Collection has an int-returning size method, which limits the length of the returned sequence to Integer.MAX_VALUE, or 2</span><span style="vertical-align: super; color: rgb(102, 102, 102);">31</span><span style="color: rgb(51, 51, 51);"> − 1. The Collection specification does allow the size method to return 2</span><span style="vertical-align: super; color: rgb(102, 102, 102);">31</span><span style="color: rgb(51, 51, 51);"> − 1 if the collection is larger, even infinite, but this is not a wholly satisfying solution.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">In order to write a Collection implementation atop AbstractCollection, you need implement only two methods beyond the one required for Iterable: contains and size. Often it’s easy to write efficient implementations of these methods. If it isn’t feasible, perhaps because the contents of the sequence aren’t predetermined before iteration takes place, return a stream or iterable, whichever feels more natural. If you choose, you can return both using two separate methods.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">In summary, when writing a method that returns a sequence of elements, remember that some of your users may want to process them as a stream while others may want to iterate over them. Try to accommodate both groups. If it’s feasible to return a collection, do so. If you already have the elements in a collection or the number of elements in the sequence is small enough to justify creating a new one, return a standard collection such as ArrayList. Otherwise, consider implementing a custom collection as we did for the power set. If it isn’t feasible to return a collection, return a stream or iterable, whichever seems more natural. If, in a future Java release, the Stream interface declaration is modified to extend Iterable, then you should feel free to return streams because they will allow for both stream processing and iteration.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">USE CAUTION WHEN MAKING STREAMS PARALLEL</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">Among mainstream languages, Java has always been at the forefront of providing facilities to ease the task of concurrent programming. When Java was released in 1996, it had built-in support for threads, with synchronization and wait/notify. Java 5 introduced the java.util.concurrent library, with concurrent collections and the executor framework. Java 7 introduced the fork-join package, a high-performance framework for parallel decomposition. Java 8 introduced streams, which can be parallelized with a single call to the parallel method. Writing concurrent programs in Java keeps getting easier, but writing concurrent programs that are correct and fast is as difficult as it ever was. Safety and liveness violations are a fact of life in concurrent programming, and parallel stream pipelines are no exception.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Simply put, the streams library has no idea how to parallelize this pipeline and the heuristics fail. Even under the best of circumstances, </span><span style="font-weight: bold; color: rgb(51, 51, 51);">parallelizing a pipeline is unlikely to increase its performance if the source is from</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Stream.iterate, or the intermediate operation</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">limit</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">is used.</span><span style="color: rgb(51, 51, 51);"> This pipeline has to contend with </span><span style="font-style: italic; color: rgb(51, 51, 51);">both</span><span style="color: rgb(51, 51, 51);"> of these issues. Worse, the default parallelization strategy deals with the unpredictability of limit by assuming there’s no harm in processing a few extra elements and discarding any unneeded results. In this case, it takes roughly twice as long to find each Mersenne prime as it did to find the previous one. Thus, the cost of computing a single extra element is roughly equal to the cost of computing all previous elements combined, and this innocuous-looking pipeline brings the automatic parallelization algorithm to its knees. The moral of this story is simple: </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Do not parallelize stream pipelines indiscriminately.</span><span style="color: rgb(51, 51, 51);"> The performance consequences may be disastrous.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">As a rule, </span><span style="font-weight: bold; color: rgb(51, 51, 51);">performance gains from parallelism are best on streams over</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">ArrayList,</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">HashMap,</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">HashSet, and</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">ConcurrentHashMap</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">instances; arrays;</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">int</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">ranges; and</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">long</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">ranges.</span><span style="color: rgb(51, 51, 51);"> What these data structures have in common is that they can all be accurately and cheaply split into subranges of any desired sizes, which makes it easy to divide work among parallel threads. The abstraction used by the streams library to perform this task is the </span><span style="font-style: italic; color: rgb(51, 51, 51);">spliterator</span><span style="color: rgb(51, 51, 51);">, which is returned by the spliterator method on Stream and Iterable.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Another important factor that all of these data structures have in common is that they provide good-to-excellent </span><span style="font-style: italic; color: rgb(51, 51, 51);">locality of reference</span><span style="color: rgb(51, 51, 51);"> when processed sequentially: sequential element references are stored together in memory. The objects referred to by those references may not be close to one another in memory, which reduces locality-of-reference. Locality-of-reference turns out to be critically important for parallelizing bulk operations: without it, threads spend much of their time idle, waiting for data to be transferred from memory into the processor’s cache. The data structures with the best locality of reference are primitive arrays because the data itself is stored contiguously in memory.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">CHECK PARAMETERS FOR VALIDITY</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">Most methods and constructors have some restrictions on what values may be passed into their parameters. For example, it is not uncommon that index values must be non-negative and object references must be non-null. You should clearly document all such restrictions and enforce them with checks at the beginning of the method body. This is a special case of the general principle that you should attempt to detect errors as soon as possible after they occur. Failing to do so makes it less likely that an error will be detected and makes it harder to determine the source of an error once it has been detected.</span></div><div><br/></div><div><span style="font-weight: bold; color: rgb(51, 51, 51);">The</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Objects.requireNonNull</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">method, added in Java 7, is flexible and convenient, so there’s no reason to perform null checks manually anymore.</span><span style="color: rgb(51, 51, 51);"> You can specify your own exception detail message if you wish. You can also ignore the return value and use Objects.requireNonNull as a freestanding null check where that suits your needs.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">To summarize, each time you write a method or constructor, you should think about what restrictions exist on its parameters. You should document these restrictions and enforce them with explicit checks at the beginning of the method body. It is important to get into the habit of doing this. The modest work that it entails will be paid back with interest the first time a validity check fails.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">MAKE DEFENSIVE COPIES WHEN NEEDED</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">Even in a safe language, you aren’t insulated from other classes without some effort on your part. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">You must program defensively, with the assumption that clients of your class will do their best to destroy its invariants.</span><span style="color: rgb(51, 51, 51);"> This is increasingly true as people try harder to break the security of systems, but more commonly, your class will have to cope with unexpected behavior resulting from the honest mistakes of well-intentioned programmers. Either way, it is worth taking the time to write classes that are robust in the face of ill-behaved clients  </span><span style="font-weight: bold; color: rgb(51, 51, 51);">It is essential to make a</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; font-style: italic; color: rgb(51, 51, 51);">defensive copy</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">of each mutable parameter to the constructor</span><span style="color: rgb(51, 51, 51);"> and to use the copies as components of the Period instance in place of the originals.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Note that </span><span style="font-weight: bold; color: rgb(51, 51, 51);">defensive copies are made</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; font-style: italic; color: rgb(51, 51, 51);">before</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">checking the validity of the parameters (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch8.xhtml#lev49" style="font-weight: bold; color: rgb(7, 7, 7);">Item 49</a><span style="font-weight: bold;">), and the validity check is performed on the copies rather than on the originals.</span><span style="color: rgb(51, 51, 51);"> While this may seem unnatural, it is necessary. It protects the class against changes to the parameters from another thread during the </span><span style="font-style: italic; color: rgb(51, 51, 51);">window of vulnerability</span><span style="color: rgb(51, 51, 51);"> between the time the parameters are checked and the time they are copied. In the computer security community, this is known as a </span><span style="font-style: italic; color: rgb(51, 51, 51);">time-of-check/time-of-use</span><span style="color: rgb(51, 51, 51);"> or </span><span style="font-style: italic; color: rgb(51, 51, 51);">TOCTOU</span><span style="color: rgb(51, 51, 51);"> attack [</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ref.xhtml#rViega01" style="color: rgb(7, 7, 7);">Viega01</a><span style="color: rgb(51, 51, 51);">].</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Note also that we did not use Date’s clone method to make the defensive copies. Because Date is nonfinal, the clone method is not guaranteed to return an object whose class is java.util.Date: it could return an instance of an untrusted subclass that is specifically designed for malicious mischief. Such a subclass could, for example, record a reference to each instance in a private static list at the time of its creation and allow the attacker to access this list. This would give the attacker free rein over all instances. To prevent this sort of attack, </span><span style="font-weight: bold; color: rgb(51, 51, 51);">do not use the</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">clone</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">method to make a defensive copy of a parameter whose type is subclassable by untrusted parties.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">While the replacement constructor successfully defends against the previous attack, it is still possible to mutate a Period instance, because its accessors offer access to its mutable internals. To defend against the second attack, merely modify the accessors to </span><span style="font-weight: bold; color: rgb(51, 51, 51);">return defensive copies of mutable internal fields.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Whether or not your class is immutable, you should think twice before returning a reference to an internal component that is mutable. Chances are, you should return a defensive copy. Remember that nonzero-length arrays are always mutable. Therefore, you should always make a defensive copy of an internal array before returning it to a client. Alternatively, you could return an immutable view of the array.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Arguably, the real lesson in all of this is that you should, where possible, use immutable objects as components of your objects so that you that don’t have to worry about defensive copying (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch4.xhtml#lev17" style="color: rgb(7, 7, 7);">Item 17</a><span style="color: rgb(51, 51, 51);">). In the case of our Period example, use Instant (or LocalDateTime or ZonedDateTime), unless you’re using a release prior to Java 8. </span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">There may be a performance penalty associated with defensive copying and it isn’t always justified. If a class trusts its caller not to modify an internal component, perhaps because the class and its client are both part of the same package, then it may be appropriate to dispense with defensive copying. Under these circumstances, the class documentation should make it clear that the caller must not modify the affected parameters or return values.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">In summary, if a class has mutable components that it gets from or returns to its clients, the class must defensively copy these components. If the cost of the copy would be prohibitive </span><span style="font-style: italic; color: rgb(51, 51, 51);">and</span><span style="color: rgb(51, 51, 51);"> the class trusts its clients not to modify the components inappropriately, then the defensive copy may be replaced by documentation outlining the client’s responsibility not to modify the affected components.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">DESIGN METHOD SIGNATURES CAREFULLY</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">This item is a grab bag of API design hints that don’t quite deserve items of their own. Taken together, they’ll help make your API easier to learn and use and less prone to errors.</span></div><div><br/></div><div><span style="font-weight: bold; color: rgb(51, 51, 51);">Choose method names carefully.</span><span style="color: rgb(51, 51, 51);"> Names should always obey the standard naming conventions.</span></div><div><span style="font-weight: bold; color: rgb(51, 51, 51);">Don’t go overboard in providing convenience methods.</span><span style="color: rgb(51, 51, 51);"> Every method should “pull its weight.” Too many methods make a class difficult to learn, use, document, test, and maintain.</span></div><div><span style="font-weight: bold; color: rgb(51, 51, 51);">Avoid long parameter lists.</span><span style="color: rgb(51, 51, 51);"> Aim for four parameters or fewer. </span></div><div><span style="font-weight: bold; color: rgb(51, 51, 51);">For parameter types, favor interfaces over classes</span><span style="color: rgb(51, 51, 51);"> (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch9.xhtml#lev64" style="color: rgb(7, 7, 7);">Item 64</a><span style="color: rgb(51, 51, 51);">). If there is an appropriate interface to define a parameter, use it in favor of a class that implements the interface.</span><span style="font-weight: bold; color: rgb(51, 51, 51);">Prefer two-element enum types to</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">boolean</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">parameters,</span><span style="color: rgb(51, 51, 51);"> unless the meaning of the boolean is clear from the method name. Enums make your code easier to read and to write. </span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">USE OVERLOADING JUDICIOUSLY</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">As a reminder, a method is overridden when a subclass contains a method declaration with the same signature as a method declaration in an ancestor. If an instance method is overridden in a subclass and this method is invoked on an instance of the subclass, the subclass’s </span><span style="font-style: italic; color: rgb(51, 51, 51);">overriding method</span><span style="color: rgb(51, 51, 51);"> executes, regardless of the compile-time type of the subclass instance. </span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The compile-time type of an object has no effect on which method is executed when an overridden method is invoked; the “most specific” overriding method always gets executed. Compare this to overloading, where the runtime type of an object has no effect on which overloading is executed; the selection is made at compile time, based entirely on the compile-time types of the parameters.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Because overriding is the norm and overloading is the exception, overriding sets people’s expectations for the behavior of method invocation. This is especially true for APIs. If the typical user of an API does not know which of several method overloadings will get invoked for a given set of parameters, use of the API is likely to result in errors. These errors will likely manifest themselves as erratic behavior at runtime, and many programmers will have a hard time diagnosing them. Therefore you should </span><span style="font-weight: bold; color: rgb(51, 51, 51);">avoid confusing uses of overloading.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Exactly what constitutes a confusing use of overloading is open to some debate. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">A safe, conservative policy is never to export two overloadings with the same number of parameters.</span><span style="color: rgb(51, 51, 51);"> If a method uses varargs, a conservative policy is not to overload it at all. If you adhere to these restrictions, programmers will never be in doubt as to which overloading applies to any set of actual parameters. These restrictions are not terribly onerous because </span><span style="font-weight: bold; color: rgb(51, 51, 51);">you can always give methods different names instead of overloading them.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">USE VARARGS JUDICIOUSLY</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">Exercise care when using varargs in performance-critical situations. Every invocation of a varargs method causes an array allocation and initialization. If you have determined empirically that you can’t afford this cost but you need the flexibility of varargs, there is a pattern that lets you have your cake and eat it too. Suppose you’ve determined that 95 percent of the calls to a method have three or fewer parameters. Then declare five overloadings of the method, one each with zero through three ordinary parameters, and a single varargs method for use when the number of arguments exceeds three.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">In summary, varargs are invaluable when you need to define methods with a variable number of arguments. Precede the varargs parameter with any required parameters, and be aware of the performance consequences of using varargs.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">RETURN EMPTY COLLECTIONS OR ARRAYS, NOT NULLS</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">Never return null instead of a zero-length array. Normally, you should simply return an array of the correct length, which may be zero. </span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">RETURN OPTIONALS JUDICIOUSLY</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">The Optional&lt;T&gt; class represents an immutable container that can hold either a single non-null T reference or nothing at all. An optional that contains nothing is said to be </span><span style="font-style: italic; color: rgb(51, 51, 51);">empty</span><span style="color: rgb(51, 51, 51);">. A value is said to be </span><span style="font-style: italic; color: rgb(51, 51, 51);">present</span><span style="color: rgb(51, 51, 51);"> in an optional that is not empty. An optional is essentially an immutable collection that can hold at most one element. Optional&lt;T&gt; does not implement Collection&lt;T&gt;, but it could in principle.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">A method that conceptually returns a T but may be unable to do so under certain circumstances can instead be declared to return an Optional&lt;T&gt;. This allows the method to return an empty result to indicate that it couldn’t return a valid result. An Optional-returning method is more flexible and easier to use than one that throws an exception, and it is less error-prone than one that returns null.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">It is a programming error to pass null to Optional.of(value). If you do this, the method responds by throwing a NullPointerException. The Optional.ofNullable(value) method accepts a possibly null value and returns an empty optional if null is passed in. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Never return a null value from an</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Optional-returning method:</span><span style="color: rgb(51, 51, 51);"> it defeats the entire purpose of the facility.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">If a method returns an optional, the client gets to choose what action to take if the method can’t return a value. You can specify a default value:</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/251pro01.jpg" width="507.902774810791"></img></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">or you can throw any exception that is appropriate. Note that we pass in an exception factory rather than an actual exception. This avoids the expense of creating the exception unless it will actually be thrown:</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/251pro02.jpg" width="548.902774810791"></img></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">In case none of these methods meets your needs, Optional provides the isPresent() method, which may be viewed as a safety valve. It returns true if the optional contains a value, false if it’s empty. You can use this method to perform any processing you like on an optional result, but make sure to use it wisely. Many uses of isPresent can profitably be replaced by one of the methods mentioned above. The resulting code will typically be shorter, clearer, and more idiomatic.</span></div><div><span style="color: rgb(51, 51, 51);">For example, consider this code snippet, which prints the process ID of the parent of a process, or N/A if the process has no parent. The snippet uses the ProcessHandle class, introduced in Java 9:</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/252pro02.jpg" width="560.902774810791"></img></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">When programming with streams, it is not uncommon to find yourself with a Stream&lt;Optional&lt;T&gt;&gt; and to require a Stream&lt;T&gt; containing all the elements in the nonempty optionals in order to proceed. If you’re using Java 8, here’s how to bridge the gap:</span></div><div><br/></div><div><img src="effective java_files/Image [21].jpg" type="image/jpeg" data-filename="Image.jpg" alt="Image" width="271.902774810791"/></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">As a rule, </span><span style="font-weight: bold; color: rgb(51, 51, 51);">you should declare a method to return</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Optional&lt;T&gt;</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">if it might not be able to return a result</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; font-style: italic; color: rgb(51, 51, 51);">and</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">clients will have to perform special processing if no result is returned.</span><span style="color: rgb(51, 51, 51);"> That said, returning an Optional&lt;T&gt; is not without cost. An Optional is an object that has to be allocated and initialized, and reading the value out of the optional requires an extra indirection. This makes optionals inappropriate for use in some performance-critical situations. </span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Returning an optional that contains a boxed primitive type is prohibitively expensive compared to returning a primitive type because the optional has two levels of boxing instead of zero. Therefore, the library designers saw fit to provide analogues of Optional&lt;T&gt; for the primitive types int, long, and double. These optional types are OptionalInt, OptionalLong, and OptionalDouble. They contain most, but not all, of the methods on Optional&lt;T&gt;. Therefore, </span><span style="font-weight: bold; color: rgb(51, 51, 51);">you should never return an optional of a boxed primitive type,</span><span style="color: rgb(51, 51, 51);"> with the possible exception of the “minor primitive types,” Boolean, Byte, Character, Short, and Float.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">More generally, </span><span style="font-weight: bold; color: rgb(51, 51, 51);">it is almost never appropriate to use an optional as a key, value, or element in a collection or array.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">WRITE DOC COMMENTS FOR ALL EXPOSED API ELEMENTS</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">While the doc comment conventions are not officially part of the language, they constitute a de facto API that every Java programmer should know. These conventions are described in the </span><span style="font-style: italic; color: rgb(51, 51, 51);">How to Write Doc Comments</span><span style="color: rgb(51, 51, 51);"> web page [Javadoc-guide]. While this page has not been updated since Java 4 was released, it is still an invaluable resource. One important doc tag was added in Java 9, {@index}; one in Java 8, {@implSpec}; and two in Java 5, {@literal} and {@code}. These tags are missing from the aforementioned web page, but are discussed in this item.</span></div><div><br/></div><div><span style="font-weight: bold; color: rgb(51, 51, 51);">The doc comment for a method should describe succinctly the contract between the method and its client.</span><span style="color: rgb(51, 51, 51);"> With the exception of methods in classes designed for inheritance (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch4.xhtml#lev19" style="color: rgb(7, 7, 7);">Item 19</a><span style="color: rgb(51, 51, 51);">), the contract should say </span><span style="font-style: italic; color: rgb(51, 51, 51);">what</span><span style="color: rgb(51, 51, 51);"> the method does rather than </span><span style="font-style: italic; color: rgb(51, 51, 51);">how</span><span style="color: rgb(51, 51, 51);"> it does its job. The doc comment should enumerate all of the method’s </span><span style="font-style: italic; color: rgb(51, 51, 51);">preconditions</span><span style="color: rgb(51, 51, 51);">, which are the things that have to be true in order for a client to invoke it, and its </span><span style="font-style: italic; color: rgb(51, 51, 51);">postconditions</span><span style="color: rgb(51, 51, 51);">, which are the things that will be true after the invocation has completed successfully. Typically, preconditions are described implicitly by the @throws tags for unchecked exceptions; each unchecked exception corresponds to a precondition violation. Also, preconditions can be specified along with the affected parameters in their @param tags.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">USE EXCEPTIONS ONLY FOR EXCEPTIONAL CONDITIONS</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-weight: bold; color: rgb(51, 51, 51);">Exceptions are, as their name implies, to be used only for exceptional conditions; they should never be used for ordinary control flow.</span><span style="color: rgb(51, 51, 51);"> More generally, use standard, easily recognizable idioms in preference to overly clever techniques that purport to offer better performance. Even if the performance advantage is real, it may not remain in the face of steadily improving platform implementations. The subtle bugs and maintenance headaches that come from overly clever techniques, however, are sure to remain.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">This principle also has implications for API design. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">A well-designed API must not force its clients to use exceptions for ordinary control flow.</span><span style="color: rgb(51, 51, 51);"> A class with a “state-dependent” method that can be invoked only under certain unpredictable conditions should generally have a separate “state-testing” method indicating whether it is appropriate to invoke the state-dependent method. For example, the Iterator interface has the state-dependent method next and the corresponding state-testing method hasNext. This enables the standard idiom for iterating over a collection with a traditional for loop (as well as the for-each loop, where the hasNext method is used internally).</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">USE CHECKED EXCEPTIONS FOR RECOVERABLE CONDITIONS AND RUNTIME EXCEPTIONS FOR PROGRAMMING ERRORS</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">The cardinal rule in deciding whether to use a checked or an unchecked exception is this: </span><span style="font-weight: bold; color: rgb(51, 51, 51);">use checked exceptions for conditions from which the caller can reasonably be expected to recover.</span><span style="color: rgb(51, 51, 51);"> By throwing a checked exception, you force the caller to handle the exception in a catch clause or to propagate it outward. Each checked exception that a method is declared to throw is therefore a potent indication to the API user that the associated condition is a possible outcome of invoking the method.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">There are two kinds of unchecked throwables: runtime exceptions and errors. They are identical in their behavior: both are throwables that needn’t, and generally shouldn’t, be caught. If a program throws an unchecked exception or an error, it is generally the case that recovery is impossible and continued execution would do more harm than good. If a program does not catch such a throwable, it will cause the current thread to halt with an appropriate error message.</span></div><div><br/></div><div><span style="font-weight: bold; color: rgb(51, 51, 51);">Use runtime exceptions to indicate programming errors.</span><span style="color: rgb(51, 51, 51);"> The great majority of runtime exceptions indicate </span><span style="font-style: italic; color: rgb(51, 51, 51);">precondition violations</span><span style="color: rgb(51, 51, 51);">. A precondition violation is simply a failure by the client of an API to adhere to the contract established by the API specification. For example, the contract for array access specifies that the array index must be between zero and the array length minus one, inclusive. ArrayIndexOutOfBoundsException indicates that this precondition was violated.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">While the Java Language Specification does not require it, there is a strong convention that </span><span style="font-style: italic; color: rgb(51, 51, 51);">errors</span><span style="color: rgb(51, 51, 51);"> are reserved for use by the JVM to indicate resource deficiencies, invariant failures, or other conditions that make it impossible to continue execution. Given the almost universal acceptance of this convention, it’s best not to implement any new Error subclasses. Therefore, </span><span style="font-weight: bold; color: rgb(51, 51, 51);">all of the unchecked throwables you implement should subclass</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">RuntimeException</span><span style="color: rgb(51, 51, 51);"> (directly or indirectly). Not only shouldn’t you define Error subclasses, but with the exception of AssertionError, you shouldn’t throw them either.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">AVOID UNNECESSARY USE OF CHECKED EXCEPTIONS</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">Many Java programmers dislike checked exceptions, but used properly, they can improve APIs and programs. Unlike return codes and unchecked exceptions, they </span><span style="font-style: italic; color: rgb(51, 51, 51);">force</span><span style="color: rgb(51, 51, 51);"> programmers to deal with problems, enhancing reliability. That said, overuse of checked exceptions in APIs can make them far less pleasant to use. If a method throws checked exceptions, the code that invokes it must handle them in one or more catch blocks, or declare that it throws them and let them propagate outward. Either way, it places a burden on the user of the API. The burden increased in Java 8, as methods throwing checked exceptions can’t be used directly in streams (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch7.xhtml#lev45" style="color: rgb(7, 7, 7);">Items 45</a><span style="color: rgb(51, 51, 51);">–</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch7.xhtml#lev48" style="color: rgb(7, 7, 7);">48</a><span style="color: rgb(51, 51, 51);">).</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The additional burden on the programmer caused by a checked exception is substantially higher if it is the </span><span style="font-style: italic; color: rgb(51, 51, 51);">sole</span><span style="color: rgb(51, 51, 51);"> checked exception thrown by a method. If there are others, the method must already appear in a try block, and this exception requires, at most, another catch block. If a method throws a single checked exception, this exception is the sole reason the method must appear in a try block and can’t be used directly in streams. Under these circumstances, it pays to ask yourself if there is a way to avoid the checked exception.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The easiest way to eliminate a checked exception is to return an </span><span style="font-style: italic; color: rgb(51, 51, 51);">optional</span><span style="color: rgb(51, 51, 51);"> of the desired result type (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch8.xhtml#lev55" style="color: rgb(7, 7, 7);">Item 55</a><span style="color: rgb(51, 51, 51);">). Instead of throwing a checked exception, the method simply returns an empty optional. The disadvantage of this technique is that the method can’t return any additional information detailing its inability to perform the desired computation. Exceptions, by contrast, have descriptive types, and can export methods to provide additional information (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch10.xhtml#lev70" style="color: rgb(7, 7, 7);">Item 70</a><span style="color: rgb(51, 51, 51);">).</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">In summary, when used sparingly, checked exceptions can increase the reliability of programs; when overused, they make APIs painful to use. If callers won’t be able to recover from failures, throw unchecked exceptions. If recovery may be possible and you want to </span><span style="font-style: italic; color: rgb(51, 51, 51);">force</span><span style="color: rgb(51, 51, 51);"> callers to handle exceptional conditions, first consider returning an optional. Only if this would provide insufficient information in the case of failure should you throw a checked exception.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">FAVOR THE USE OF STANDARD EXCEPTIONS</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">An attribute that distinguishes expert programmers from less experienced ones is that experts strive for and usually achieve a high degree of code reuse. Exceptions are no exception to the rule that code reuse is a good thing. The Java libraries provide a set of exceptions that covers most of the exception-throwing needs of most APIs.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Reusing standard exceptions has several benefits. Chief among them is that it makes your API easier to learn and use because it matches the established conventions that programmers are already familiar with. A close second is that programs using your API are easier to read because they aren’t cluttered with unfamiliar exceptions. Last (and least), fewer exception classes means a smaller memory footprint and less time spent loading classes.</span></div><div><br/></div><div><span style="font-weight: bold; color: rgb(51, 51, 51);">Do</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; font-style: italic; color: rgb(51, 51, 51);">not</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">reuse</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Exception,</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">RuntimeException,</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Throwable, or</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Error</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">directly.</span><span style="color: rgb(51, 51, 51);"> Treat these classes as if they were abstract. You can't reliably test for these exceptions because they are superclasses of other exceptions that a method may throw.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">This table summarizes the most commonly reused exceptions:</span></div><div><img src="effective java_files/exceptions.png" type="image/png" data-filename="exceptions.png" width="559.2333270109726px"/></div><div><br/></div><div><br/></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">THROW EXCEPTIONS APPROPRIATE TO THE ABSTRACTION</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">It is disconcerting when a method throws an exception that has no apparent connection to the task that it performs. This often happens when a method propagates an exception thrown by a lower-level abstraction. Not only is it disconcerting, but it pollutes the API of the higher layer with implementation details. If the implementation of the higher layer changes in a later release, the exceptions it throws will change too, potentially breaking existing client programs.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">To avoid this problem, </span><span style="font-weight: bold; color: rgb(51, 51, 51);">higher layers should catch lower-level exceptions and, in their place, throw exceptions that can be explained in terms of the higher-level abstraction.</span><span style="color: rgb(51, 51, 51);"> This idiom is known as </span><span style="font-style: italic; color: rgb(51, 51, 51);">exception translation.</span> <span style="color: rgb(51, 51, 51);">Here is an example of exception translation taken from the AbstractSequentialList class, which is a </span><span style="font-style: italic; color: rgb(51, 51, 51);">skeletal implementation</span><span style="color: rgb(51, 51, 51);"> (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch4.xhtml#lev20" style="color: rgb(7, 7, 7);">Item 20</a><span style="color: rgb(51, 51, 51);">) of the List interface. In this example, exception translation is mandated by the specification of the get method in the List&lt;E&gt; interface:</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/302pro02.jpg" width="500.902774810791"></img></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">A special form of exception translation called </span><span style="font-style: italic; color: rgb(51, 51, 51);">exception chaining</span><span style="color: rgb(51, 51, 51);"> is called for in cases where the lower-level exception might be helpful to someone debugging the problem that caused the higher-level exception. The lower-level exception (the </span><span style="font-style: italic; color: rgb(51, 51, 51);">cause</span><span style="color: rgb(51, 51, 51);">) is passed to the higher-level exception, which provides an accessor method (Throwable’s getCause method) to retrieve the lower-level exception:</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/303pro01.jpg" width="490.902774810791"></img></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The higher-level exception’s constructor passes the cause to a </span><span style="font-style: italic; color: rgb(51, 51, 51);">chaining-aware</span><span style="color: rgb(51, 51, 51);"> superclass constructor, so it is ultimately passed to one of Throwable’s chaining-aware constructors, such as Throwable(Throwable).</span></div><div><br/></div><div><span style="font-weight: bold; color: rgb(51, 51, 51);">While exception translation is superior to mindless propagation of exceptions from lower layers, it should not be overused.</span><span style="color: rgb(51, 51, 51);"> Where possible, the best way to deal with exceptions from lower layers is to avoid them, by ensuring that lower-level methods succeed. Sometimes you can do this by checking the validity of the higher-level method’s parameters before passing them on to lower layers.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">In summary, if it isn’t feasible to prevent or to handle exceptions from lower layers, use exception translation, unless the lower-level method happens to guarantee that all of its exceptions are appropriate to the higher level. Chaining provides the best of both worlds: it allows you to throw an appropriate higher-level exception, while capturing the underlying cause for failure analysis (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch10.xhtml#lev75" style="color: rgb(7, 7, 7);">Item 75</a><span style="color: rgb(51, 51, 51);">).</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">DOCUMENT ALL EXCEPTIONS THROWN BY EACH METHOD</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-weight: bold; color: rgb(51, 51, 51);">Always declare checked exceptions individually, and document precisely the conditions under which each one is thrown</span><span style="color: rgb(51, 51, 51);"> using the Javadoc @throws tag. Don’t take the shortcut of declaring that a method throws some superclass of multiple exception classes that it can throw. As an extreme example, don’t declare that a public method throws Exception or, worse, throws Throwable. In addition to denying any guidance to the method’s user concerning the exceptions it is capable of throwing, such a declaration greatly hinders the use of the method because it effectively obscures any other exception that may be thrown in the same context. One exception to this advice is the main method, which can safely be declared to throw Exception because it is called only by VM.</span></div><div><br/></div><div><span style="font-weight: bold; color: rgb(51, 51, 51);">Use the Javadoc</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">@throws</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">tag to document each exception that a method can throw, but do</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; font-style: italic; color: rgb(51, 51, 51);">not</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">use the</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">throws</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">keyword on unchecked exceptions.</span><span style="color: rgb(51, 51, 51);"> It is important that programmers using your API are aware of which exceptions are checked and which are unchecked because the programmers’ responsibilities differ in these two cases. The documentation generated by the Javadoc @throws tag without a corresponding throws clause in the method declaration provides a strong visual cue to the programmer that an exception is unchecked.</span></div><div><br/></div><div><span style="font-weight: bold; color: rgb(51, 51, 51);">If an exception is thrown by many methods in a class for the same reason, you can document the exception in the class’s documentation comment</span><span style="color: rgb(51, 51, 51);"> rather than documenting it individually for each method. A common example is NullPointerException. It is fine for a class’s documentation comment to say, “All methods in this class throw a NullPointerException if a null object reference is passed in any parameter,” or words to that effect.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">INCLUDE FAILURE-CAPTURE INFORMATION IN DETAIL MESSAGES</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-weight: bold; color: rgb(51, 51, 51);">To capture a failure, the detail message of an exception should contain the values of all parameters and fields that contributed to the exception.</span><span style="color: rgb(51, 51, 51);"> For example, the detail message of an IndexOutOfBoundsException should contain the lower bound, the upper bound, and the index value that failed to lie between the bounds. This information tells a lot about the failure. Any or all of the three values could be wrong. The index could be one less than the lower bound or equal to the upper bound (a “fencepost error”), or it could be a wild value, far too low or high. The lower bound could be greater than the upper bound (a serious internal invariant failure). Each of these situations points to a different problem, and it greatly aids in the diagnosis if you know what sort of error you’re looking for.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">One caveat concerns security-sensitive information. Because stack traces may be seen by many people in the process of diagnosing and fixing software issues, </span><span style="font-weight: bold; color: rgb(51, 51, 51);">do not include passwords, encryption keys, and the like in detail messages.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">While it is critical to include all of the pertinent data in the detail message of an exception, it is generally unimportant to include a lot of prose. The stack trace is intended to be analyzed in conjunction with the documentation and, if necessary, source code. It generally contains the exact file and line number from which the exception was thrown, as well as the files and line numbers of all other method invocations on the stack. Lengthy prose descriptions of the failure are superfluous; the information can be gleaned by reading the documentation and source code.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">STRIVE FOR FAILURE ATOMICITY</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">After an object throws an exception, it is generally desirable that the object still be in a well-defined, usable state, even if the failure occurred in the midst of performing an operation. This is especially true for checked exceptions, from which the caller is expected to recover. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Generally speaking, a failed method invocation should leave the object in the state that it was in prior to the invocation</span><span style="color: rgb(51, 51, 51);">. A method with this property is said to be </span><span style="font-style: italic; color: rgb(51, 51, 51);">failure-atomic.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">There are several ways to achieve this effect. The simplest is to design immutable objects (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch4.xhtml#lev17" style="color: rgb(7, 7, 7);">Item 17</a><span style="color: rgb(51, 51, 51);">). If an object is immutable, failure atomicity is free. If an operation fails, it may prevent a new object from getting created, but it will never leave an existing object in an inconsistent state, because the state of each object is consistent when it is created and can’t be modified thereafter.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">A closely related approach to achieving failure atomicity is to order the computation so that any part that may fail takes place before any part that modifies the object. This approach is a natural extension of the previous one when arguments cannot be checked without performing a part of the computation.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">A third approach to achieving failure atomicity is to perform the operation on a temporary copy of the object and to replace the contents of the object with the temporary copy once the operation is complete. This approach occurs naturally when the computation can be performed more quickly once the data has been stored in a temporary data structure. For example, some sorting functions copy their input list into an array prior to sorting to reduce the cost of accessing elements in the inner loop of the sort. This is done for performance, but as an added benefit, it ensures that the input list will be untouched if the sort fails.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">A last and far less common approach to achieving failure atomicity is to write </span><span style="font-style: italic; color: rgb(51, 51, 51);">recovery code</span><span style="color: rgb(51, 51, 51);"> that intercepts a failure that occurs in the midst of an operation, and causes the object to roll back its state to the point before the operation began. This approach is used mainly for durable (disk-based) data structures.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">DON’T IGNORE EXCEPTIONS</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-weight: bold; color: rgb(51, 51, 51);">An empty</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">catch</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">block defeats the purpose of exceptions,</span><span style="color: rgb(51, 51, 51);"> which is to force you to handle exceptional conditions. Ignoring an exception is analogous to ignoring a fire alarm—and turning it off so no one else gets a chance to see if there’s a real fire. You may get away with it, or the results may be disastrous. Whenever you see an empty catch block, alarm bells should go off in your head.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">There are situations where it is appropriate to ignore an exception. For example, it might be appropriate when closing a FileInputStream. You haven’t changed the state of the file, so there’s no need to perform any recovery action, and you’ve already read the information that you need from the file, so there’s no reason to abort the operation in progress. It may be wise to log the exception, so that you can investigate the matter if these exceptions happen often. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">If you choose to ignore an exception, the</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">catch</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">block should contain a comment explaining why it is appropriate to do so, and the variable should be named</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">ignored.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">SYNCHRONIZE ACCESS TO SHARED MUTABLE DATA</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">You may hear it said that to improve performance, you should dispense with synchronization when reading or writing atomic data. This advice is dangerously wrong. While the language specification guarantees that a thread will not see an arbitrary value when reading a field, it does not guarantee that a value written by one thread will be visible to another. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Synchronization is required for reliable communication between threads as well as for mutual exclusion.</span><span style="color: rgb(51, 51, 51);"> This is due to a part of the language specification known as the </span><span style="font-style: italic; color: rgb(51, 51, 51);">memory model</span><span style="color: rgb(51, 51, 51);">, which specifies when and how changes made by one thread become visible to others [JLS, 17.4; Goetz06, 16].</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The consequences of failing to synchronize access to shared mutable data can be dire even if the data is atomically readable and writable. Consider the task of stopping one thread from another. The libraries provide the Thread.stop method, but this method was deprecated long ago because it is inherently </span><span style="font-style: italic; color: rgb(51, 51, 51);">unsafe</span><span style="color: rgb(51, 51, 51);">—its use can result in data corruption. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Do not use</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Thread.stop.</span><span style="color: rgb(51, 51, 51);"> A recommended way to stop one thread from another is to have the first thread poll a boolean field that is initially false but can be set to true by the second thread to indicate that the first thread is to stop itself. Because reading and writing a boolean field is atomic, some programmers dispense with synchronization when accessing the field:</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/312pro01.jpg" width="518.902774810791"></img></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">You might expect this program to run for about a second, after which the main thread sets stopRequested to true, causing the background thread’s loop to terminate. On my machine, however, the program </span><span style="font-style: italic; color: rgb(51, 51, 51);">never</span><span style="color: rgb(51, 51, 51);"> terminates: the background thread loops forever!</span></div><div><span style="color: rgb(51, 51, 51);">The problem is that in the absence of synchronization, there is no guarantee as to when, if ever, the background thread will see the change in the value of stopRequested made by the main thread. In the absence of synchronization, it’s quite acceptable for the virtual machine to transform this code:</span></div><div><br/></div><div><img src="effective java_files/image.png" type="image/png" data-filename="image.png" width="184.90277481079102px"/></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">into this code:</span></div><div><br/></div><div><img src="effective java_files/image [1].png" type="image/png" data-filename="image.png" width="149.90277481079102px"/></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">This optimization is known as </span><span style="font-style: italic; color: rgb(51, 51, 51);">hoisting</span><span style="color: rgb(51, 51, 51);">, and it is precisely what the OpenJDK Server VM does. The result is a </span><span style="font-style: italic; color: rgb(51, 51, 51);">liveness failure</span><span style="color: rgb(51, 51, 51);">: the program fails to make progress. One way to fix the problem is to synchronize access to the stopRequested field. This program terminates in about one second, as expected:</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/313pro03.jpg" width="469.902774810791"></img></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Note that both the write method (requestStop) and the read method (stop-Requested) are synchronized. It is </span><span style="font-style: italic; color: rgb(51, 51, 51);">not</span><span style="color: rgb(51, 51, 51);"> sufficient to synchronize only the write method! </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Synchronization is not guaranteed to work unless both read and write operations are synchronized.</span><span style="color: rgb(51, 51, 51);"> Occasionally a program that synchronizes only writes (or reads) may </span><span style="font-style: italic; color: rgb(51, 51, 51);">appear</span><span style="color: rgb(51, 51, 51);"> to work on some machines, but in this case, appearances are deceiving.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The actions of the synchronized methods in StopThread would be atomic even without synchronization. In other words, the synchronization on these methods is used </span><span style="font-style: italic; color: rgb(51, 51, 51);">solely</span><span style="color: rgb(51, 51, 51);"> for its communication effects, not for mutual exclusion. While the cost of synchronizing on each iteration of the loop is small, there is a correct alternative that is less verbose and whose performance is likely to be better. The locking in the second version of StopThread can be omitted if stopRequested is declared volatile. While the volatile modifier performs no mutual exclusion, it guarantees that any thread that reads the field will see the most recently written value:</span></div><div><br/></div><div><img src="effective java_files/Image [22].jpg" type="image/jpeg" data-filename="Image.jpg" alt="Image" width="476.902774810791"/></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">You do have to be careful when using volatile. Consider the following method, which is supposed to generate serial numbers:</span></div><div><br/></div><div><img src="effective java_files/Image [23].jpg" type="image/jpeg" data-filename="Image.jpg" alt="Image" width="441.902774810791"/></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The intent of the method is to guarantee that every invocation returns a unique value (so long as there are no more than 2</span><span style="vertical-align: super; color: rgb(102, 102, 102);">32</span><span style="color: rgb(51, 51, 51);"> invocations). The method’s state consists of a single atomically accessible field, nextSerialNumber, and all possible values of this field are legal. Therefore, no synchronization is necessary to protect its invariants. Still, the method won’t work properly without synchronization.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The problem is that the increment operator (++) is not atomic. It performs </span><span style="font-style: italic; color: rgb(51, 51, 51);">two</span><span style="color: rgb(51, 51, 51);"> operations on the nextSerialNumber field: first it reads the value, and then it writes back a new value, equal to the old value plus one. If a second thread reads the field between the time a thread reads the old value and writes back a new one, the second thread will see the same value as the first and return the same serial number. This is a </span><span style="font-style: italic; color: rgb(51, 51, 51);">safety failure</span><span style="color: rgb(51, 51, 51);">: the program computes the wrong results.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">One way to fix generateSerialNumber is to add the synchronized modifier to its declaration. This ensures that multiple invocations won’t be interleaved and that each invocation of the method will see the effects of all previous invocations. Once you’ve done that, you can and should remove the volatile modifier from nextSerialNumber. To bulletproof the method, use long instead of int, or throw an exception if nextSerialNumber is about to wrap.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Better still, follow the advice in </span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch9.xhtml#lev59" style="color: rgb(7, 7, 7);">Item 59</a><span style="color: rgb(51, 51, 51);"> and use the class AtomicLong, which is part of java.util.concurrent.atomic. This package provides primitives for lock-free, thread-safe programming on single variables. While volatile provides only the communication effects of synchronization, this package also provides atomicity</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The best way to avoid the problems discussed in this item is not to share mutable data. Either share immutable data (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch4.xhtml#lev17" style="color: rgb(7, 7, 7);">Item 17</a><span style="color: rgb(51, 51, 51);">) or don’t share at all. In other words, </span><span style="font-weight: bold; color: rgb(51, 51, 51);">confine mutable data to a single thread.</span><span style="color: rgb(51, 51, 51);"> If you adopt this policy, it is important to document it so that the policy is maintained as your program evolves. It is also important to have a deep understanding of the frameworks and libraries you’re using because they may introduce threads that you are unaware of.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">In summary, </span><span style="font-weight: bold; color: rgb(51, 51, 51);">when multiple threads share mutable data, each thread that reads or writes the data must perform synchronization.</span><span style="color: rgb(51, 51, 51);"> In the absence of synchronization, there is no guarantee that one thread’s changes will be visible to another thread. The penalties for failing to synchronize shared mutable data are liveness and safety failures. These failures are among the most difficult to debug. They can be intermittent and timing-dependent, and program behavior can vary radically from one VM to another. If you need only inter-thread communication, and not mutual exclusion, the volatile modifier is an acceptable form of synchronization, but it can be tricky to use correctly.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">AVOID EXCESSIVE SYNCHRONIZATION</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-weight: bold; color: rgb(51, 51, 51);">To avoid liveness and safety failures, never cede control to the client within a synchronized method or block.</span><span style="color: rgb(51, 51, 51);"> In other words, inside a synchronized region, do not invoke a method that is designed to be overridden, or one provided by a client in the form of a function object (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch4.xhtml#lev24" style="color: rgb(7, 7, 7);">Item 24</a><span style="color: rgb(51, 51, 51);">). From the perspective of the class with the synchronized region, such methods are </span><span style="font-style: italic; color: rgb(51, 51, 51);">alien</span><span style="color: rgb(51, 51, 51);">. The class has no knowledge of what the method does and has no control over it. Depending on what an alien method does, calling it from a synchronized region can cause exceptions, deadlocks, or data corruption.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">To make this concrete, consider the following class, which implements an </span><span style="font-style: italic; color: rgb(51, 51, 51);">observable</span><span style="color: rgb(51, 51, 51);"> set wrapper. It allows clients to subscribe to notifications when elements are added to the set. This is the </span><span style="font-style: italic; color: rgb(51, 51, 51);">Observer</span><span style="color: rgb(51, 51, 51);"> pattern [</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ref.xhtml#rGamma95" style="color: rgb(7, 7, 7);">Gamma95</a><span style="color: rgb(51, 51, 51);">]. For brevity’s sake, the class does not provide notifications when elements are removed from the set, but it would be a simple matter to provide them. This class is implemented atop the reusable ForwardingSet from </span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch4.xhtml#lev18" style="color: rgb(7, 7, 7);">Item 18</a><span style="color: rgb(51, 51, 51);"> (page 90):</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/317pro01.jpg" width="599.8040861039345"></img></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Observers subscribe to notifications by invoking the addObserver method and unsubscribe by invoking the removeObserver method. In both cases, an instance of this </span><span style="font-style: italic; color: rgb(51, 51, 51);">callback</span><span style="color: rgb(51, 51, 51);"> interface is passed to the method.</span></div><div><br/></div><div><img src="effective java_files/Image [24].jpg" type="image/jpeg" data-filename="Image.jpg" alt="Image" width="547.902774810791"/></div><div><br/></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">This interface is structurally identical to BiConsumer&lt;ObservableSet&lt;E&gt;,E&gt;. We chose to define a custom functional interface because the interface and method names make the code more readable and because the interface could evolve to incorporate multiple callbacks. That said, a reasonable argument could also be made for using BiConsumer (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch7.xhtml#lev44" style="color: rgb(7, 7, 7);">Item 44</a><span style="color: rgb(51, 51, 51);">).</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">On cursory inspection, ObservableSet appears to work fine. For example, the following program prints the numbers from 0 through 99:</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/318pro03.jpg" width="444.902774810791"></img></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Now let’s try something a bit fancier. Suppose we replace the addObserver call with one that passes an observer that prints the Integer value that was added to the set and removes itself if the value is 23:</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/319pro01.jpg" width="536.902774810791"></img></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Note that this call uses an anonymous class instance in place of the lambda used in the previous call. That is because the function object needs to pass itself to s.removeObserver, and lambdas cannot access themselves (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch7.xhtml#lev42" style="color: rgb(7, 7, 7);">Item 42</a><span style="color: rgb(51, 51, 51);">).</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">You might expect the program to print the numbers 0 through 23, after which the observer would unsubscribe and the program would terminate silently. In fact, it prints these numbers and then throws a ConcurrentModificationException. The problem is that notifyElementAdded is in the process of iterating over the observers list when it invokes the observer’s added method. The added method calls the observable set’s removeObserver method, which in turn calls the method observers.remove. Now we’re in trouble. We are trying to remove an element from a list in the midst of iterating over it, which is illegal. The iteration in the notifyElementAdded method is in a synchronized block to prevent concurrent modification, but it doesn’t prevent the iterating thread itself from calling back into the observable set and modifying its observers list.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Now let’s try something odd: let’s write an observer that tries to unsubscribe, but instead of calling removeObserver directly, it engages the services of another thread to do the deed. This observer uses an </span><span style="font-style: italic; color: rgb(51, 51, 51);">executor service</span><span style="color: rgb(51, 51, 51);"> (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch11.xhtml#lev80" style="color: rgb(7, 7, 7);">Item 80</a><span style="color: rgb(51, 51, 51);">):</span></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/319pro02.jpg" width="556.902774810791"></img></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">When we run this program, we don’t get an exception; we get a deadlock. The background thread calls s.removeObserver, which attempts to lock observers, but it can’t acquire the lock, because the main thread already has the lock. All the while, the main thread is waiting for the background thread to finish removing the observer, which explains the deadlock.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">In both of the previous examples (the exception and the deadlock) we were lucky. The resource that was guarded by the synchronized region (observers) was in a consistent state when the alien method (added) was invoked. Suppose you were to invoke an alien method from a synchronized region while the invariant protected by the synchronized region was temporarily invalid. Because locks in the Java programming language are </span><span style="font-style: italic; color: rgb(51, 51, 51);">reentrant</span><span style="color: rgb(51, 51, 51);">, such calls won’t deadlock. As in the first example, which resulted in an exception, the calling thread already holds the lock, so the thread will succeed when it tries to reacquire the lock, even though another conceptually unrelated operation is in progress on the data guarded by the lock. The consequences of such a failure can be catastrophic. In essence, the lock has failed to do its job. Reentrant locks simplify the construction of multithreaded object-oriented programs, but they can turn liveness failures into safety failures.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Luckily, it is usually not too hard to fix this sort of problem by moving alien method invocations out of synchronized blocks. For the notifyElementAdded method, this involves taking a “snapshot” of the observers list that can then be safely traversed without a lock. With this change, both of the previous examples run without exception or deadlock:</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/320pro01.jpg" width="514.902774810791"></img></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">In fact, there’s a better way to move the alien method invocations out of the synchronized block. The libraries provide a </span><span style="font-style: italic; color: rgb(51, 51, 51);">concurrent collection</span><span style="color: rgb(51, 51, 51);"> (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch11.xhtml#lev81" style="color: rgb(7, 7, 7);">Item 81</a><span style="color: rgb(51, 51, 51);">) known as CopyOnWriteArrayList that is tailor-made for this purpose. This List implementation is a variant of ArrayList in which all modification operations are implemented by making a fresh copy of the entire underlying array. Because the internal array is never modified, iteration requires no locking and is very fast. For most uses, the performance of CopyOnWriteArrayList would be atrocious, but it’s perfect for observer lists, which are rarely modified and often traversed.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">An alien method invoked outside of a synchronized region is known as an </span><span style="font-style: italic; color: rgb(51, 51, 51);">open call</span><span style="color: rgb(51, 51, 51);"> [</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ref.xhtml#rGoetz06" style="color: rgb(7, 7, 7);">Goetz06, 10.1.4</a><span style="color: rgb(51, 51, 51);">]. Besides preventing failures, open calls can greatly increase concurrency. An alien method might run for an arbitrarily long period. If the alien method were invoked from a synchronized region, other threads would be denied access to the protected resource unnecessarily.</span></div><div><br/></div><div><span style="font-weight: bold; color: rgb(51, 51, 51);">As a rule, you should do as little work as possible inside synchronized regions.</span><span style="color: rgb(51, 51, 51);"> Obtain the lock, examine the shared data, transform it as necessary, and drop the lock. If you must perform some time-consuming activity, find a way to move it out of the synchronized region without violating the guidelines in </span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch11.xhtml#lev78" style="color: rgb(7, 7, 7);">Item 78</a><span style="color: rgb(51, 51, 51);">.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The first part of this item was about correctness. Now let’s take a brief look at performance. While the cost of synchronization has plummeted since the early days of Java, it is more important than ever not to oversynchronize. In a multicore world, the real cost of excessive synchronization is not the CPU time spent getting locks; it is </span><span style="font-style: italic; color: rgb(51, 51, 51);">contention</span><span style="color: rgb(51, 51, 51);">: the lost opportunities for parallelism and the delays imposed by the need to ensure that every core has a consistent view of memory. Another hidden cost of oversynchronization is that it can limit the VM’s ability to optimize code execution.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">If you are writing a mutable class, you have two options: you can omit all synchronization and allow the client to synchronize externally if concurrent use is desired, or you can synchronize internally, making the class </span><span style="font-style: italic; color: rgb(51, 51, 51);">thread-safe</span><span style="color: rgb(51, 51, 51);"> (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch11.xhtml#lev82" style="color: rgb(7, 7, 7);">Item 82</a><span style="color: rgb(51, 51, 51);">). You should choose the latter option only if you can achieve significantly higher concurrency with internal synchronization than you could by having the client lock the entire object externally. The collections in java.util (with the exception of the obsolete Vector and Hashtable) take the former approach, while those in java.util.concurrent take the latter (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch11.xhtml#lev81" style="color: rgb(7, 7, 7);">Item 81</a><span style="color: rgb(51, 51, 51);">)</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">If you do synchronize your class internally, you can use various techniques to achieve high concurrency, such as lock splitting, lock striping, and nonblocking concurrency control. These techniques are beyond the scope of this book, but they are discussed elsewhere [</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ref.xhtml#rGoetz06" style="color: rgb(7, 7, 7);">Goetz06</a><span style="color: rgb(51, 51, 51);">, </span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ref.xhtml#rHerlihy12" style="color: rgb(7, 7, 7);">Herlihy12</a><span style="color: rgb(51, 51, 51);">].</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">If a method modifies a static field and there is any possibility that the method will be called from multiple threads, you </span><span style="font-style: italic; color: rgb(51, 51, 51);">must</span><span style="color: rgb(51, 51, 51);"> synchronize access to the field internally (unless the class can tolerate nondeterministic behavior). It is not possible for a multithreaded client to perform external synchronization on such a method, because unrelated clients can invoke the method without synchronization. The field is essentially a global variable even if it is private because it can be read and modified by unrelated clients. The nextSerialNumber field used by the method generateSerialNumber in </span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch11.xhtml#lev78" style="color: rgb(7, 7, 7);">Item 78</a><span style="color: rgb(51, 51, 51);"> exemplifies this situation.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">In summary, to avoid deadlock and data corruption, never call an alien method from within a synchronized region. More generally, keep the amount of work that you do from within synchronized regions to a minimum. When you are designing a mutable class, think about whether it should do its own synchronization. In the multicore era, it is more important than ever not to oversynchronize. Synchronize your class internally only if there is a good reason to do so, and document your decision clearly (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch11.xhtml#lev82" style="color: rgb(7, 7, 7);">Item 82</a><span style="color: rgb(51, 51, 51);">)</span></div><h3 style="text-align:start;"></h3></td></tr></tbody></table><div><br/></div><div><br/></div><div><br/></div><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">PREFER EXECUTORS, TASKS, AND STREAMS TO THREADS</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">You can do </span><span style="font-style: italic; color: rgb(51, 51, 51);">many</span><span style="color: rgb(51, 51, 51);"> more things with an executor service. For example, you can wait for a particular task to complete (with the get method, as shown in </span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch11.xhtml#lev79" style="color: rgb(7, 7, 7);">Item 79</a><span style="color: rgb(51, 51, 51);">, page 319), you can wait for any or all of a collection of tasks to complete (using the invokeAny or invokeAll methods), you can wait for the executor service to terminate (using the awaitTermination method), you can retrieve the results of tasks one by one as they complete (using an ExecutorCompletionService), you can schedule tasks to run at a particular time or to run periodically (using a ScheduledThreadPoolExecutor), and so on.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">If you want more than one thread to process requests from the queue, simply call a different static factory that creates a different kind of executor service called a </span><span style="font-style: italic; color: rgb(51, 51, 51);">thread pool</span><span style="color: rgb(51, 51, 51);">. You can create a thread pool with a fixed or variable number of threads. The java.util.concurrent.Executors class contains static factories that provide most of the executors you’ll ever need. If, however, you want something out of the ordinary, you can use the ThreadPoolExecutor class directly. This class lets you configure nearly every aspect of a thread pool’s operation.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Choosing the executor service for a particular application can be tricky. For a small program, or a lightly loaded server, Executors.newCachedThreadPool is generally a good choice because it demands no configuration and generally “does the right thing.” But a cached thread pool is not a good choice for a heavily loaded production server! In a cached thread pool, submitted tasks are not queued but immediately handed off to a thread for execution. If no threads are available, a new one is created. If a server is so heavily loaded that all of its CPUs are fully utilized and more tasks arrive, more threads will be created, which will only make matters worse. Therefore, in a heavily loaded production server, you are much better off using Executors.newFixedThreadPool, which gives you a pool with a fixed number of threads, or using the ThreadPoolExecutor class directly, for maximum control.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Not only should you refrain from writing your own work queues, but you should generally refrain from working directly with threads. When you work directly with threads, a Thread serves as both a unit of work and the mechanism for executing it. In the executor framework, the unit of work and the execution mechanism are separate. The key abstraction is the unit of work, which is the </span><span style="font-style: italic; color: rgb(51, 51, 51);">task</span><span style="color: rgb(51, 51, 51);">. There are two kinds of tasks: Runnable and its close cousin, Callable (which is like Runnable, except that it returns a value and can throw arbitrary exceptions). The general mechanism for executing tasks is the </span><span style="font-style: italic; color: rgb(51, 51, 51);">executor service</span><span style="color: rgb(51, 51, 51);">. If you think in terms of tasks and let an executor service execute them for you, you gain the flexibility to select an appropriate execution policy to meet your needs and to change the policy if your needs change. In essence, the Executor Framework does for execution what the Collections Framework did for aggregation.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">PREFER CONCURRENCY UTILITIES TO</span><span style="color: rgb(64, 64, 64);"> </span><span style="font-weight: bold; color: rgb(64, 64, 64);">WAIT</span><span style="color: rgb(64, 64, 64);"> </span><span style="font-weight: bold; color: rgb(64, 64, 64);">AND</span><span style="color: rgb(64, 64, 64);"> </span><span style="font-weight: bold; color: rgb(64, 64, 64);">NOTIFY</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">The first edition of this book devoted an item to the correct use of wait and notify [</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ref.xhtml#rBloch01" style="color: rgb(7, 7, 7);">Bloch01</a><span style="color: rgb(51, 51, 51);">, </span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch8.xhtml#lev50" style="color: rgb(7, 7, 7);">Item 50</a><span style="color: rgb(51, 51, 51);">]. Its advice is still valid and is summarized at end of this item, but this advice is far less important than it once was. This is because there is far less reason to use wait and notify. Since Java 5, the platform has provided higher-level concurrency utilities that do the sorts of things you formerly had to hand-code atop wait and notify. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Given the difficulty of using</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">wait</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">and</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">notify</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">correctly, you should use the higher-level concurrency utilities instead.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The higher-level utilities in java.util.concurrent fall into three categories: the Executor Framework, which was covered briefly in </span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch11.xhtml#lev80" style="color: rgb(7, 7, 7);">Item 80</a><span style="color: rgb(51, 51, 51);">; concurrent collections; and synchronizers. Concurrent collections and synchronizers are covered briefly in this item.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The concurrent collections are high-performance concurrent implementations of standard collection interfaces such as List, Queue, and Map. To provide high concurrency, these implementations manage their own synchronization internally (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch11.xhtml#lev79" style="color: rgb(7, 7, 7);">Item 79</a><span style="color: rgb(51, 51, 51);">). Therefore, </span><span style="font-weight: bold; color: rgb(51, 51, 51);">it is impossible to exclude concurrent activity from a concurrent collection; locking it will only slow the program.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Besides offering excellent concurrency, ConcurrentHashMap is very fast. On my machine, the intern method above is over six times faster than String.intern (but keep in mind that String.intern must employ some strategy to keep from leaking memory in a long-lived application). Concurrent collections make synchronized collections largely obsolete. For example, </span><span style="font-weight: bold; color: rgb(51, 51, 51);">use</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">ConcurrentHashMap</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">in preference to</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Collections.synchronizedMap.</span><span style="color: rgb(51, 51, 51);"> Simply replacing synchronized maps with concurrent maps can dramatically increase the performance of concurrent applications.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Some of the collection interfaces were extended with </span><span style="font-style: italic; color: rgb(51, 51, 51);">blocking operations,</span><span style="color: rgb(51, 51, 51);"> which wait (or </span><span style="font-style: italic; color: rgb(51, 51, 51);">block</span><span style="color: rgb(51, 51, 51);">) until they can be successfully performed. For example, BlockingQueue extends Queue and adds several methods, including take, which removes and returns the head element from the queue, waiting if the queue is empty. This allows blocking queues to be used for </span><span style="font-style: italic; color: rgb(51, 51, 51);">work queues</span><span style="color: rgb(51, 51, 51);"> (also known as </span><span style="font-style: italic; color: rgb(51, 51, 51);">producer-consumer queues</span><span style="color: rgb(51, 51, 51);">), to which one or more </span><span style="font-style: italic; color: rgb(51, 51, 51);">producer threads</span><span style="color: rgb(51, 51, 51);"> enqueue work items and from which one or more </span><span style="font-style: italic; color: rgb(51, 51, 51);">consumer threads</span><span style="color: rgb(51, 51, 51);"> dequeue and process items as they become available. As you’d expect, most ExecutorService implementations, including ThreadPoolExecutor, use a BlockingQueue (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch11.xhtml#lev80" style="color: rgb(7, 7, 7);">Item 80</a>).</div><div><br/></div><div><span style="font-style: italic; color: rgb(51, 51, 51);">Synchronizers</span><span style="color: rgb(51, 51, 51);"> are objects that enable threads to wait for one another, allowing them to coordinate their activities. The most commonly used synchronizers are CountDownLatch and Semaphore. Less commonly used are CyclicBarrier and Exchanger. The most powerful synchronizer is Phaser.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Countdown latches are single-use barriers that allow one or more threads to wait for one or more other threads to do something. The sole constructor for CountDownLatch takes an int that is the number of times the countDown method must be invoked on the latch before all waiting threads are allowed to proceed.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">It is surprisingly easy to build useful things atop this simple primitive. For example, suppose you want to build a simple framework for timing the concurrent execution of an action. This framework consists of a single method that takes an executor to execute the action, a concurrency level representing the number of actions to be executed concurrently, and a runnable representing the action. All of the worker threads ready themselves to run the action before the timer thread starts the clock. When the last worker thread is ready to run the action, the timer thread “fires the starting gun,” allowing the worker threads to perform the action. As soon as the last worker thread finishes performing the action, the timer thread stops the clock. Implementing this logic directly on top of wait and notify would be messy to say the least, but it is surprisingly straightforward on top of CountDownLatch:</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/327pro01.jpg" width="533.6083100417565"></img></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Note that the method uses three countdown latches. The first, ready, is used by worker threads to tell the timer thread when they’re ready. The worker threads then wait on the second latch, which is start. When the last worker thread invokes ready.countDown, the timer thread records the start time and invokes start.countDown, allowing all of the worker threads to proceed. Then the timer thread waits on the third latch, done, until the last of the worker threads finishes running the action and calls done.countDown. As soon as this happens, the timer thread awakens and records the end time.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">A few more details bear noting. The executor passed to the time method must allow for the creation of at least as many threads as the given concurrency level, or the test will never complete. This is known as a </span><span style="font-style: italic; color: rgb(51, 51, 51);">thread starvation deadlock</span><span style="color: rgb(51, 51, 51);"> [Goetz06, 8.1.1]. If a worker thread catches an InterruptedException, it reasserts the interrupt using the idiom Thread.currentThread().interrupt() and returns from its run method. This allows the executor to deal with the interrupt as it sees fit. Note that System.nanoTime is used to time the activity. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">For interval timing, always use</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">System.nanoTime</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">rather than</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">System.currentTimeMillis.</span><span style="color: rgb(51, 51, 51);"> System.nanoTime is both more accurate and more precise and is unaffected by adjustments to the system’s real-time clock. Finally, note that the code in this example won’t yield accurate timings unless action does a fair amount of work, say a second or more. Accurate microbenchmarking is notoriously hard and is best done with the aid of a specialized framework such as jmh [</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ref.xhtml#rJMH" style="color: rgb(7, 7, 7);">JMH</a><span style="color: rgb(51, 51, 51);">].</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">This item only scratches the surface of what you can do with the concurrency utilities. For example, the three countdown latches in the previous example could be replaced by a single CyclicBarrier or Phaser instance. The resulting code would be a bit more concise but perhaps more difficult to understand.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">While you should always use the concurrency utilities in preference to wait and notify, you might have to maintain legacy code that uses wait and notify. The wait method is used to make a thread wait for some condition. It must be invoked inside a synchronized region that locks the object on which it is invoked. Here is the standard idiom for using the wait method:</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/328pro01.jpg" width="584.902774810791"></img></div><div><br/></div><div><span style="font-weight: bold; color: rgb(51, 51, 51);">Always use the wait loop idiom to invoke the</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">wait</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">method; never invoke it outside of a loop.</span><span style="color: rgb(51, 51, 51);"> The loop serves to test the condition before and after waiting.</span></div><div><span style="color: rgb(51, 51, 51);">Testing the condition before waiting and skipping the wait if the condition already holds are necessary to ensure liveness. If the condition already holds and the notify (or notifyAll) method has already been invoked before a thread waits, there is no guarantee that the thread will </span><span style="font-style: italic; color: rgb(51, 51, 51);">ever</span><span style="color: rgb(51, 51, 51);"> wake from the wait.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">• Another thread could have obtained the lock and changed the guarded state between the time a thread invoked notify and the waiting thread woke up.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">• Another thread could have invoked notify accidentally or maliciously when the condition did not hold. Classes expose themselves to this sort of mischief by waiting on publicly accessible objects. Any wait in a synchronized method of a publicly accessible object is susceptible to this problem.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">• The notifying thread could be overly “generous” in waking waiting threads. For example, the notifying thread might invoke notifyAll even if only some of the waiting threads have their condition satisfied.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">• The waiting thread could (rarely) wake up in the absence of a notify. This is known as a </span><span style="font-style: italic; color: rgb(51, 51, 51);">spurious wakeup</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">A related issue is whether to use notify or notifyAll to wake waiting threads. (Recall that notify wakes a single waiting thread, assuming such a thread exists, and notifyAll wakes all waiting threads.) It is sometimes said that you should </span><span style="font-style: italic; color: rgb(51, 51, 51);">always</span><span style="color: rgb(51, 51, 51);"> use notifyAll. This is reasonable, conservative advice. It will always yield correct results because it guarantees that you’ll wake the threads that need to be awakened. You may wake some other threads, too, but this won’t affect the correctness of your program. These threads will check the condition for which they’re waiting and, finding it false, will continue waiting.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">As an optimization, you may choose to invoke notify instead of notifyAll if all threads that could be in the wait-set are waiting for the same condition and only one thread at a time can benefit from the condition becoming true.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">In summary, using wait and notify directly is like programming in “concurrency assembly language,” as compared to the higher-level language provided by java.util.concurrent. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">There is seldom, if ever, a reason to use</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">wait</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">and</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">notify</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">in new code.</span><span style="color: rgb(51, 51, 51);"> If you maintain code that uses wait and notify, make sure that it always invokes wait from within a while loop using the standard idiom. The notifyAll method should generally be used in preference to notify. If notify is used, great care must be taken to ensure liveness.</span></div></td></tr></tbody></table><div><br/></div><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><h3 style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">DOCUMENT THREAD SAFETY</span></h3></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">How a class behaves when its methods are used concurrently is an important part of its contract with its clients. If you fail to document this aspect of a class’s behavior, its users will be forced to make assumptions. If these assumptions are wrong, the resulting program may perform insufficient synchronization (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch11.xhtml#lev78" style="color: rgb(7, 7, 7);">Item 78</a><span style="color: rgb(51, 51, 51);">) or excessive synchronization (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch11.xhtml#lev79" style="color: rgb(7, 7, 7);">Item 79</a><span style="color: rgb(51, 51, 51);">). In either case, serious errors may result.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">You may hear it said that you can tell if a method is thread-safe by looking for the synchronized modifier in its documentation. This is wrong on several counts. In normal operation, Javadoc does not include the synchronized modifier in its output, and with good reason. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">The presence of the</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">synchronized</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">modifier in a method declaration is an implementation detail, not a part of its API.</span><span style="color: rgb(51, 51, 51);"> It does not reliably indicate that a method is thread-safe.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Moreover, the claim that the presence of the synchronized modifier is sufficient to document thread safety embodies the misconception that thread safety is an all-or-nothing property. In fact, there are several levels of thread safety. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">To enable safe concurrent use, a class must clearly document what level of thread safety it supports.</span><span style="color: rgb(51, 51, 51);"> The following list summarizes levels of thread safety. It is not exhaustive but covers the common cases:</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">• </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Immutable</span><span style="color: rgb(51, 51, 51);">—Instances of this class appear constant. No external synchronization is necessary. Examples include String, Long, and BigInteger (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch4.xhtml#lev17" style="color: rgb(7, 7, 7);">Item 17</a>).</div><div><br/></div><div><span style="color: rgb(51, 51, 51);">• </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Unconditionally thread-safe</span><span style="color: rgb(51, 51, 51);">—Instances of this class are mutable, but the class has sufficient internal synchronization that its instances can be used concurrently without the need for any external synchronization. Examples include AtomicLong and ConcurrentHashMap.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">• </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Conditionally thread-safe</span><span style="color: rgb(51, 51, 51);">—Like unconditionally thread-safe, except that some methods require external synchronization for safe concurrent use. Examples include the collections returned by the Collections.synchronized wrappers, whose iterators require external synchronization.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">• </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Not thread-safe</span><span style="color: rgb(51, 51, 51);">—Instances of this class are mutable. To use them concurrently, clients must surround each method invocation (or invocation sequence) with external synchronization of the clients’ choosing. Examples include the general-purpose collection implementations, such as ArrayList and HashMap.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">• </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Thread-hostile</span><span style="color: rgb(51, 51, 51);">—This class is unsafe for concurrent use even if every method invocation is surrounded by external synchronization. Thread hostility usually results from modifying static data without synchronization. No one writes a thread-hostile class on purpose; such classes typically result from the failure to consider concurrency. When a class or method is found to be thread-hostile, it is typically fixed or deprecated</span></div><div><br/></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">These categories (apart from thread-hostile) correspond roughly to the </span><span style="font-style: italic; color: rgb(51, 51, 51);">thread safety annotations</span><span style="color: rgb(51, 51, 51);"> in </span><span style="font-style: italic; color: rgb(51, 51, 51);">Java Concurrency in Practice</span><span style="color: rgb(51, 51, 51);">, which are Immutable, ThreadSafe, and NotThreadSafe [Goetz06, Appendix A]. The unconditionally and conditionally thread-safe categories in the above taxonomy are both covered under the ThreadSafe annotation.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">To summarize, every class should clearly document its thread safety properties with a carefully worded prose description or a thread safety annotation. The synchronized modifier plays no part in this documentation. Conditionally thread-safe classes must document which method invocation sequences require external synchronization and which lock to acquire when executing these sequences. If you write an unconditionally thread-safe class, consider using a private lock object in place of synchronized methods. This protects you against synchronization interference by clients and subclasses and gives you more flexibility to adopt a sophisticated approach to concurrency control in a later release.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><h3 style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">USE LAZY INITIALIZATION JUDICIOUSLY</span></h3></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-style: italic; color: rgb(51, 51, 51);">Lazy initialization</span><span style="color: rgb(51, 51, 51);"> is the act of delaying the initialization of a field until its value is needed. If the value is never needed, the field is never initialized. This technique is applicable to both static and instance fields. While lazy initialization is primarily an optimization, it can also be used to break harmful circularities in class and instance initialization [</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ref.xhtml#rBloch05" style="color: rgb(7, 7, 7);">Bloch05</a><span style="color: rgb(51, 51, 51);">, Puzzle 51].</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">As is the case for most optimizations, the best advice for lazy initialization is “don’t do it unless you need to” (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch9.xhtml#lev67" style="color: rgb(7, 7, 7);">Item 67</a><span style="color: rgb(51, 51, 51);">). Lazy initialization is a double-edged sword. It decreases the cost of initializing a class or creating an instance, at the expense of increasing the cost of accessing the lazily initialized field. Depending on what fraction of these fields eventually require initialization, how expensive it is to initialize them, and how often each one is accessed once initialized, lazy initialization can (like many “optimizations”) actually harm performance.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">That said, lazy initialization has its uses. If a field is accessed only on a fraction of the instances of a class </span><span style="font-style: italic; color: rgb(51, 51, 51);">and</span><span style="color: rgb(51, 51, 51);"> it is costly to initialize the field, then lazy initialization may be worthwhile. The only way to know for sure is to measure the performance of the class with and without lazy initialization.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">In the presence of multiple threads, lazy initialization is tricky. If two or more threads share a lazily initialized field, it is critical that some form of synchronization be employed, or severe bugs can result (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch11.xhtml#lev78" style="color: rgb(7, 7, 7);">Item 78</a>). All of the initialization techniques discussed in this item are thread-safe.</div><div><span style="font-weight: bold; color: rgb(51, 51, 51);">Under most circumstances, normal initialization is preferable to lazy initialization.</span><span style="color: rgb(51, 51, 51);"> </span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Both of these idioms (</span><span style="font-style: italic; color: rgb(51, 51, 51);">normal initialization</span><span style="color: rgb(51, 51, 51);"> and </span><span style="font-style: italic; color: rgb(51, 51, 51);">lazy initialization with a synchronized accessor</span><span style="color: rgb(51, 51, 51);">) are unchanged when applied to static fields, except that you add the static modifier to the field and accessor declarations.</span></div><div><span style="font-weight: bold; color: rgb(51, 51, 51);">If you need to use lazy initialization for performance on a static field, use the</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; font-style: italic; color: rgb(51, 51, 51);">lazy initialization holder class idiom</span><span style="font-weight: bold; color: rgb(51, 51, 51);">.</span><span style="color: rgb(51, 51, 51);"> This idiom exploits the guarantee that a class will not be initialized until it is used [JLS, 12.4.1]. Here’s how it looks:</span></div><div><br/></div><div><img src="effective java_files/Image [25].jpg" type="image/jpeg" data-filename="Image.jpg" alt="Image" width="544.902774810791"/></div><div><br/></div><div><br/></div><div><span style="font-weight: bold; color: rgb(51, 51, 51);">If you need to use lazy initialization for performance on an instance field, use the</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; font-style: italic; color: rgb(51, 51, 51);">double-check idiom</span><span style="font-weight: bold; color: rgb(51, 51, 51);">.</span><span style="color: rgb(51, 51, 51);"> This idiom avoids the cost of locking when accessing the field after initialization (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch11.xhtml#lev79" style="color: rgb(7, 7, 7);">Item 79</a><span style="color: rgb(51, 51, 51);">). The idea behind the idiom is to check the value of the field twice (hence the name </span><span style="font-style: italic; color: rgb(51, 51, 51);">double-check</span><span style="color: rgb(51, 51, 51);">): once without locking and then, if the field appears to be uninitialized, a second time with locking. Only if the second check indicates that the field is uninitialized does the call initialize the field. Because there is no locking once the field is initialized, it is </span><span style="font-style: italic; color: rgb(51, 51, 51);">critical</span><span style="color: rgb(51, 51, 51);"> that the field be declared volatile (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch11.xhtml#lev78" style="color: rgb(7, 7, 7);">Item 78</a><span style="color: rgb(51, 51, 51);">). Here is the idiom:</span></div><div><br/></div><div><img src="effective java_files/Image [26].jpg" type="image/jpeg" data-filename="Image.jpg" alt="Image" width="566.902774810791"/></div><div><br/></div><div>This code may appear a bit convoluted. In particular, the need for the local variable (result) may be unclear. What this variable does is to ensure that field is read only once in the common case where it’s already initialized. While not strictly necessary, this may improve performance and is more elegant by the standards applied to low-level concurrent programming. On my machine, the method above is about 1.4 times as fast as the obvious version without a local variable.</div><div><br/></div><div><span style="color: rgb(51, 51, 51);">While you can apply the double-check idiom to static fields as well, there is no reason to do so: the lazy initialization holder class idiom is a better choice.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Two variants of the double-check idiom bear noting. Occasionally, you may need to lazily initialize an instance field that can tolerate repeated initialization. If you find yourself in this situation, you can use a variant of the double-check idiom that dispenses with the second check. It is, not surprisingly, known as the </span><span style="font-style: italic; color: rgb(51, 51, 51);">single-check idiom</span><span style="color: rgb(51, 51, 51);">. Here is how it looks. Note that field is still declared volatile:</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/335pro01.jpg" width="514.902774810791"></img></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">All of the initialization techniques discussed in this item apply to primitive fields as well as object reference fields. When the double-check or single-check idiom is applied to a numerical primitive field, the field’s value is checked against 0 (the default value for numerical primitive variables) rather than null.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">If you don’t care whether </span><span style="font-style: italic; color: rgb(51, 51, 51);">every</span><span style="color: rgb(51, 51, 51);"> thread recalculates the value of a field, and the type of the field is a primitive other than long or double, then you may choose to remove the volatile modifier from the field declaration in the single-check idiom. This variant is known as the </span><span style="font-style: italic; color: rgb(51, 51, 51);">racy single-check idiom.</span><span style="color: rgb(51, 51, 51);"> It speeds up field access on some architectures, at the expense of additional initializations (up to one per thread that accesses the field). This is definitely an exotic technique, not for everyday use.</span></div><div><br/></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><h3 style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">DON’T DEPEND ON THE THREAD SCHEDULER</span></h3></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">When many threads are runnable, the thread scheduler determines which ones get to run and for how long. Any reasonable operating system will try to make this determination fairly, but the policy can vary. Therefore, well-written programs shouldn’t depend on the details of this policy. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Any program that relies on the thread scheduler for correctness or performance is likely to be nonportable.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The best way to write a robust, responsive, portable program is to ensure that the average number of </span><span style="font-style: italic; color: rgb(51, 51, 51);">runnable</span><span style="color: rgb(51, 51, 51);"> threads is not significantly greater than the number of processors. This leaves the thread scheduler with little choice: it simply runs the runnable threads till they’re no longer runnable. The program’s behavior doesn’t vary too much, even under radically different thread-scheduling policies. Note that the number of runnable threads isn’t the same as the total number of threads, which can be much higher. Threads that are waiting are not runnable.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The main technique for keeping the number of runnable threads low is to have each thread do some useful work, and then wait for more. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Threads should not run if they aren’t doing useful work.</span><span style="color: rgb(51, 51, 51);"> In terms of the Executor Framework (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch11.xhtml#lev80" style="color: rgb(7, 7, 7);">Item 80</a><span style="color: rgb(51, 51, 51);">), this means sizing thread pools appropriately [Goetz06, 8.2] and keeping tasks short, but not </span><span style="font-style: italic; color: rgb(51, 51, 51);">too</span><span style="color: rgb(51, 51, 51);"> short, or dispatching overhead will harm performance.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">When faced with a program that barely works because some threads aren’t getting enough CPU time relative to others, </span><span style="font-weight: bold; color: rgb(51, 51, 51);">resist the temptation to “fix” the program by putting in calls to</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Thread.yield.</span><span style="color: rgb(51, 51, 51);"> You may succeed in getting the program to work after a fashion, but it will not be portable. The same yield invocations that improve performance on one JVM implementation might make it worse on a second and have no effect on a third. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Thread.yield</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">has no testable semantics.</span><span style="color: rgb(51, 51, 51);"> A better course of action is to restructure the application to reduce the number of concurrently runnable threads.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">A related technique, to which similar caveats apply, is adjusting thread priorities. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Thread priorities are among the least portable features of Java.</span><span style="color: rgb(51, 51, 51);"> It is not unreasonable to tune the responsiveness of an application by tweaking a few thread priorities, but it is rarely necessary and is not portable. It is unreasonable to attempt to solve a serious liveness problem by adjusting thread priorities. The problem is likely to return until you find and fix the underlying cause.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><h3 style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">PREFER ALTERNATIVES TO JAVA SERIALIZATION</span></h3></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">A fundamental problem with serialization is that its </span><span style="font-style: italic; color: rgb(51, 51, 51);">attack surface</span><span style="color: rgb(51, 51, 51);"> is too big to protect, and constantly growing: Object graphs are deserialized by invoking the readObject method on an ObjectInputStream. This method is essentially a magic constructor that can be made to instantiate objects of almost any type on the class path, so long as the type implements the Serializable interface. In the process of deserializing a byte stream, this method can execute code from any of these types, so the code for </span><span style="font-style: italic; color: rgb(51, 51, 51);">all</span><span style="color: rgb(51, 51, 51);"> of these types is part of the attack surface.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The attack surface includes classes in the Java platform libraries, in third-party libraries such as Apache Commons Collections, and in the application itself. Even if you adhere to all of the relevant best practices and succeed in writing serializable classes that are invulnerable to attack, your application may still be vulnerable. To quote Robert Seacord, technical manager of the CERT Coordination Center:</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Java deserialization is a clear and present danger as it is widely used both directly by applications and indirectly by Java subsystems such as RMI (Remote Method Invocation), JMX (Java Management Extension), and JMS (Java Messaging System). Deserialization of untrusted streams can result in remote code execution (RCE), denial-of-service (DoS), and a range of other exploits. Applications can be vulnerable to these attacks even if they did nothing wrong. [</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ref.xhtml#rSeacord17" style="color: rgb(7, 7, 7);">Seacord17</a><span style="color: rgb(51, 51, 51);">]</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Attackers and security researchers study the serializable types in the Java libraries and in commonly used third-party libraries, looking for methods invoked during deserialization that perform potentially dangerous activities. Such methods are known as </span><span style="font-style: italic; color: rgb(51, 51, 51);">gadgets</span><span style="color: rgb(51, 51, 51);">. Multiple gadgets can be used in concert, to form a </span><span style="font-style: italic; color: rgb(51, 51, 51);">gadget chain</span><span style="color: rgb(51, 51, 51);">. From time to time, a gadget chain is discovered that is sufficiently powerful to allow an attacker to execute arbitrary native code on the underlying hardware, given only the opportunity to submit a carefully crafted byte stream for deserialization. This is exactly what happened in the SFMTA Muni attack. This attack was not isolated. There have been others, and there will be more.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Without using any gadgets, you can easily mount a denial-of-service attack by causing the deserialization of a short stream that requires a long time to deserialize. Such streams are known as </span><span style="font-style: italic; color: rgb(51, 51, 51);">deserialization bombs</span><span style="color: rgb(51, 51, 51);"> [</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ref.xhtml#rSvoboda16" style="color: rgb(7, 7, 7);">Svoboda16</a><span style="color: rgb(51, 51, 51);">]. Here’s an example by Wouter Coekaerts that uses only hash sets and a string [</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ref.xhtml#rCoekaerts15" style="color: rgb(7, 7, 7);">Coekaerts15</a><span style="color: rgb(51, 51, 51);">]:</span></div><div><br/></div><div><img src="effective java_files/Image [27].jpg" type="image/jpeg" data-filename="Image.jpg" alt="Image" width="546.902774810791"/></div><div><br/></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The object graph consists of 201 HashSet instances, each of which contains 3 or fewer object references. The entire stream is 5,744 bytes long, yet the sun would burn out long before you could deserialize it. The problem is that deserializing a HashSet instance requires computing the hash codes of its elements. The 2 elements of the root hash set are themselves hash sets containing 2 hash-set elements, each of which contains 2 hash-set elements, and so on, 100 levels deep. Therefore, deserializing the set causes the hashCode method to be invoked over 2</span><span style="vertical-align: super; color: rgb(102, 102, 102);">100</span><span style="color: rgb(51, 51, 51);"> times. Other than the fact that the deserialization is taking forever, the deserializer has no indication that anything is amiss. Few objects are produced, and the stack depth is bounded.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">So what can you do defend against these problems? You open yourself up to attack whenever you deserialize a byte stream that you don’t trust. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">The best way to avoid serialization exploits is never to deserialize anything.</span><span style="color: rgb(51, 51, 51);"> In the words of the computer named Joshua in the 1983 movie </span><span style="font-style: italic; color: rgb(51, 51, 51);">WarGames</span><span style="color: rgb(51, 51, 51);">, “the only winning move is not to play.” </span><span style="font-weight: bold; color: rgb(51, 51, 51);">There is no reason to use Java serialization in any new system you write.</span><span style="color: rgb(51, 51, 51);"> There are other mechanisms for translating between objects and byte sequences that avoid many of the dangers of Java serialization, while offering numerous advantages, such as cross-platform support, high performance, a large ecosystem of tools, and a broad community of expertise. In this book, we refer to these mechanisms as </span><span style="font-style: italic; color: rgb(51, 51, 51);">cross-platform structured-data representations.</span><span style="color: rgb(51, 51, 51);"> While others sometimes refer to them as serialization systems, this book avoids that usage to prevent confusion with Java serialization.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">What these representations have in common is that they’re </span><span style="font-style: italic; color: rgb(51, 51, 51);">far</span><span style="color: rgb(51, 51, 51);"> simpler than Java serialization. They don’t support automatic serialization and deserialization of arbitrary object graphs. Instead, they support simple, structured data-objects consisting of a collection of attribute-value pairs. Only a few primitive and array data types are supported. This simple abstraction turns out to be sufficient for building extremely powerful distributed systems and simple enough to avoid the serious problems that have plagued Java serialization since its inception.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The leading cross-platform structured data representations are JSON [</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ref.xhtml#rJSON" style="color: rgb(7, 7, 7);">JSON</a>] and Protocol Buffers, also known as protobuf [<a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ref.xhtml#rProtobuf" style="color: rgb(7, 7, 7);">Protobuf</a>]. JSON was designed by Douglas Crockford for browser-server communication, and protocol buffers were designed by Google for storing and interchanging structured data among its servers. Even though these representations are sometimes called <span style="font-style: italic;">language-neutral</span>, JSON was originally developed for JavaScript and protobuf for C++; both representations retain vestiges of their origins.</div><div><span style="color: rgb(51, 51, 51);">The most significant differences between JSON and protobuf are that JSON is text-based and human-readable, whereas protobuf is binary and substantially more efficient; and that JSON is exclusively a data representation, whereas protobuf offers </span><span style="font-style: italic; color: rgb(51, 51, 51);">schemas</span><span style="color: rgb(51, 51, 51);"> (types) to document and enforce appropriate usage. Although protobuf is more efficient than JSON, JSON is extremely efficient for a text-based representation. And while protobuf is a binary representation, it does provide an alternative text representation for use where human-readability is desired (pbtxt).</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">If you can’t avoid Java serialization entirely, perhaps because you’re working in the context of a legacy system that requires it, your next best alternative is to </span><span style="font-weight: bold; color: rgb(51, 51, 51);">never deserialize untrusted data.</span><span style="color: rgb(51, 51, 51);"> In particular, you should never accept RMI traffic from untrusted sources. The official secure coding guidelines for Java say “Deserialization of untrusted data is inherently dangerous and should be avoided.” This sentence is set in large, bold, italic, red type, and it is the only text in the entire document that gets this treatment [Java-secure].</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">If you can’t avoid serialization and you aren’t absolutely certain of the safety of the data you’re deserializing, use the object deserialization filtering added in Java 9 and backported to earlier releases (java.io.ObjectInputFilter). This facility lets you specify a filter that is applied to data streams before they’re deserialized. It operates at the class granularity, letting you accept or reject certain classes. Accepting classes by default and rejecting a list of potentially dangerous ones is known as </span><span style="font-style: italic; color: rgb(51, 51, 51);">blacklisting</span><span style="color: rgb(51, 51, 51);">; rejecting classes by default and accepting a list of those that are presumed safe is known as </span><span style="font-style: italic; color: rgb(51, 51, 51);">whitelisting</span><span style="color: rgb(51, 51, 51);">. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Prefer whitelisting to blacklisting</span><span style="color: rgb(51, 51, 51);">, as blacklisting only protects you against known threats. A tool called Serial Whitelist Application Trainer (SWAT) can be used to automatically prepare a whitelist for your application [</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ref.xhtml#rSchneider16" style="color: rgb(7, 7, 7);">Schneider16</a><span style="color: rgb(51, 51, 51);">]. The filtering facility will also protect you against excessive memory usage, and excessively deep object graphs, but it will not protect you against serialization bombs like the one shown above.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><h3 style="text-align:start;"><span style="font-weight: bold; color: rgb(64, 64, 64);">IMPLEMENT</span><span style="color: rgb(64, 64, 64);"> </span><span style="font-weight: bold; color: rgb(64, 64, 64);">SERIALIZABLE</span><span style="color: rgb(64, 64, 64);"> </span><span style="font-weight: bold; color: rgb(64, 64, 64);">WITH GREAT CAUTION</span></h3></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="font-weight: bold; color: rgb(51, 51, 51);">A major cost of implementing</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Serializable</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">is that it decreases the flexibility to change a class’s implementation once it has been released.</span><span style="color: rgb(51, 51, 51);"> When a class implements Serializable, its byte-stream encoding (or </span><span style="font-style: italic; color: rgb(51, 51, 51);">serialized form</span><span style="color: rgb(51, 51, 51);">) becomes part of its exported API. Once you distribute a class widely, you are generally required to support the serialized form forever, just as you are required to support all other parts of the exported API. If you do not make the effort to design a </span><span style="font-style: italic; color: rgb(51, 51, 51);">custom serialized form</span><span style="color: rgb(51, 51, 51);"> but merely accept the default, the serialized form will forever be tied to the class’s original internal representation. In other words, if you accept the default serialized form, the class’s private and package-private instance fields become part of its exported API, and the practice of minimizing access to fields (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch4.xhtml#lev15" style="color: rgb(7, 7, 7);">Item 15</a><span style="color: rgb(51, 51, 51);">) loses its effectiveness as a tool for information hiding.</span></div><div><br/></div><div><span style="font-weight: bold; color: rgb(51, 51, 51);">A second cost of implementing</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Serializable</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">is that it increases the likelihood of bugs and security holes (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch12.xhtml#lev85" style="font-weight: bold; color: rgb(7, 7, 7);">Item 85</a><span style="font-weight: bold;">).</span><span style="color: rgb(51, 51, 51);"> Normally, objects are created with constructors; serialization is an </span><span style="font-style: italic; color: rgb(51, 51, 51);">extralinguistic mechanism</span><span style="color: rgb(51, 51, 51);"> for creating objects. Whether you accept the default behavior or override it, deserialization is a “hidden constructor” with all of the same issues as other constructors. Because there is no explicit constructor associated with deserialization, it is easy to forget that you must ensure that it guarantees all of the invariants established by the constructors and that it does not allow an attacker to gain access to the internals of the object under construction. Relying on the default deserialization mechanism can easily leave objects open to invariant corruption and illegal access (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch12.xhtml#lev88" style="color: rgb(7, 7, 7);">Item 88</a><span style="color: rgb(51, 51, 51);">).</span></div><div><br/></div><div><span style="font-weight: bold; color: rgb(51, 51, 51);">A third cost of implementing</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Serializable</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">is that it increases the testing burden associated with releasing a new version of a class.</span><span style="color: rgb(51, 51, 51);"> When a serializable class is revised, it is important to check that it is possible to serialize an instance in the new release and deserialize it in old releases, and vice versa. The amount of testing required is thus proportional to the product of the number of serializable classes and the number of releases, which can be large. You must ensure both that the serialization-deserialization process succeeds and that it results in a faithful replica of the original object. The need for testing is reduced if a custom serialized form is carefully designed when the class is first written (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch12.xhtml#lev87" style="color: rgb(7, 7, 7);">Items 87</a><span style="color: rgb(51, 51, 51);">, </span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch12.xhtml#lev90" style="color: rgb(7, 7, 7);">90</a><span style="color: rgb(51, 51, 51);">).</span></div><div><br/></div><div><span style="font-weight: bold; color: rgb(51, 51, 51);">Implementing</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Serializable</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">is not a decision to be undertaken lightly.</span><span style="color: rgb(51, 51, 51);"> It is essential if a class is to participate in a framework that relies on Java serialization for object transmission or persistence. Also, it greatly eases the use of a class as a component in another class that must implement Serializable. There are, however, many costs associated with implementing Serializable. Each time you design a class, weigh the costs against the benefits. Historically, value classes such as BigInteger and Instant implemented Serializable, and collection classes did too. Classes representing active entities, such as thread pools, should rarely implement Serializable.</span></div><div><br/></div><div><span style="font-weight: bold; color: rgb(51, 51, 51);">Classes designed for inheritance (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch4.xhtml#lev19" style="font-weight: bold; color: rgb(7, 7, 7);">Item 19</a><span style="font-weight: bold;">) should rarely implement</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Serializable</span><span style="color: rgb(51, 51, 51);">, </span><span style="font-weight: bold; color: rgb(51, 51, 51);">and interfaces should rarely extend it.</span><span style="color: rgb(51, 51, 51);"> Violating this rule places a substantial burden on anyone who extends the class or implements the interface. There are times when it is appropriate to violate the rule. For example, if a class or interface exists primarily to participate in a framework that requires all participants to implement Serializable, then it may make sense for the class or interface to implement or extend Serializable.</span></div><div><br/></div><div><span style="font-weight: bold; color: rgb(51, 51, 51);">Inner classes (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch4.xhtml#lev24" style="font-weight: bold; color: rgb(7, 7, 7);">Item 24</a><span style="font-weight: bold;">) should not implement</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Serializable.</span><span style="color: rgb(51, 51, 51);"> They use compiler-generated </span><span style="font-style: italic; color: rgb(51, 51, 51);">synthetic fields</span><span style="color: rgb(51, 51, 51);"> to store references to </span><span style="font-style: italic; color: rgb(51, 51, 51);">enclosing instances</span><span style="color: rgb(51, 51, 51);"> and to store values of local variables from enclosing scopes. How these fields correspond to the class definition is unspecified, as are the names of anonymous and local classes. Therefore, the default serialized form of an inner class is ill-defined. A </span><span style="font-style: italic; color: rgb(51, 51, 51);">static member class</span><span style="color: rgb(51, 51, 51);"> can, however, implement Serializable.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><h3 style="text-align:start;"><span style="color: rgb(64, 64, 64); font-weight: bold;">CONSIDER USING A CUSTOM SERIALIZED FORM</span></h3></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">When you are writing a class under time pressure, it is generally appropriate to concentrate your efforts on designing the best API. Sometimes this means releasing a “throwaway” implementation that you know you’ll replace in a future release. Normally this is not a problem, but if the class implements Serializable and uses the default serialized form, you’ll never be able to escape completely from the throwaway implementation. It will dictate the serialized form forever. This is not just a theoretical problem. It happened to several classes in the Java libraries, including BigInteger.</span></div><div><br/></div><div><span style="font-weight: bold; color: rgb(51, 51, 51);">Do not accept the default serialized form without first considering whether it is appropriate.</span><span style="color: rgb(51, 51, 51);"> Accepting the default serialized form should be a conscious decision that this encoding is reasonable from the standpoint of flexibility, performance, and correctness. Generally speaking, you should accept the default serialized form only if it is largely identical to the encoding that you would choose if you were designing a custom serialized form.</span></div><div><br/></div><div><span style="font-weight: bold; color: rgb(51, 51, 51);">Even if you decide that the default serialized form is appropriate, you often must provide a</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">readObject</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">method to ensure invariants and security.</span><span style="color: rgb(51, 51, 51);"> In the case of Name, the readObject method must ensure that the fields lastName and firstName are non-null. </span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Whether or not you use the default serialized form, </span><span style="font-weight: bold; color: rgb(51, 51, 51);">you must impose any synchronization on object serialization that you would impose on any other method that reads the entire state of the object.</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/351pro01.jpg" width="579.01171875"></img></div><div><br/></div><div><span style="font-weight: bold; color: rgb(51, 51, 51);">Regardless of what serialized form you choose, declare an explicit serial version UID in every serializable class you write.</span><span style="color: rgb(51, 51, 51);"> This eliminates the serial version UID as a potential source of incompatibility (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch12.xhtml#lev86" style="color: rgb(7, 7, 7);">Item 86</a><span style="color: rgb(51, 51, 51);">). There is also a small performance benefit. If no serial version UID is provided, an expensive computation is performed to generate one at runtime.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">If you ever want to make a new version of a class that is </span><span style="font-style: italic; color: rgb(51, 51, 51);">incompatible</span><span style="color: rgb(51, 51, 51);"> with existing versions, merely change the value in the serial version UID declaration. This will cause attempts to deserialize serialized instances of previous versions to throw an InvalidClassException. </span><span style="font-weight: bold; color: rgb(51, 51, 51);">Do not change the serial version UID unless you want to break compatibility with all existing serialized instances of a class.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><h3 style="text-align:start;"><span style="color: rgb(64, 64, 64); font-weight: bold;">WRITE</span><span style="color: rgb(64, 64, 64);"> </span><span style="color: rgb(64, 64, 64); font-weight: bold;">READOBJECT</span><span style="color: rgb(64, 64, 64);"> </span><span style="color: rgb(64, 64, 64); font-weight: bold;">METHODS DEFENSIVELY</span></h3></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">Loosely speaking, readObject is a constructor that takes a byte stream as its sole parameter. In normal use, the byte stream is generated by serializing a normally constructed instance. The problem arises when readObject is presented with a byte stream that is artificially constructed to generate an object that violates the invariants of its class. Such a byte stream can be used to create an </span><span style="font-style: italic; color: rgb(51, 51, 51);">impossible object</span><span style="color: rgb(51, 51, 51);">, which could not have been created using a normal constructor.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">To fix this problem, provide a readObject method for the serialized object that calls defaultReadObject and then checks the validity of the deserialized object. If the validity check fails, the readObject method throws InvalidObjectException, preventing the deserialization from completing. Furthermore</span> <span style="font-weight: bold; color: rgb(51, 51, 51);">when an object is deserialized, it is critical to defensively copy any field containing an object reference that a client must not possess.</span><span style="color: rgb(51, 51, 51);"> Therefore, every serializable immutable class containing private mutable components must defensively copy these components in its readObject method. The following readObject method suffices to ensure Period’s invariants and to maintain its immutability:</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/357pro02.jpg" width="580.76171875"></img></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">To summarize, anytime you write a readObject method, adopt the mind-set that you are writing a public constructor that must produce a valid instance regardless of what byte stream it is given. Do not assume that the byte stream represents an actual serialized instance. While the examples in this item concern a class that uses the default serialized form, all of the issues that were raised apply equally to classes with custom serialized forms.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><h3 style="text-align:start;"><span style="color: rgb(64, 64, 64);"><span style="color: rgb(64, 64, 64); font-weight: bold;">FOR INSTANCE CONTROL, PREFER ENUM TYPES TO</span> <span style="color: rgb(64, 64, 64); font-weight: bold;">READRESOLVE</span></span></h3></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">Item 3 describes the </span><span style="font-style: italic; color: rgb(51, 51, 51);">Singleton</span><span style="color: rgb(51, 51, 51);"> pattern and gives the following example of a singleton class. This class restricts access to its constructor to ensure that only a single instance is ever created. As noted in </span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch2.xhtml#lev3" style="color: rgb(7, 7, 7);">Item 3</a><span style="color: rgb(51, 51, 51);">, this class would no longer be a singleton if the words implements Serializable were added to its declaration. It doesn’t matter whether the class uses the default serialized form or a custom serialized form (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch12.xhtml#lev87" style="color: rgb(7, 7, 7);">Item 87</a><span style="color: rgb(51, 51, 51);">), nor does it matter whether the class provides an explicit readObject method (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch12.xhtml#lev88" style="color: rgb(7, 7, 7);">Item 88</a><span style="color: rgb(51, 51, 51);">). Any readObject method, whether explicit or default, returns a newly created instance, which will not be the same instance that was created at class initialization time.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The readResolve feature allows you to substitute another instance for the one created by readObject [Serialization, 3.7]. If the class of an object being deserialized defines a readResolve method with the proper declaration, this method is invoked on the newly created object after it is deserialized. The object reference returned by this method is then returned in place of the newly created object. In most uses of this feature, no reference to the newly created object is retained, so it immediately becomes eligible for garbage collection.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">This method ignores the deserialized object, returning the distinguished Elvis instance that was created when the class was initialized. Therefore, the serialized form of an Elvis instance need not contain any real data; all instance fields should be declared transient. In fact, </span><span style="font-weight: bold; color: rgb(51, 51, 51);">if you depend on</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">readResolve</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">for instance</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">control, all instance fields with object reference types</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; font-style: italic; color: rgb(51, 51, 51);">must</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">be declared</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">transient.</span><span style="color: rgb(51, 51, 51);"> Otherwise, it is possible for a determined attacker to secure a reference to the deserialized object before its readResolve method is run, using a technique that is somewhat similar to the MutablePeriod attack in </span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch12.xhtml#lev88" style="color: rgb(7, 7, 7);">Item 88</a><span style="color: rgb(51, 51, 51);">.</span></div><div><br/></div><div><span style="font-weight: bold; color: rgb(51, 51, 51);">The accessibility of</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">readResolve</span><span style="color: rgb(51, 51, 51);"> </span><span style="font-weight: bold; color: rgb(51, 51, 51);">is significant.</span><span style="color: rgb(51, 51, 51);"> If you place a readResolve method on a final class, it should be private. If you place a readResolve method on a nonfinal class, you must carefully consider its accessibility. If it is private, it will not apply to any subclasses. If it is package-private, it will apply only to subclasses in the same package. If it is protected or public, it will apply to all subclasses that do not override it. If a readResolve method is protected or public and a subclass does not override it, deserializing a subclass instance will produce a superclass instance, which is likely to cause a ClassCastException.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">To summarize, use enum types to enforce instance control invariants wherever possible. If this is not possible and you need a class to be both serializable and instance-controlled, you must provide a readResolve method and ensure that all of the class’s instance fields are either primitive or transient.</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;" width="1236px"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><h3 style="text-align:start;"><span style="color: rgb(64, 64, 64); font-weight: bold;">CONSIDER SERIALIZATION PROXIES INSTEAD OF SERIALIZED INSTANCES</span></h3></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div><span style="color: rgb(51, 51, 51);">As mentioned in Items 85 and 86 and discussed throughout this chapter, the decision to implement Serializable increases the likelihood of bugs and security problems as it allows instances to be created using an extralinguistic mechanism in place of ordinary constructors. There is, however, a technique that greatly reduces these risks. This technique is known as the </span><span style="font-style: italic; color: rgb(51, 51, 51);">serialization proxy pattern</span><span style="color: rgb(51, 51, 51);">.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The serialization proxy pattern is reasonably straightforward. First, design a private static nested class that concisely represents the logical state of an instance of the enclosing class. This nested class is known as the </span><span style="font-style: italic; color: rgb(51, 51, 51);">serialization proxy</span><span style="color: rgb(51, 51, 51);"> of the enclosing class. It should have a single constructor, whose parameter type is the enclosing class. This constructor merely copies the data from its argument: it need not do any consistency checking or defensive copying. By design, the default serialized form of the serialization proxy is the perfect serialized form of the enclosing class. Both the enclosing class and its serialization proxy must be declared to implement Serializable.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">For example, consider the immutable Period class written in </span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch8.xhtml#lev50" style="color: rgb(7, 7, 7);">Item 50</a><span style="color: rgb(51, 51, 51);"> and made serializable in </span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch12.xhtml#lev88" style="color: rgb(7, 7, 7);">Item 88</a><span style="color: rgb(51, 51, 51);">. Here is a serialization proxy for this class. Period is so simple that its serialization proxy has exactly the same fields as the class:</span></div><div><br/></div><div><img src="effective java_files/Image [28].jpg" type="image/jpeg" data-filename="Image.jpg" alt="Image" width="581.76171875"/></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Next, add the following writeReplace method to the enclosing class. This method can be copied verbatim into any class with a serialization proxy:</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/363pro02.jpg" width="548.76171875"></img></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The presence of this method on the enclosing class causes the serialization system to emit a SerializationProxy instance instead of an instance of the enclosing class. In other words, the writeReplace method translates an instance of the enclosing class to its serialization proxy prior to serialization.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">With this writeReplace method in place, the serialization system will never generate a serialized instance of the enclosing class, but an attacker might fabricate one in an attempt to violate the class’s invariants. To guarantee that such an attack would fail, merely add this readObject method to the enclosing class:</span></div><div><br/></div><div><img alt="Image" src="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/graphics/364pro01.jpg" width="502.76171875"></img></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Finally, provide a readResolve method on the SerializationProxy class that returns a logically equivalent instance of the enclosing class. The presence of this method causes the serialization system to translate the serialization proxy back into an instance of the enclosing class upon deserialization.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">This readResolve method creates an instance of the enclosing class using only its public API and therein lies the beauty of the pattern. It largely eliminates the extralinguistic character of serialization, because the deserialized instance is created using the same constructors, static factories, and methods as any other instance. This frees you from having to separately ensure that deserialized instances obey the class’s invariants. If the class’s static factories or constructors establish these invariants and its instance methods maintain them, you’ve ensured that the invariants will be maintained by serialization as well.</span></div><div><span style="color: rgb(51, 51, 51);">Here is the readResolve method for Period.SerializationProxy above:</span></div><div><br/></div><div><img src="effective java_files/Image [29].jpg" type="image/jpeg" data-filename="Image.jpg" alt="Image" width="561.76171875"/></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">Like the defensive copying approach (page 357), the serialization proxy approach stops the bogus byte-stream attack (page 354) and the internal field theft attack (page 356) dead in their tracks. Unlike the two previous approaches, this one allows the fields of Period to be final, which is required in order for the Period class to be truly immutable (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch4.xhtml#lev17" style="color: rgb(7, 7, 7);">Item 17</a><span style="color: rgb(51, 51, 51);">). And unlike the two previous approaches, this one doesn’t involve a great deal of thought. You don’t have to figure out which fields might be compromised by devious serialization attacks, nor do you have to explicitly perform validity checking as part of deserialization.</span></div><div><br/></div><div><span style="color: rgb(51, 51, 51);">The serialization proxy pattern has two limitations. It is not compatible with classes that are extendable by their users (</span><a href="https://learning.oreilly.com/library/view/effective-java-3rd/9780134686097/ch4.xhtml#lev19" style="color: rgb(7, 7, 7);">Item 19</a><span style="color: rgb(51, 51, 51);">). Also, it is not compatible with some classes whose object graphs contain circularities: if you attempt to invoke a method on such an object from within its serialization proxy’s readResolve method, you’ll get a ClassCastException because you don’t have the object yet, only its serialization proxy.</span></div><div><span style="color: rgb(51, 51, 51);">Finally, the added power and safety of the serialization proxy pattern are not free. On my machine, it is 14 percent more expensive to serialize and deserialize Period instances with serialization proxies than it is with defensive copying.</span></div><div><span style="color: rgb(51, 51, 51);">In summary, consider the serialization proxy pattern whenever you find yourself having to write a readObject or writeObject method on a class that is not extendable by its clients. This pattern is perhaps the easiest way to robustly serialize objects with nontrivial invariants.</span></div></td></tr></tbody></table><div><br/></div></div></span>
</div></body></html> 