<html>
<head>
  <title>Evernote Export</title>
  <basefont face="Segoe UI" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/309091 (it-IT, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: Segoe UI;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="809"/>

<div>
<span><div><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div>Write the <span style="font-weight: bold;">mergesort</span> algorithm and describe memory and time complexity. What kind on improvent can be done?</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div>The mergesort takes O(nlogn) time complexity (for average case and worst case) and O(n) auxiliary memory (because of the auxiliary arrays)</div><div><br/></div><div><span style="font-family: &quot;Courier New&quot;;">public class Merge {</span></div><div><span style="font-family: &quot;Courier New&quot;;">  public static void sort(Comparable[] a) {</span></div><div><span style="font-family: &quot;Courier New&quot;;">    aux = new Comparable[a.length];</span></div><div><span style="font-family: &quot;Courier New&quot;;">    sort(a, aux, 0, a.length - 1);</span></div><div><span style="font-family: &quot;Courier New&quot;;">  }</span></div><div><span style="font-family: &quot;Courier New&quot;;">  private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) {</span></div><div><span style="font-family: &quot;Courier New&quot;;">    if (hi &lt;= lo) return;</span></div><div><span style="font-family: &quot;Courier New&quot;;">    int mid = lo + (hi - lo) / 2;</span></div><div><span style="font-family: &quot;Courier New&quot;;">    sort(a, aux, lo, mid);</span></div><div><span style="font-family: &quot;Courier New&quot;;">    sort(a, aux, mid + 1, hi);</span></div><div><span style="font-family: &quot;Courier New&quot;;">    merge(a, aux, lo, mid, hi);</span></div><div><span style="font-family: &quot;Courier New&quot;;">  }</span></div><div><span style="font-family: &quot;Courier New&quot;;">  private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) {</span></div><div><span style="font-family: &quot;Courier New&quot;;">    for (int k = lo; k &lt;= hi; k++)</span></div><div><span style="font-family: &quot;Courier New&quot;;">      aux[k] = a[k];</span></div><div><span style="font-family: &quot;Courier New&quot;;">    int i = lo, j = mid + 1;</span></div><div><span style="font-family: &quot;Courier New&quot;;">    for (int k = lo; k &lt;= hi; k++) {</span></div><div><span style="font-family: &quot;Courier New&quot;;">      if (i &gt; mid) a[k] = aux[j++];</span></div><div><span style="font-family: &quot;Courier New&quot;;">      else if (j &gt; hi) a[k] = aux[i++];</span></div><div><span style="font-family: &quot;Courier New&quot;;">      else if (less(aux[j], aux[i])) a[k] = aux[j++];</span></div><div><span style="font-family: &quot;Courier New&quot;;">      else a[k] = aux[i++];</span></div><div><span style="font-family: &quot;Courier New&quot;;">    }</span></div><div><span style="font-family: &quot;Courier New&quot;;">  }</span></div><div><span style="font-family: &quot;Courier New&quot;;">}</span></div><div><br/></div><div>Improvements that can be done are:</div><ul><li><div>Cut-off for array with size &lt;= 7. Since merge-sort has extra overhead for small arrays, we can merge sort until the array has a small size (canonical value is 7)</div></li></ul><div><span style="font-family: &quot;Courier New&quot;;">private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) {</span></div><div><span style="font-family: &quot;Courier New&quot;;">  </span><span style="font-family: &quot;Courier New&quot;; font-weight: bold;">if (hi &lt;= lo + CUTOFF - 1) {</span></div><div><span style="font-family: &quot;Courier New&quot;; font-weight: bold;">    Insertion.sort(a, lo, hi);</span></div><div><span style="font-family: &quot;Courier New&quot;; font-weight: bold;">    return;</span></div><div><span style="font-family: &quot;Courier New&quot;; font-weight: bold;">  }</span></div><div><span style="font-family: &quot;Courier New&quot;;">  int mid = lo + (hi - lo) / 2;</span></div><div><span style="font-family: &quot;Courier New&quot;;">  sort(a, aux, lo, mid);</span></div><div><span style="font-family: &quot;Courier New&quot;;">  sort(a, aux, mid + 1, hi);</span></div><div><span style="font-family: &quot;Courier New&quot;;">  merge(a, aux, lo, mid, hi);</span></div><div><span style="font-family: &quot;Courier New&quot;;">}</span></div><div><br/></div><ul><li><div>Stop if the array is sorted. If the biggest element in the first half is less than the smallest item of the second half then we know that means that we don't need to sort the array. This improvement helps for partially-ordered arrays.</div></li></ul><div><span style="font-family: &quot;Courier New&quot;;">private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) {</span></div><div><span style="font-family: &quot;Courier New&quot;;">  if (hi &lt;= lo) return;</span></div><div><span style="font-family: &quot;Courier New&quot;;">  int mid = lo + (hi - lo) / 2;</span></div><div><span style="font-family: &quot;Courier New&quot;;">  sort(a, aux, lo, mid);</span></div><div><span style="font-family: &quot;Courier New&quot;;">  sort(a, aux, mid + 1, hi);</span></div><div><span style="font-family: &quot;Courier New&quot;; font-weight: bold;">  if (!less(a[mid + 1], a[mid])) return;</span></div><div><span style="font-family: &quot;Courier New&quot;;">  merge(a, aux, lo, mid, hi);</span></div><div><span style="font-family: &quot;Courier New&quot;;">}</span></div><div><br/></div><ul><li><div><span style="font-family: &quot;Courier New&quot;;">Eliminate the cpy to the auxiliary array. We can save time (but not space) by switching the role of the input and auxiliary array in each recursive call.</span></div></li></ul><div><span style="font-family: &quot;Courier New&quot;;">private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) {</span></div><div><span style="font-family: &quot;Courier New&quot;;">  if (hi &lt;= lo) return;</span></div><div><span style="font-family: &quot;Courier New&quot;;">  int mid = lo + (hi - lo) / 2;</span></div><div><span style="font-family: &quot;Courier New&quot;;">  <span style="font-family: &quot;Courier New&quot;; font-weight: bold;">sort(aux, a, lo, mid);</span></span></div><div><span style="font-family: &quot;Courier New&quot;; font-weight: bold;">  sort(aux, a, mid + 1, hi);</span></div><div><span style="font-family: &quot;Courier New&quot;; font-weight: bold;">  merge(a, aux, lo, mid, hi);</span></div><div><span style="font-family: &quot;Courier New&quot;;">}</span></div><div><br/></div><div>It is worth to take note that merge sort is optimal in time complexity but not in memory complexity (it can be demonstrate that sorting algorithm have a lower bound time complexity of nlogn time)</div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div>Write the algorithm for the <span style="font-weight: bold;">bottom-up merge sort</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div>The bottom-up merge sort is an alternative version of the merge sort for which no recursion is done.</div><div><br/></div><div><span style="font-family: &quot;Courier New&quot;;">  public static void sort(Comparable[] a) {</span></div><div><span style="font-family: &quot;Courier New&quot;;">    int N = a.length;</span></div><div><span style="font-family: &quot;Courier New&quot;;">    Comparable[] aux = new Comparable[N];</span></div><div><span style="font-family: &quot;Courier New&quot;;">    for (int sz = 1; sz &lt; N; sz = sz + sz)</span></div><div><span style="font-family: &quot;Courier New&quot;;">      for (int lo = 0; lo &lt; N - sz; lo += sz + sz)</span></div><div><span style="font-family: &quot;Courier New&quot;;">        merge(a, aux, lo, lo + sz - 1, Math.min(lo + sz + sz - 1, N - 1));</span></div><div><span style="font-family: &quot;Courier New&quot;;">  }</span></div><div><br/></div><div><span style="font-family: &quot;Courier New&quot;;">private static void merge(...) {</span></div><div><span style="font-family: &quot;Courier New&quot;;"> </span> <span style="font-family: &quot;Courier New&quot;;">for (int k = lo; k &lt;= hi; k++)</span></div><div><span style="font-family: &quot;Courier New&quot;;">      aux[k] = a[k];</span></div><div><span style="font-family: &quot;Courier New&quot;;">    int i = lo, j = mid + 1;</span></div><div><span style="font-family: &quot;Courier New&quot;;">    for (int k = lo; k &lt;= hi; k++) {</span></div><div><span style="font-family: &quot;Courier New&quot;;">      if (i &gt; mid) a[k] = aux[j++];</span></div><div><span style="font-family: &quot;Courier New&quot;;">      else if (j &gt; hi) a[k] = aux[i++];</span></div><div><span style="font-family: &quot;Courier New&quot;;">      else if (less(aux[j], aux[i])) a[k] = aux[j++];</span></div><div><span style="font-family: &quot;Courier New&quot;;">      else a[k] = aux[i++];</span></div><div><span style="font-family: &quot;Courier New&quot;;">    }</span><span style="font-family: &quot;Courier New&quot;;"> </span></div><div><span style="font-family: &quot;Courier New&quot;;">}</span></div><div><br/></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div>Write the algorithm for the <span style="font-weight: bold;">quicksort</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div>Time complexity for this algorithm is O(NlogN) for best and average case, while the worst case can be O(n^2) but using the shuffle (or another technique) eliminates this bug. Also quicksort use constant memory complexity (due to the swap function)</div><div><br/></div><div><span style="font-family: &quot;Courier New&quot;;">public class Quick {</span></div><div><span style="font-family: &quot;Courier New&quot;;">  public static void sort(Comparable[] a) {</span></div><div><span style="font-family: &quot;Courier New&quot;;">    StdRandom.shuffle(a); // shuffle need for performance guarantee</span></div><div><span style="font-family: &quot;Courier New&quot;;">    sort(a, 0, a.length - 1);</span></div><div><span style="font-family: &quot;Courier New&quot;;">  }</span></div><div><span style="font-family: &quot;Courier New&quot;;">  private static void sort(Comparable[] a, int lo, int hi) {</span></div><div><span style="font-family: &quot;Courier New&quot;;">    if (hi &lt;= lo) return;</span></div><div><span style="font-family: &quot;Courier New&quot;;">    int j = partition(a, lo, hi);</span></div><div><span style="font-family: &quot;Courier New&quot;;">    sort(a, lo, j - 1);</span></div><div><span style="font-family: &quot;Courier New&quot;;">    sort(a, j + 1, hi);</span></div><div><span style="font-family: &quot;Courier New&quot;;">  }</span></div><div><br/></div><div><span style="font-family: &quot;Courier New&quot;;">  private static int partition(Comparable[] a, int lo, int hi) {</span></div><div><span style="font-family: &quot;Courier New&quot;;">    int i = lo, j = hi + 1;</span></div><div><span style="font-family: &quot;Courier New&quot;;">    while (true) {</span></div><div><span style="font-family: &quot;Courier New&quot;;">      while (less(a[++i], a[lo])) // find item on left to swap</span></div><div><span style="font-family: &quot;Courier New&quot;;">        if (i == hi) break;</span></div><div><span style="font-family: &quot;Courier New&quot;;">      while (less(a[lo], a[--j])) // find item on right to swap</span></div><div><span style="font-family: &quot;Courier New&quot;;">        if (j == lo) break;</span></div><div><br/></div><div><span style="font-family: &quot;Courier New&quot;;">      if (i &gt;= j) break; // check if pointers cross</span></div><div><span style="font-family: &quot;Courier New&quot;;">      exch(a, i, j); // swap</span></div><div><span style="font-family: &quot;Courier New&quot;;">    }</span></div><div><span style="font-family: &quot;Courier New&quot;;">    exch(a, lo, j); // swap with partitioning item</span></div><div><span style="font-family: &quot;Courier New&quot;;">    return j; // return index of item now known to be in place</span></div><div><span style="font-family: &quot;Courier New&quot;;">  }</span></div><div><span style="font-family: &quot;Courier New&quot;;">}</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div>Write the algorithm for the <span style="font-weight: bold;">quickSelect.</span> Describe time and memory complexity</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div>QuickSelect takes constant memory and linear time complexity on average. Is an algorithm used by problems like &quot;find the kth smallest element in a collection.&quot;</div><div><br/></div><div><span style="font-family: &quot;Courier New&quot;;">public static Comparable select(Comparable[] a, int k) {</span></div><div><span style="font-family: &quot;Courier New&quot;;">  StdRandom.shuffle(a);</span></div><div><span style="font-family: &quot;Courier New&quot;;">  int lo = 0, hi = a.length - 1;</span></div><div><span style="font-family: &quot;Courier New&quot;;">  while (hi &gt; lo) {</span></div><div><span style="font-family: &quot;Courier New&quot;;">    int j = partition(a, lo, hi);</span></div><div><span style="font-family: &quot;Courier New&quot;;">    if (j &lt; k) lo = j + 1;</span></div><div><span style="font-family: &quot;Courier New&quot;;">    else if (j &gt; k) hi = j - 1;</span></div><div><span style="font-family: &quot;Courier New&quot;;">    else return a[k];</span></div><div><span style="font-family: &quot;Courier New&quot;;">  }</span></div><div><span style="font-family: &quot;Courier New&quot;;">  return a[k];</span></div><div><br/></div><div><span style="font-family: &quot;Courier New&quot;;">  private static int partition(Comparable[] a, int lo, int hi) {</span></div><div><span style="font-family: &quot;Courier New&quot;;">    int i = lo, j = hi + 1;</span></div><div><span style="font-family: &quot;Courier New&quot;;">    while (true) {</span></div><div><span style="font-family: &quot;Courier New&quot;;">      while (less(a[++i], a[lo])) // find item on left to swap</span></div><div><span style="font-family: &quot;Courier New&quot;;">        if (i == hi) break;</span></div><div><span style="font-family: &quot;Courier New&quot;;">      while (less(a[lo], a[--j])) // find item on right to swap</span></div><div><span style="font-family: &quot;Courier New&quot;;">        if (j == lo) break;</span></div><div><br/></div><div><span style="font-family: &quot;Courier New&quot;;">      if (i &gt;= j) break; // check if pointers cross</span></div><div><span style="font-family: &quot;Courier New&quot;;">      exch(a, i, j); // swap</span></div><div><span style="font-family: &quot;Courier New&quot;;">    }</span></div><div><span style="font-family: &quot;Courier New&quot;;">    exch(a, lo, j); // swap with partitioning item</span></div><div><span style="font-family: &quot;Courier New&quot;;">    return j; // return index of item now known to be in place</span></div><div><span style="font-family: &quot;Courier New&quot;;">  }</span></div><div><br/></div><div><span style="font-family: &quot;Courier New&quot;;">}</span></div></td></tr></tbody></table><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 1236px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div>Write the algorithm for the <b>3-way quicksort</b></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 1236px; padding: 8px;"><div>The 3-way quicksort is performant for arrays with a lot of duplicates. </div><div>Randomized quicksort with 3-way partitioning reduces wunning time from linearithmic to linear in broad class of applications.</div><div>The algorithm is the following:</div><div><br/></div><div><font face="Courier New">private static void sort(Comparable[] a, int lo, int hi) {</font></div><div><font face="Courier New">  if (hi &lt;= lo) return;</font></div><div><font face="Courier New">  int lt = lo, gt = hi;</font></div><div><font face="Courier New">  Comparable v = a[lo];</font></div><div><font face="Courier New">  int i = lo;</font></div><div><font face="Courier New">  while (i &lt;= gt) {</font></div><div><font face="Courier New">    int cmp = a[i].compareTo(v);</font></div><div><font face="Courier New">    if (cmp &lt; 0) exch(a, lt++, i++);</font></div><div><font face="Courier New">    else if (cmp &gt; 0) exch(a, i, gt--);</font></div><div><font face="Courier New">    else i++;</font></div><div><font face="Courier New">  }</font></div><div><font face="Courier New">  sort(a, lo, lt - 1);</font></div><div><font face="Courier New">  sort(a, gt + 1, hi);</font></div><div><font face="Courier New">}</font></div></td></tr></tbody></table><div><br/></div></div></span>
</div></body></html> 